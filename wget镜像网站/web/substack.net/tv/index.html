<!DOCTYPE html>
<html>
<head>
<title>analog video simulation</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta charset=utf-8></head>
<body></body>
<script>(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports = function (regl) {
  return regl({
    frag: `
      precision highp float;
      varying vec2 vpos;
      uniform float time;
      void main () {
        gl_FragColor = vec4(vec3(0),1);
      }
    `,
    vert: `
      precision highp float;
      attribute vec2 position;
      varying vec2 vpos;
      void main () {
        vpos = position;
        gl_Position = vec4(position,0,1);
      }
    `,
    attributes: { position: [-4,-4,-4,+4,+4,+0] },
    elements: [0,1,2],
    uniforms: {
      time: regl.context('time')
    },
    depth: { enable: false }
  })
}

},{}],2:[function(require,module,exports){
var html = require('choo/html')
var resl = require('resl')
var el = require('./lib/elem.js')()

module.exports = function(regl) {
  var draw = regl({
    frag: `
      precision highp float;
      varying vec2 vpos;
      uniform sampler2D img;
      void main () {
        vec2 uv = vpos*vec2(1,-1)*0.5+0.5;
        vec3 rgb = texture2D(img,uv).xyz;
        gl_FragColor = vec4(rgb,1);
      }
    `,
    vert: `
      precision highp float;
      attribute vec2 position;
      varying vec2 vpos;
      void main () {
        vpos = position;
        gl_Position = vec4(position,0,1);
      }
    `,
    attributes: { position: [-4,-4,-4,+4,+4,+0] },
    elements: [0,1,2],
    uniforms: {
      img: regl.prop('img')
    },
    depth: { enable: false }
  })
  var props = { img: regl.texture() }
  resl({
    manifest: {
      img: { type: 'image', src: 'images/books.jpg' },
    },
    onDone: (assets) => {
      props.img = regl.texture(assets.img)
    }
  })
  el.element.appendChild(html`<div class="hyperlinks">
    <style>
      .hyperlinks {
        position: absolute;
        top: 20%;
        left: 5%;
        right: 10%;
        bottom: 10%;
        font-size: 2em;
        font-family: monospace;
        color: white;
        text-shadow: 2px 2px magenta;
      }
    </style>
    <ul>
      <li>digital video and dsp. keith jack [chapter 6]</li>
      <li>modern cable television technology. ciciora, farmer, large, adams. [chapter 2]</li>
      <li>television engineering and video systems. gupta</li>
    </ul>
  </div>`)
  return function() {
    el.touch()
    regl.clear({ color: [0,0,0,1], depth: true })
    draw(props)
  }
}

},{"./lib/elem.js":10,"choo/html":17,"resl":164}],3:[function(require,module,exports){
module.exports = function (regl) {
  var positions = [], cells = [], digits = []
  var ndigits = 2
  for (var n = 0; n < ndigits; n++) {
    var k = positions.length/2
    positions.push(-1,-1, -1,+1, +1,+1, +1,-1)
    digits.push(n,n,n,n)
    cells.push(k+0,k+1,k+2,k+0,k+2,k+3)
  }
  return regl({
    frag: `
      precision highp float;
      varying vec2 vpos;
      varying float vdigit;
      uniform float time, channel;
      uniform sampler2D font;

      float text(sampler2D font, vec2 uv, vec2 t) {
        return length(texture2D(font,uv/vec2(32,3)+vec2(t.x/32.0,t.y/3.0)).xyz)
          * (1.0/sqrt(3.0));
      }
      vec3 shadow(vec2 v, vec2 r) {
        float sy = floor(mod(v.x*r.x,2.0))/r.x*0.5;
        return vec3(
          step(mod(v.x*r.x*3.0+2.0,3.0),1.0),
          step(mod(v.x*r.x*3.0+1.0,3.0),1.0),
          step(mod(v.x*r.x*3.0+0.0,3.0),1.0)
        ) * (1.0-step(mod(((v.y+sy)*r.y)*3.0,3.0),0.5));
      }
      void main () {
        vec2 uv = vpos*vec2(1,-1)*0.5+0.5;
        float d = mod(floor(channel/pow(10.0,vdigit)),10.0);
        vec2 c = vec2(15.0+d,0.0);
        vec3 rgb = text(font, uv, c)*vec3(0,1,0.5);
        vec2 r = vec2(720,485);
        vec3 mrgb = mix(rgb,rgb*shadow(uv,r),0.1);
        gl_FragColor = vec4(mrgb,clamp(0.0,1.0,length(rgb)*step(vdigit-0.5,d)));
      }
    `,
    vert: `
      precision highp float;
      attribute vec2 position;
      attribute float digit;
      varying vec2 vpos;
      varying float vdigit;
      void main () {
        vpos = position;
        vdigit = digit;
        gl_Position = vec4(position*vec2(0.07,0.2)+vec2(0.8-0.13*digit,0.8),0,1);
      }
    `,
    attributes: {
      position: positions,
      digit: digits
    },
    elements: cells,
    uniforms: {
      time: regl.context('time'),
      channel: regl.prop('channel'),
      font: regl.prop('font')
    },
    depth: { enable: false },
    blend: {
      enable: true,
      func: { src: 'src alpha', dst: 'one minus src alpha' }
    }
  })
}

},{}],4:[function(require,module,exports){
var html = require('choo/html')
var resl = require('resl')
var el = require('./lib/elem.js')()

module.exports = function(regl) {
  var draw = regl({
    frag: `
      precision highp float;
      varying vec2 vpos;
      uniform sampler2D img;
      void main () {
        vec2 uv = vpos*vec2(1,-1)*0.5+0.5;
        vec3 rgb = texture2D(img,uv).xyz;
        gl_FragColor = vec4(rgb,1);
      }
    `,
    vert: `
      precision highp float;
      attribute vec2 position;
      varying vec2 vpos;
      void main () {
        vpos = position;
        gl_Position = vec4(position,0,1);
      }
    `,
    attributes: { position: [-4,-4,-4,+4,+4,+0] },
    elements: [0,1,2],
    uniforms: {
      img: regl.prop('img')
    },
    depth: { enable: false }
  })
  var props = { img: regl.texture() }
  resl({
    manifest: {
      img: { type: 'image', src: 'images/code.jpg' },
    },
    onDone: (assets) => {
      props.img = regl.texture(assets.img)
    }
  })
  el.element.appendChild(html`<div class="hyperlinks">
    <style>
      .hyperlinks {
        position: absolute;
        top: 20%;
        left: 5%;
        right: 10%;
        bottom: 10%;
        font-size: 2em;
        font-family: monospace;
        color: lightgreen;
        text-shadow: 2px 2px purple;
      }
      .hyperlinks a:link {
        color: white;
        text-shadow: 2px 2px blue;
      }
      .hyperlinks a:visited {
        color: white;
        text-shadow: 1px 1px purple;
      }
      .hyperlinks .neocities {
        margin-top: 2em;
      }
      .hyperlinks .neocities span {
        display: inline-block;
        height: 107px;
        vertical-align: middle;
        margin-left: 1ex;
      }
    </style>
    <ul>
      <li><a href="https://github.com/substack/glsl-ntsc-video">glsl-ntsc-video</a></li>
      <li><a href="https://github.com/substack/ntsc-video-simulator">ntsc-video-simulator</a></li>
      <li><a href="https://github.com/substack/analog-tv-simulation">analog-tv-simulation</a></li>
    </ul>
    <div class="neocities">
      <a href="https://neocities.org/site/substack"
        ><img src="images/neocities-cat.png" width="130" height="107">
        <span>follow me on neocities</span></a>
    </div>
  </div>`)
  return function() {
    el.touch()
    regl.clear({ color: [0,0,0,1], depth: true })
    draw(props)
  }
}

},{"./lib/elem.js":10,"choo/html":17,"resl":164}],5:[function(require,module,exports){
var mat4 = require('gl-mat4')
var vec3 = require('gl-vec3')
var quat = require('gl-quat')
var extrudeByPath = require('extrude-by-path')

var html = require('choo/html')
var app = require('choo')()

var rstate = {
  azimuth: 0
}

app.use((state, emitter) => {
  state.azimuth = 0
  emitter.on('set-azimuth', (az) => {
    state.azimuth = az
    rstate.azimuth = az/180*Math.PI
    emitter.emit('render')
  })
})

app.route('*', (state, emit) => {
  return html`<div class="ui">
    <style>
      .ui {
        position: absolute;
        left: 0px;
        right: 0px;
        bottom: 1em;
        text-align: center;
        z-index: 5000;
        color: white;
        font-size: 3em;
        font-family: monospace;
      }
      .ui input {
        margin-right: 1ex;
      }
      .ui .az {
        display: inline-block;
        width: 3ex;
        text-align: right;
      }
    </style>
    azimuth
    <input type="range" min="-45" max="45" step="1" value="${state.azimuth}"
      oninput=${(ev) => emit('set-azimuth', Number(ev.target.value))}>
    <span class="az">${state.azimuth}</span> degrees
  </div>`
})
var el = require('./lib/elem.js')()
app.mount(el.element)

var tmpq = [0,0,0,1]
var tmpv = [0,0,0]
var tmpm = new Float32Array(16)
var forward = [0,0,1]

var props = {
  solid: [],
  wave: []
}

;(function() { // ferrous ring
  var path = []
  var N = 64, gap = 1/64
  for (var i = 0; i <= N; i++) {
    var theta = i/N*2*Math.PI*(1-gap)
    var r = 0.3
    path.push([
      Math.cos(theta)*r,
      0,
      Math.sin(theta)*r
    ])
  }
  var m = extrudeByPath({
    positions: [
      [+0.1,-0.15],
      [+0.1,+0.15],
      [-0.1,+0.15],
      [-0.1,-0.15]
    ],
    cells: [[0,1,2],[0,2,3]],
    edges: [[0,1],[1,2],[2,3],[3,0]],
    path
  })
  m.colors = m.positions.map(p => {
    return [0,0,0]
  })
  m.model = mat4.identity(new Float32Array(16))
  props.solid.push(m)
})()

;(function() { // tape
  props.solid.push({
    positions: [
      -0.15, +0.0, -5,
      +0.15, +0.0, -5,
      +0.15, +0.0, +5,
      -0.15, +0.0, +5,
    ],
    colors: [ 0.7,0,1, 0.7,0,1, 0.7,0,1, 0.7,0,1 ],
    cells: [0,1,2,0,2,3],
    model: mat4.identity(new Float32Array(16))
  })
})()

;(function() { // coil
  var path = []
  var R = 0.29, r = 0.18, i = 0, m = 32, n = 32*2, l = 1
  for (var k = m-1; k <= m*3-2; k++) {
    var t = 2*Math.PI*(k+0.5)/(4*n)
    path.push([ 
      Math.cos(t)*(R-r*Math.cos(2*Math.PI*i/m+l*n*t)),
      Math.sin(t)*(R-r*Math.cos(2*Math.PI*i/m+l*n*t)),
      r*Math.sin(2*Math.PI*i/m+l*n*t)*1.25
    ])
  }
  path.unshift(
    [
      path[0][0]+1,
      path[0][1],
      path[0][2]-0.25,
    ],
    [
      path[0][0],
      path[0][1],
      path[0][2]-0.25,
    ]
  )
  var k = path.length-1
  path.push(
    [
      path[k][0],
      path[k][1],
      path[k][2]-0.25,
    ],
    [
      path[k][0]+1.4,
      path[k][1],
      path[k][2]-0.25,
    ]
  )
  var m = extrudeByPath({
    positions: [
      [+0.01,-0.01],
      [+0.01,+0.01],
      [-0.01,+0.01],
      [-0.01,-0.01]
    ],
    cells: [[0,1,2],[0,2,3]],
    edges: [[0,1],[1,2],[2,3],[3,0]],
    path
  })
  m.colors = m.positions.map(p => {
    return [1,0,0.2]
  })
  m.model = mat4.identity(new Float32Array(16))
  props.solid.push(m)
})()

;(function() { // wave
  var path = []
  for (var i = 0; i <= 64; i++) {
    path.push([ 0, 0, -1-i/64*2 ])
  }
  var m = extrudeByPath({
    positions: [
      [+0.01,-0.01],
      [+0.01,+0.01],
      [-0.01,+0.01],
      [-0.01,-0.01]
    ],
    cells: [[0,1,2],[0,2,3]],
    edges: [[0,1],[1,2],[2,3],[3,0]],
    path
  })
  m.colors = m.positions.map(p => {
    return [0,1,0]
  })
  m.model = mat4.identity(new Float32Array(16))
  props.wave.push(m)
})()

;(function () { // arrows
  for (var i = 0; i < 100; i++) {
    var p = {
      positions: [
        +0.0,+0.0,+0.8,
        +0.15,+0.15,+0.5,
        -0.15,+0.15,+0.5,
        -0.15,-0.15,+0.5,
        +0.15,-0.15,+0.5,
        +0.05,+0.05,+0.5,
        -0.05,+0.05,+0.5,
        -0.05,-0.05,+0.5,
        +0.05,-0.05,+0.5,
        +0.05,+0.05,+0.0,
        -0.05,+0.05,+0.0,
        -0.05,-0.05,+0.0,
        +0.05,-0.05,+0.0,
      ],
      cells: [
        0,1,2,0,2,3,0,3,4,0,4,1,1,2,3,1,3,4,
        5,6,9,6,9,10, 6,7,10,7,10,11,
        7,8,11,8,11,12, 8,5,12,5,12,9,
        9,10,11,9,11,12
      ],
      colors: [
        0,1,1, 0,1,1, 0,1,1, 0,1,1, 0,1,1,
        0,1,1, 0,1,1, 0,1,1, 0,1,1, 0,1,1,
        0,1,1, 0,1,1, 0,1,1
      ],
      model: mat4.identity(new Float32Array(16)),
      pose: {
        position: [(Math.random()*2-1)*0.15,0,-0.5-i/50*5],
        magnitude: Math.random(),
        direction: vec3.random([])
      }
    }
    setArrowColors(p)
    props.solid.push(p)
  }
})()

function setArrowColors(p) {
  for (var i = 0; i < p.colors.length; i++) {
    p.colors[i] = (0.5*p.pose.direction[(i+2)%3]+0.5)
      * p.pose.magnitude
  }
}

function update(time) {
  var m
  m = props.solid[0].model
  mat4.identity(m)
  mat4.translate(m,m,vec3.set(tmpv,0,0.425,0))
  mat4.rotateY(m,m,rstate.azimuth)
  mat4.rotateZ(m,m,-Math.PI/2)

  m = props.solid[1].model
  mat4.identity(m)
  mat4.translate(m,m,vec3.set(tmpv,0,-0.12,0))

  m = props.solid[2].model
  mat4.identity(m)
  mat4.rotateY(m,m,Math.PI*0.5 + rstate.azimuth)
  mat4.translate(m,m,vec3.set(tmpv,0,0.425,0))

  m = props.wave[0].model
  mat4.identity(m)
  mat4.rotateY(m,m,rstate.azimuth)
  mat4.translate(m,m,vec3.set(tmpv,-0.4,0.65,-0.2))

  for (var i = 0; i < 100; i++) {
    var p = props.solid[i+3]
    m = p.model
    mat4.identity(m)
    mat4.translate(m,m,p.pose.position)
    var prevZ = p.pose.position[2]
    p.pose.position[2] += 0.01
    if (p.pose.position[2] > 5) {
      p.pose.position[2] -= 10
      vec3.random(p.pose.direction)
      setArrowColors(p)
    } else if (p.pose.position[2] > 0 && prevZ <= 0) {
      var s = Math.sin(time*2)
      vec3.set(p.pose.direction,
        Math.sin(rstate.azimuth)*Math.sign(s),
        0,
        Math.cos(rstate.azimuth)*Math.sign(s)
      )
      p.pose.magnitude = Math.abs(s)
      setArrowColors(p)
    }
    quat.rotationTo(tmpq,forward,p.pose.direction)
    mat4.fromQuat(tmpm,tmpq)
    mat4.multiply(m,m,tmpm)
    mat4.scale(m,m,
      vec3.set(tmpv,0.4,0.2,0.3*p.pose.magnitude+0.05))
  }
}
update(0)

module.exports = function (regl) {
  var camera = require('./lib/camera.js')(regl, {
    distance: 3, theta: 0.7, phi: 0.5,
    minDistance: 0.5,
    maxDistance: 7
  })
  var draw = {
    solid: solid(regl),
    wave: wave(regl)
  }
  var attached = false
  var iv = null
  var last = 0
  return function ({time}) {
    el.touch()
    camera.touch()
    regl.clear({ color: [0.35,0,0.35,1], depth: true })
    camera(() => {
      draw.solid(props.solid)
      draw.wave(props.wave)
    })
    update(time)
  }
}

function solid(regl) {
  return regl({
    frag: `
      precision highp float;
      #extension GL_OES_standard_derivatives: enable
      varying vec3 vpos, vcolor;
      void main () {
        vec3 N = normalize(cross(dFdx(vpos),dFdy(vpos)));
        vec3 c = mix(N*0.5+0.5,vcolor,0.8);
        gl_FragColor = vec4(c,1);
      }
    `,
    vert: `
      precision highp float;
      uniform mat4 projection, view, model;
      attribute vec3 position, color;
      varying vec3 vpos, vcolor;
      void main () {
        vpos = position;
        vcolor = color;
        gl_Position = projection * view * model * vec4(position,1);
      }
    `,
    attributes: {
      position: regl.prop('positions'),
      color: regl.prop('colors')
    },
    elements: regl.prop('cells'),
    uniforms: {
      model: regl.prop('model')
    }
  })
}

function wave(regl) {
  return regl({
    frag: `
      precision highp float;
      #extension GL_OES_standard_derivatives: enable
      varying vec3 vpos, vcolor;
      void main () {
        vec3 N = normalize(cross(dFdx(vpos),dFdy(vpos)));
        vec3 c = mix(N*0.5+0.5,vcolor,0.8);
        gl_FragColor = vec4(c,1);
      }
    `,
    vert: `
      precision highp float;
      uniform mat4 projection, view, model;
      uniform float time;
      attribute vec3 position, color;
      varying vec3 vpos, vcolor;
      void main () {
        vpos = position;
        vcolor = color;
        vec3 p = position + vec3(0,sin(position.z*8.0+time*2.0)*0.2,0);
        gl_Position = projection * view * model * vec4(p,1);
      }
    `,
    attributes: {
      position: regl.prop('positions'),
      color: regl.prop('colors')
    },
    elements: regl.prop('cells'),
    uniforms: {
      model: regl.prop('model'),
      time: regl.context('time')
    }
  })
}

},{"./lib/camera.js":9,"./lib/elem.js":10,"choo":18,"choo/html":17,"extrude-by-path":20,"gl-mat4":37,"gl-quat":62,"gl-vec3":97}],6:[function(require,module,exports){
var mat4 = require('gl-mat4')
var cylinder = require('primitive-cylinder')
var el = require('./lib/elem.js')()

module.exports = function (regl) {
  var camera = require('./lib/camera.js')(regl, {
    distance: 3.5,
    maxDistance: 10,
    minDistance: 2,
    phi: 0.25
  })
  var draw = {
    head: head(regl),
    roller: roller(regl),
    tape: tape(regl)
  }
  var props = {
    head: Object.assign(cylinder(1,1,1,16,1), {
      model: new Float32Array(16)
    }),
    roller: (() => {
      var mesh = cylinder(0.1,0.1,0.8,8,1)
      var models = [
        mat4.identity(new Float32Array(16)), // left loading roller
        mat4.identity(new Float32Array(16)), // left tape guide
        mat4.identity(new Float32Array(16)), // right loading roller
        mat4.identity(new Float32Array(16)), // right tape guide
      ]
      return models.map((model) => {
        return Object.assign({ model }, mesh)
      })
    })(),
    tape: (() => {
      var positions = [], cells = [], distances = []
      var n = 16, r = 1.1, y = 0.16
      positions.push(
        +0.5,+y,+2.8,
        +0.5,-y,+2.8,
        -0.5,+y,+1.8,
        -0.5,-y,+1.8,
        -0.6,+y,+1.7,
        -0.6,-y,+1.7,
        -0.6,+y,+1.6,
        -0.6,-y,+1.6,
        -0.5,+y,+1.5,
        -0.5,-y,+1.5,
      )
      for (var i = 1; i < n/2-1; i++) {
        var x = Math.sin(2*Math.PI*i/n)*r
        var z = Math.cos(2*Math.PI*i/n)*r
        positions.push(
          x,+y,z,
          x,-y,z
        )
      }
      positions.push(
        -0.5,+y,-1.5,
        -0.5,-y,-1.5,
        -0.6,+y,-1.6,
        -0.6,-y,-1.6,
        -0.6,+y,-1.7,
        -0.6,-y,-1.7,
        -0.5,+y,-1.8,
        -0.5,-y,-1.8,
        +0.5,+y,-2.8,
        +0.5,-y,-2.8,
      )
      for (var i = 0; i < positions.length/3-2; i+=2) {
        cells.push(
          i,i+1,i+2,
          i+1,i+3,i+2
        )
      }
      for (var i = 0, d = 0; i < positions.length/3-2; i+=2) {
        distances.push(d,d)
        var dx = positions[(i+2)*3] - positions[i*3+0]
        var dz = positions[(i+2)*3+2] - positions[i*3+2]
        d += Math.sqrt(dx*dx+dz*dz)
      }
      distances.push(d,d)
      return { positions, cells, distances }
    })()
  }

  update(0)
  function update (time) {
    var m = props.head.model
    mat4.identity(m)
    mat4.rotateX(m, m,
      (5+58/60+9.9/3600)/180*Math.PI, // SP
      // 5°56′48.1″ // EP/SLP
      // 5°56′07.4″ // stationary
    )
    mat4.rotateY(m, m, 1798.2/60*time*2*Math.PI) // ntsc rpm -> ~30 rotations/second

    var m = props.roller[0].model // left loading roller
    mat4.identity(m)
    mat4.translate(m, m, [-0.5,+0.0,+1.65])
    mat4.rotateY(m, m, -time*2*Math.PI*15)

    var m = props.roller[1].model // left tape guide
    mat4.identity(m)
    mat4.translate(m, m, [+0.3,+0.0,+1.2])
    mat4.rotateX(m, m, (5+58/60+9.9/3600)/180*Math.PI) // SP
    mat4.rotateY(m, m, -time*2*Math.PI*15)

    var m = props.roller[2].model // right loading roller
    mat4.identity(m)
    mat4.translate(m, m, [-0.5,+0.0,-1.65])
    mat4.rotateY(m, m, -time*2*Math.PI*15)

    var m = props.roller[3].model // right tape guide
    mat4.identity(m)
    mat4.translate(m, m, [+0.3,+0.0,-1.18])
    mat4.rotateX(m, m, (5+58/60+9.9/3600)/180*Math.PI) // SP
    mat4.rotateY(m, m, -time*2*Math.PI*15)
  }

  var html = require('choo/html')
  var app = require('choo')()

  app.route('*', function (state, emit) {
    return html`<div>
      <style>
        .slider {
          position: absolute;
          bottom: 50px;
          left: 0px;
          right: 0px;
          text-align: center;
          color: white;
          font-size: 2em;
          font-family: monospace;
        }
        .slider input[type="range"] {
          margin-left: 1ex;
          margin-right: 1ex;
        }
        .slider .ratio {
          display: inline-block;
          width: 6ex;
        }
        .slider .info {
          font-size: 0.7em;
          margin: auto;
          margin-bottom: 1em;
        }
        .slider .info th {
          padding-right: 1ex;
        }
      </style>
      <div class="slider">
        <table class="info">
          <tr>
            <th>tape speed (SP)</th>
            <td>33.35 mm/s</td>
          </tr>
          <tr>
            <th>drum speed (SP)</th>
            <td>1798.2 rpm</td>
          </tr>
        </table>
        <div>
          speed
          <input type="range" width="80%" height="2em"
            min="20" max="300" value=${state.rspeed}
            oninput=${(ev) => emit('set-rspeed', Number(ev.target.value))}>
          <span class="ratio">1/${state.rspeed}x</span>
        </div>
      </div>
    </div>`
  })

  var emitter
  app.use(function (state, em) {
    emitter = em
    state.rspeed = 100
    state.speed = 1/state.rspeed
    emitter.on('set-rspeed', function (rspeed) {
      state.rspeed = rspeed
      state.speed = 1/state.rspeed
      emitter.emit('render')
    })

    var uniforms = regl({
      uniforms: {
        speed: () => state.speed,
        mmScale: 0.4/12.7
      }
    })
    emitter.on('frame', (time) => {
      camera.touch()
      regl.clear({ color: [0.3,0.25,0.5,1], depth: true })
      camera(() => {
        uniforms(() => {
          draw.head(props.head)
          draw.roller(props.roller)
          draw.tape(props.tape) // blending, must be last
        })
      })
      update(time*state.speed)
    })
  })
  app.mount(el.element)

  return function ({time}) {
    el.touch()
    camera.touch()
    emitter.emit('frame', time)
  }

  function head(regl) {
    return regl({
      frag: `
        precision highp float;
        #extension GL_OES_standard_derivatives: enable
        varying vec3 vpos;
        void main () {
          vec3 N = normalize(cross(dFdx(vpos),dFdy(vpos)));
          float d = step(0.1,distance(abs(vpos.xz),vec2(1,0)));
          float h = 1.0-step(0.05,distance(abs(vpos),vec3(1,0,0)));
          gl_FragColor = vec4((N*0.5+0.5)*(0.5+d*0.5)+h,1);
        }
      `,
      vert: `
        precision highp float;
        uniform mat4 projection, view, model;
        attribute vec3 position;
        varying vec3 vpos;
        void main () {
          vpos = position;
          gl_Position = projection * view * model * vec4(position,1);
        }
      `,
      uniforms: {
        model: regl.prop('model')
      },
      attributes: {
        position: regl.prop('positions')
      },
      elements: regl.prop('cells')
    })
  }

  function tape(regl) {
    return regl({
      frag: `
        precision highp float;
        #extension GL_OES_standard_derivatives: enable
        varying vec3 vpos;
        varying float vdist;
        uniform float time, speed, mmScale;
        uniform vec3 eye;
        const float PI = ${Math.PI};
        void main () {
          vec3 N = normalize(cross(dFdx(vpos),dFdy(vpos)));
          float x = vdist*16.0 - vpos.y*260.0;
          float m = mod(time*speed*1798.2/30.0+0.45,1.0);
          float t = -2.0*PI*time*speed*1798.2/60.0;
          vec3 p0 = vec3(
            cos(t)*1.1,
            0.2-mod(t/(2.0*PI)+PI*0.5,1.0)*0.4-0.02,
            sin(t)*1.1
          );
          vec3 p1 = vec3(
            cos(t+PI)*1.1,
            0.2-mod(t/(2.0*PI),1.0)*0.4-0.02,
            sin(t+PI)*1.1
          );
          float w = step(0.03, min(distance(vpos,p0),distance(vpos,p1)));
          float r = 1.1;
          float d = max(
              step(75.0+5.0*step(cos(mod(t*0.5-0.2,PI))*2.5+3.6,vdist),x),
              step(75.0+5.0*step(cos(mod(t*0.5-0.2+PI*0.5,PI))*2.5+3.6,vdist),x)
            )
            * step(abs(vpos.y),0.08)
            * pow(sin(x+t*2.0+1.8)*0.5+0.5,4.0)
          ;
          vec3 c = mix(
            vec3(0,1,1),
            mix(
              vec3(1,0.7,0.4),
              vec3(1,0.4,1),
              floor(mod((x+t*2.0+1.0)*0.5/PI,2.0))
            )*d,
            //pow(N*0.5+0.5,vec3(0.5))*d,
            w
          );
          c += 0.2*pow(dot(normalize(eye),N),16.0);
          gl_FragColor = vec4(c,0.8);
        }
      `,
      vert: `
        precision highp float;
        uniform mat4 projection, view;
        attribute vec3 position;
        attribute float dist;
        varying vec3 vpos;
        varying float vdist;
        void main () {
          vpos = position;
          vdist = dist;
          gl_Position = projection * view * vec4(position,1);
        }
      `,
      uniforms: {
        time: regl.context('time')
      },
      attributes: {
        position: regl.prop('positions'),
        dist: regl.prop('distances')
      },
      elements: regl.prop('cells'),
      blend: {
        enable: true,
        func: {
          src: 'src alpha',
          dst: 'one minus src alpha'
        },
        equation: {
          rgb: 'add',
          alpha: 'max'
        }
      },
      depth: {
        mask: false
      }
    })
  }

  function roller(regl) {
    return regl({
      frag: `
        precision highp float;
        #extension GL_OES_standard_derivatives: enable
        varying vec3 vpos;
        void main () {
          vec3 N = normalize(cross(dFdx(vpos),dFdy(vpos)));
          gl_FragColor = vec4(N*0.5+0.5,1);
        }
      `,
      vert: `
        precision highp float;
        uniform mat4 projection, view, model;
        attribute vec3 position;
        varying vec3 vpos;
        void main () {
          vpos = position;
          gl_Position = projection * view * model * vec4(position,1);
        }
      `,
      uniforms: {
        model: regl.prop('model')
      },
      attributes: {
        position: regl.prop('positions')
      },
      elements: regl.prop('cells')
    })
  }
}

},{"./lib/camera.js":9,"./lib/elem.js":10,"choo":18,"choo/html":17,"gl-mat4":37,"primitive-cylinder":161}],7:[function(require,module,exports){
var html = require('choo/html')
var resl = require('resl')
var el = require('./lib/elem.js')()

module.exports = function(regl) {
  var draw = regl({
    frag: `
      precision highp float;
      varying vec2 vpos;
      uniform sampler2D img;
      void main () {
        vec2 uv = vpos*vec2(1,-1)*0.5+0.5;
        vec3 rgb = texture2D(img,uv).xyz;
        gl_FragColor = vec4(rgb,1);
      }
    `,
    vert: `
      precision highp float;
      attribute vec2 position;
      varying vec2 vpos;
      void main () {
        vpos = position;
        gl_Position = vec4(position,0,1);
      }
    `,
    attributes: { position: [-4,-4,-4,+4,+4,+0] },
    elements: [0,1,2],
    uniforms: {
      img: regl.prop('img')
    },
    depth: { enable: false }
  })
  var props = { img: regl.texture() }
  resl({
    manifest: {
      img: { type: 'image', src: 'images/hyperlinks.jpg' },
    },
    onDone: (assets) => {
      props.img = regl.texture(assets.img)
    }
  })
  el.element.appendChild(html`<div class="hyperlinks">
    <style>
      .hyperlinks {
        position: absolute;
        top: 20%;
        left: 5%;
        right: 10%;
        bottom: 10%;
        font-size: 2em;
        font-family: monospace;
        color: lightgreen;
        text-shadow: 2px 2px purple;
      }
      .hyperlinks a:link {
        color: white;
        text-shadow: 2px 2px blue;
      }
      .hyperlinks a:visited {
        color: white;
        text-shadow: 1px 1px purple;
      }
    </style>
    <ul>
      <li><a href="https://www.youtube.com/watch?v=X24zDXz8Xgc">let's learn: ntsc (cnlohr)</a>
        [youtube.com]</li>
      <li><a href="http://www.kolumbus.fi/pami1/video/pal_ntsc.html"
        >characteristics of b,g/pal and m/ntsc television systems</a> [kolumbus.fi]</li>
      <li><a href="http://repairfaq.cis.upenn.edu/sam/icets/vcr.htm"
        >the video cassette recorder</a> [repairfaq.cis.upenn.edu]</li>
      <li><a href="http://hyperphysics.phy-astr.gsu.edu/hbase/Audio/tape2.html"
        >tape head action (hyperphysics)</a> [hyperphysics.phy-astr.gsu.edu]</li>
      <li><a href="https://archives.fbi.gov/archives/about-us/lab/forensic-science-communications/fsc/july2006/technical/2006_07_technical01.htm"
        >video and audio characteristics in vhs overrecordings</a> [archives.fbi.gov]</a>
      <li><a href="https://en.wikipedia.org/wiki/Analog_television"
        >analog television</a> [en.wikipedia.org]</li>
      <li><a href="https://en.wikipedia.org/wiki/NTSC"
        >ntsc</a> [en.wikipedia.org]</li>
      <li><a href="https://en.wikipedia.org/wiki/VHS"
        >vhs</a> [en.wikipedia.org]</li>
    </ul>
  </div>`)
  return function() {
    el.touch()
    regl.clear({ color: [0,0,0,1], depth: true })
    draw(props)
  }
}

},{"./lib/elem.js":10,"choo/html":17,"resl":164}],8:[function(require,module,exports){
module.exports = function (regl) {
  return regl({
    frag: `
      precision highp float;
      varying vec2 vpos;
      uniform sampler2D img;
      void main () {
        vec2 uv = vpos*vec2(1,-1)*0.5+0.5;
        vec3 rgb = texture2D(img,uv).xyz;
        gl_FragColor = vec4(rgb,1);
      }
    `,
    vert: `
      precision highp float;
      attribute vec2 position;
      varying vec2 vpos;
      void main () {
        vpos = position;
        gl_Position = vec4(position,0,1);
      }
    `,
    attributes: { position: [-4,-4,-4,+4,+4,+0] },
    elements: [0,1,2],
    uniforms: {
      img: regl.prop('img')
    },
    depth: { enable: false }
  })
}

},{}],9:[function(require,module,exports){
var camera = require('./regl-camera.js')

module.exports = function(regl, opts) {
  var c = camera(regl, opts)
  c.pause()
  var iv = null
  var last = 0
  c.touch = function() {
    if (!iv) {
      c.resume()
      iv = setInterval(() => {
        if (performance.now() - last > 50) {
          clearInterval(iv)
          c.pause()
          iv = null
        }
      }, 100)
    }
    last = performance.now()
  }
  return c
}

},{"./regl-camera.js":11}],10:[function(require,module,exports){
module.exports = function () {
  var attached = false
  var iv = null
  var last = 0
  var element = document.createElement('div')
  return {
    element,
    touch: function() {
      if (!attached) {
        document.body.appendChild(element)
        attached = true
        iv = setInterval(() => {
          var now = performance.now()
          if (now - last > 50) {
            clearInterval(iv)
            iv = null
            document.body.removeChild(element)
            attached = false
          }
        }, 100)
      }
      last = performance.now()
    }
  }
}

},{}],11:[function(require,module,exports){
// vendored version of regl-camera with touch events
// and pause/resume to toggle capturing events

var mouseChange = require('mouse-change')
var mouseWheel = require('mouse-wheel')
var identity = require('gl-mat4/identity')
var perspective = require('gl-mat4/perspective')
var lookAt = require('gl-mat4/lookAt')

module.exports = createCamera

var isBrowser = typeof window !== 'undefined'

function createCamera (regl, props_) {
  var props = props_ || {}

  // Preserve backward-compatibilty while renaming preventDefault -> noScroll
  if (typeof props.noScroll === 'undefined') {
    props.noScroll = props.preventDefault;
  }

  var cameraState = {
    view: identity(new Float32Array(16)),
    projection: identity(new Float32Array(16)),
    center: new Float32Array(props.center || 3),
    theta: props.theta || 0,
    phi: props.phi || 0,
    distance: Math.log(props.distance || 10.0),
    eye: new Float32Array(3),
    up: new Float32Array(props.up || [0, 1, 0]),
    fovy: props.fovy || Math.PI / 4.0,
    near: typeof props.near !== 'undefined' ? props.near : 0.01,
    far: typeof props.far !== 'undefined' ? props.far : 1000.0,
    noScroll: typeof props.noScroll !== 'undefined' ? props.noScroll : false,
    flipY: !!props.flipY,
    dtheta: 0,
    dphi: 0,
    rotationSpeed: typeof props.rotationSpeed !== 'undefined' ? props.rotationSpeed : 1,
    zoomSpeed: typeof props.zoomSpeed !== 'undefined' ? props.zoomSpeed : 1,
    renderOnDirty: typeof props.renderOnDirty !== undefined ? !!props.renderOnDirty : false,
    paused: false
  }

  var element = props.element
  var damping = typeof props.damping !== 'undefined' ? props.damping : 0.9

  var right = new Float32Array([1, 0, 0])
  var front = new Float32Array([0, 0, 1])

  var minDistance = Math.log('minDistance' in props ? props.minDistance : 0.1)
  var maxDistance = Math.log('maxDistance' in props ? props.maxDistance : 1000)

  var ddistance = 0

  var prevX = 0
  var prevY = 0

  if (isBrowser && props.mouse !== false) {
    var source = element || regl._gl.canvas

    function getWidth () {
      return element ? element.offsetWidth : window.innerWidth
    }

    function getHeight () {
      return element ? element.offsetHeight : window.innerHeight
    }

    mouseChange(source, function (buttons, x, y) {
      if (cameraState.paused) return
      if (buttons & 1) {
        var dx = (x - prevX) / getWidth()
        var dy = (y - prevY) / getHeight()

        cameraState.dtheta += cameraState.rotationSpeed * 4.0 * dx
        cameraState.dphi += cameraState.rotationSpeed * 4.0 * dy
        cameraState.dirty = true;
      }
      prevX = x
      prevY = y
    })


    source.addEventListener("touchstart", function(ev) {
      if (event.cancelable) {
        event.preventDefault();
      }
      var touch = ev.touches[0];
      var bounds = source.getBoundingClientRect();
      var x = touch.clientX - bounds.left;
      var y = touch.clientY - bounds.top;
      prevX = x
      prevY = y
    });

    source.addEventListener("touchend", function(event) {
      if (event.cancelable) {
        event.preventDefault();
      }
    });

    source.addEventListener("touchmove", function(ev) {
      if (ev.cancelable) {
        ev.preventDefault();
      }

      var touch = ev.touches[0];
      var bounds = source.getBoundingClientRect();
      var x = touch.clientX - bounds.left;
      var y = touch.clientY - bounds.top;
     
      var dx = (x - prevX) / getWidth()
      var dy = (y - prevY) / getHeight()

      cameraState.dtheta += cameraState.rotationSpeed * 4.0 * dx
      cameraState.dphi += cameraState.rotationSpeed * 4.0 * dy
      cameraState.dirty = true;

      prevX = x
      prevY = y
    });

    mouseWheel(source, function (dx, dy) {
      if (cameraState.paused) return
      ddistance += dy / getHeight() * cameraState.zoomSpeed
      cameraState.dirty = true;
    }, props.noScroll)
  }

  function damp (x) {
    var xd = x * damping
    if (Math.abs(xd) < 0.1) {
      return 0
    }
    cameraState.dirty = true;
    return xd
  }

  function clamp (x, lo, hi) {
    return Math.min(Math.max(x, lo), hi)
  }

  function updateCamera (props) {
    Object.keys(props).forEach(function (prop) {
      cameraState[prop] = props[prop]
    })

    var center = cameraState.center
    var eye = cameraState.eye
    var up = cameraState.up
    var dtheta = cameraState.dtheta
    var dphi = cameraState.dphi

    cameraState.theta += dtheta
    cameraState.phi = clamp(
      cameraState.phi + dphi,
      -Math.PI / 2.0,
      Math.PI / 2.0)
    cameraState.distance = clamp(
      cameraState.distance + ddistance,
      minDistance,
      maxDistance)

    cameraState.dtheta = damp(dtheta)
    cameraState.dphi = damp(dphi)
    ddistance = damp(ddistance)

    var theta = cameraState.theta
    var phi = cameraState.phi
    var r = Math.exp(cameraState.distance)

    var vf = r * Math.sin(theta) * Math.cos(phi)
    var vr = r * Math.cos(theta) * Math.cos(phi)
    var vu = r * Math.sin(phi)

    for (var i = 0; i < 3; ++i) {
      eye[i] = center[i] + vf * front[i] + vr * right[i] + vu * up[i]
    }

    lookAt(cameraState.view, eye, center, up)
  }

  cameraState.dirty = true;

  var injectContext = regl({
    context: Object.assign({}, cameraState, {
      dirty: function () {
        return cameraState.dirty;
      },
      projection: function (context) {
        perspective(cameraState.projection,
          cameraState.fovy,
          context.viewportWidth / context.viewportHeight,
          cameraState.near,
          cameraState.far)
        if (cameraState.flipY) { cameraState.projection[5] *= -1 }
        return cameraState.projection
      }
    }),
    uniforms: Object.keys(cameraState).reduce(function (uniforms, name) {
      uniforms[name] = regl.context(name)
      return uniforms
    }, {})
  })

  function setupCamera (props, block) {
    if (typeof setupCamera.dirty !== 'undefined') {
      cameraState.dirty = setupCamera.dirty || cameraState.dirty
      setupCamera.dirty = undefined;
    }

    if (props && block) {
      cameraState.dirty = true;
    }

    if (cameraState.renderOnDirty && !cameraState.dirty) return;

    if (!block) {
      block = props
      props = {}
    }

    updateCamera(props)
    injectContext(block)
    cameraState.dirty = false;
  }

  Object.keys(cameraState).forEach(function (name) {
    setupCamera[name] = cameraState[name]
  })
  setupCamera.pause = function () {
    cameraState.paused = true
  }
  setupCamera.resume = function () {
    cameraState.paused = false
  }

  return setupCamera
}

},{"gl-mat4/identity":36,"gl-mat4/lookAt":39,"gl-mat4/perspective":42,"mouse-change":139,"mouse-wheel":141}],12:[function(require,module,exports){
var glsl = require('glslify')

module.exports = function (regl) {
  return regl({
    frag: glsl(["\n      precision highp float;\n#define GLSLIFY 1\n\n      //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n      varying vec2 vpos;\n      uniform float quality, n_lines, tick;\n      uniform sampler2D signal;\n      const float L_TIME = 6.356e-5;\n      void main () {\n        vec2 uv = vpos*0.5+0.5;\n        float ft = uv.x*L_TIME + floor(uv.y*(n_lines-1.0)+0.5)*L_TIME;\n        float t = tick*L_TIME*n_lines + ft;\n        float ht = mod(tick*L_TIME*n_lines,4.0) + ft;\n        float q = pow(1.0-quality*0.01,2.2);\n        float n = snoise(vec3(vpos*vec2(24,72),t*8.0));\n        vec2 tuv = (vpos*0.5+0.5) + vec2(sin(ht*8.121e5+n*q)*0.02*q,0);\n        float x = texture2D(signal,tuv).x * pow(quality*0.015,0.15);\n        x *= max(quality*0.01,1.0-pow(n*0.5+0.5,2.0)) * (2.0-pow(quality*0.01,0.8));\n        x += pow(n*0.5+0.5,2.0)*sign(n)*q*1.2;\n        x += sin(8.40743e5*ht+tick*1e2)*q*0.5;\n        x += sin(5555.55*ht)*0.2*q;\n        gl_FragColor = vec4(x,0,0,1);\n      }\n    ",""]),
    vert: `
      precision highp float;
      attribute vec2 position;
      varying vec2 vpos;
      void main () {
        vpos = position;
        gl_Position = vec4(position,0,1);
      }
    `,
    attributes: { position: [-4,-4,-4,+4,+4,+0] },
    elements: [0,1,2],
    uniforms: {
      tick: regl.context('tick'),
      quality: regl.prop('quality')
    },
    depth: { enable: false }
  })
}

},{"glslify":136}],13:[function(require,module,exports){
var mat4 = require('gl-mat4')

module.exports = function (regl) {
  var camera = require('./lib/camera.js')(regl, {
    theta: 1.5,
    distance: 2.5,
    minDistance: 0.5,
    maxDistance: 10
  })
  var props = {
    tape: { img: regl.texture() }
  }
  var draw = {
    tape: tape(regl)
  }
  require('resl')({
    manifest: {
      vhs: { type: 'image', src: 'images/texture/vhs.jpg' },
    },
    onDone: (assets) => {
      props.tape.img = regl.texture(assets.vhs)
    }
  })
  return function () {
    camera.touch()
    regl.clear({ color: [0.6,0,0.4,1], depth: true })
    camera(() => {
      draw.tape(props.tape)
    })
  }
}

function tape(regl) {
  var mesh = {
    positions: [
      -0.5, +0.5, +0.5,
      +0.5, +0.5, +0.5,
      +0.5, -0.5, +0.5,
      -0.5, -0.5, +0.5,
      -0.5, +0.5, -0.5,
      +0.5, +0.5, -0.5,
      +0.5, -0.5, -0.5,
      -0.5, -0.5, -0.5,
    ],
    cells: [
      0,1,2,0,2,3,4,5,6,4,6,7,
      0,4,1,1,4,5,
      1,5,2,2,5,6,
      2,6,3,3,6,7,
      3,7,0,0,7,4
    ]
  }
  var model = new Float32Array(16)
  return regl({
    frag: `
      precision highp float;
      #extension GL_OES_standard_derivatives: enable
      uniform sampler2D img;
      varying vec3 vpos;
      void main () {
        vec3 N = normalize(cross(dFdx(vpos),dFdy(vpos)));
        vec2 uv = (vpos.xy*vec2(1,-1)+0.5)*vec2(1,0.5)
          + step(vpos.z,0.0)*vec2(0,0.5);
        vec3 rgb = texture2D(img,uv).xyz
          * step(0.49,abs(vpos.z));
        float d = 0.0;
        d = max(d,dot(N,normalize(vec3(0.1,1.0,-0.5))));
        d = max(d,0.3*dot(N,normalize(vec3(-0.3,-0.2,0.4))));
        vec3 c = mix(rgb,vec3(d),0.2);
        gl_FragColor = vec4(c,1);
      }
    `,
    vert: `
      precision highp float;
      uniform mat4 projection, view, model;
      uniform vec3 size;
      attribute vec3 position;
      varying vec3 vpos;
      void main () {
        vpos = position;
        gl_Position = projection * view * model * vec4(position*size,1);
      }
    `,
    attributes: {
      position: mesh.positions
    },
    elements: mesh.cells,
    uniforms: {
      img: regl.prop('img'),
      size: [1.87, 1.03, 0.25 ],
      model: ({time}) => {
        mat4.identity(model)
        mat4.rotateY(model,model,Math.sin(time*3)*0.2)
        return model
      }
    }
  })
}

},{"./lib/camera.js":9,"gl-mat4":37,"resl":164}],14:[function(require,module,exports){
var glsl = require('glslify')
var resl = require('resl')
var regl = require('regl')({
  extensions: [
    'oes_standard_derivatives',
    'oes_element_index_uint',
    'ext_blend_minmax'
  ]
})
var { EventEmitter } = require('events')

var state = {
  drawing: false,
  events: new EventEmitter,
  ui: {
    attached: true,
    selected: false
  },
  static: true,
  channel: {
    display: 63,
    value: 63,
    changed: 0,
    typing: 0,
    scanning: false
  },
  paused: false
}
state.events.on('set-channel', function(ch) {
  state.channel.display = ch
  state.channel.value = ch
  state.channel.changed = performance.now()
  state.channel.typing = 0
  state.channel.scanning = false
})
state.events.on('key-ch', function() {
  if (!state.ui.selected && state.ui.attached) {
    state.ui.attached = false
    document.body.removeChild(ui)
  }
})
state.events.on('num', function(num) {
  if (state.channel.typing === 0) {
    state.channel.display = Number(num)
    state.channel.typing++
  } else if (state.channel.typing === 1) {
    state.channel.display *= 10
    state.channel.display += Number(num)
    if (validCh(state.channel.display)) {
      state.channel.value = state.channel.display
    } else {
      state.channel.display = state.channel.value
    }
    state.events.emit('key-ch')
    state.channel.typing = 0
    state.channel.scanning = false
    location.hash = String(state.channel.value)
  }
  state.channel.changed = performance.now()
  unpause()
})

hashChange()
window.addEventListener('hashchange', hashChange)

var html = require('choo/html')
var ui = (function () {
  var numpad = html`<div class="numpad hide">
    <div>
      <button onclick=${typeKey}>1</button>
      <button onclick=${typeKey}>2</button>
      <button onclick=${typeKey}>3</button>
    </div>
    <div>
      <button onclick=${typeKey}>4</button>
      <button onclick=${typeKey}>5</button>
      <button onclick=${typeKey}>6</button>
    </div>
    <div>
      <button onclick=${typeKey}>7</button>
      <button onclick=${typeKey}>8</button>
      <button onclick=${typeKey}>9</button>
    </div>
    <div>
      <button onclick=${typeKey}>0</button>
    </div>
  </div>`
  var numpadButton = html`<button
    class="numpad-button" onclick=${toggleNumpad}>\u2328</button>`
  function typeKey(ev) {
    state.ui.selected = true
    state.events.emit('num', Number(ev.target.textContent))
  }
  var elem = html`<div class="ch-ui">
    <style>
      .ch-ui {
        position: absolute;
        top: 0px;
        bottom: 0px;
      }
      .ch-ui button {
        font-family: monospace;
        font-size: 4em;
        background-color: transparent;
        color: white;
        text-shadow: 2px 2px black;
        opacity: 50%;
        border-width: 0px;
      }
      .ch-ui button.static {
        display: block;
        position: absolute;
        bottom: 1.4em;
      }
      .ch-ui button.active {
        background-color: white;
        color: black;
      }
      .ch-ui button.numpad-button {
        display: block;
        position: absolute;
        bottom: 0.2em;
      }
      .ch-ui .hide {
        display: none;
      }
      .ch-ui .numpad {
        position: absolute;
        bottom: 0.2em;
        width: 18ex;
        text-align: center;
        left: 6ex;
      }
    </style>
    <div><button onclick=${up}>\u25b2</button></div>
    <div><button onclick=${down}>\u25bc</button></div>
    <div><button class="static" onclick=${toggleStatic}>s</button></div>
    <div>${numpadButton}</div>
    ${numpad}
  </div>`
  elem.style.position = 'absolute'
  elem.style.top = '5px'
  elem.style.left = '5px'
  document.body.appendChild(elem)
  return elem
  function up() {
    state.ui.selected = true
    state.events.emit('set-channel', wrapCh(state.channel.value+1))
    location.hash = String(state.channel.value)
  }
  function down() {
    state.ui.selected = true
    state.events.emit('set-channel', wrapCh(state.channel.value-1))
    location.hash = String(state.channel.value)
  }
  function toggleStatic() {
    state.ui.selected = true
    state.static = !state.static
  }
  function toggleNumpad() {
    numpad.classList.toggle('hide')
    numpadButton.classList.toggle('active')
  }
})()

function hashChange(ev) {
  var ch = Number(location.hash.replace(/^#/,''))
  if (validCh(ch)) {
    state.events.emit('set-channel', ch)
  } else {
    location.hash = String(state.channel.value)
  }
}

function wrapCh(n) {
  if (n > 83) return 2
  if (n < 2) return 83
  return n
}
function validCh(n) {
  return n >= 2 && n <= 83 && n === Math.floor(n)
}

function unpause() {
  if (state.paused) {
    state.paused = false
    state.events.emit('frame')
  }
}
window.addEventListener('keydown', (ev) => {
  if (ev.key === 'ArrowDown') {
    state.events.emit('key-ch')
    state.events.emit('set-channel', wrapCh(state.channel.value - 1))
    location.hash = String(state.channel.value)
    unpause()
  } else if (ev.key === 'ArrowUp') {
    state.events.emit('key-ch')
    state.events.emit('set-channel', wrapCh(state.channel.value + 1))
    location.hash = String(state.channel.value)
    unpause()
  } else if (/^[0-9]/.test(ev.key)) {
    state.events.emit('num', Number(ev.key))
  } else if (ev.key === ' ') {
    if (state.paused) {
      unpause()
    } else {
      state.paused = true
    }
  } else if (ev.key === 's') {
    state.static = !state.static
  } else if (ev.key === 'u') {
    state.ui.selected = true
    state.ui.attached = !state.ui.attached
    if (state.ui.attached) {
      document.body.appendChild(ui)
    } else {
      document.body.removeChild(ui)
    }
  }
})
function check(now) {
  var ch = state.channel
  if (ch.typing > 0 && now - ch.changed >= 2000) {
    if (validCh(state.channel.display)) {
      state.channel.value = state.channel.display
    } else {
      state.channel.display = state.channel.value
    }
    state.channel.typing = 0
    state.channel.scanning = false
    state.channel.changed = now
    location.hash = String(state.channel.value)
  }
}

var draw = {
  static: require('./draw/static.js')(regl),
  img: require('./draw/img.js')(regl),
  blank: require('./draw/blank.js')(regl),
  channel: require('./draw/channel.js')(regl),
  helicalScan: require('./draw/helical-scan.js')(regl),
  headAzimuth: require('./draw/head-azimuth.js')(regl),
  vhs: require('./draw/vhs.js')(regl),
  hyperlinks: require('./draw/hyperlinks.js')(regl),
  books: require('./draw/books.js')(regl),
  code: require('./draw/code.js')(regl),
}

var tv = require('ntsc-video-simulator')({ regl })
resl({
  manifest: {
    font: { type: 'image', src: 'images/font.png' },
    intro: { type: 'image', src: 'images/intro.jpg' },
    questions: { type: 'image', src: 'images/questions.jpg' },
    why: { type: 'image', src: 'images/why.jpg' },
    television0: { type: 'image', src: 'images/television0.jpg' },
    television1: { type: 'image', src: 'images/television1.jpg' },
    crt: { type: 'image', src: 'images/crt.jpg' },
    shadowMask: { type: 'image', src: 'images/shadow-mask.jpg' },
    world: { type: 'image', src: 'images/world.jpg' },

    frames: { type: 'image', src: 'images/frames.jpg' },
    interlacing: { type: 'image', src: 'images/interlacing.jpg' },
    radioWaves: { type: 'image', src: 'images/radio-waves.jpg' },
    line: { type: 'image', src: 'images/line.jpg' },
    field: { type: 'image', src: 'images/field.jpg' },

    yiq: { type: 'image', src: 'images/yiq.jpg' },
    rgbToYiq: { type: 'image', src: 'images/rgb-to-yiq.jpg' },
    yiqToRgb: { type: 'image', src: 'images/yiq-to-rgb.jpg' },
    qamEq: { type: 'image', src: 'images/qam-eq.jpg' },
    qamLine: { type: 'image', src: 'images/qam-line.jpg' },

    simGoals: { type: 'image', src: 'images/sim-goals.jpg' },
    sponsors: { type: 'image', src: 'images/sponsors.jpg' },
    simModDemod: { type: 'image', src: 'images/sim-mod-demod.jpg' },
    modulate: { type: 'image', src: 'images/modulate.jpg' },
    qamQuadrature: { type: 'image', src: 'images/qam-quadrature.jpg' },
    demodulate: { type: 'image', src: 'images/demodulate.jpg' },
    demodulateIq: { type: 'image', src: 'images/demodulate-iq.jpg' },
    demodulateCode1: { type: 'image', src: 'images/demodulate-code-1.jpg' },
    demodulateCode2: { type: 'image', src: 'images/demodulate-code-2.jpg' },
    demodulateCode3: { type: 'image', src: 'images/demodulate-code-3.jpg' },
    maskCode: { type: 'image', src: 'images/mask-code.jpg' },

    vhsTapeLayout: { type: 'image', src: 'images/vhs-tape-layout.jpg' },
    vhsVideoAzimuth: { type: 'image', src: 'images/vhs-video-azimuth.jpg' },
    vhsHiFi: { type: 'image', src: 'images/vhs-hi-fi.jpg' },
    vhsSim: { type: 'image', src: 'images/vhs-sim.jpg' },
  },
  onDone: (assets) => {
    var font = regl.texture(assets.font)
    var img = {
      intro: regl.texture(assets.intro),
      questions: regl.texture(assets.questions),
      why: regl.texture(assets.why),
      television0: regl.texture(assets.television0),
      television1: regl.texture(assets.television1),
      crt: regl.texture(assets.crt),
      shadowMask: regl.texture(assets.shadowMask),
      world: regl.texture(assets.world),

      frames: regl.texture(assets.frames),
      interlacing: regl.texture(assets.interlacing),
      radioWaves: regl.texture(assets.radioWaves),
      line: regl.texture(assets.line),
      field: regl.texture(assets.field),

      yiq: regl.texture(assets.yiq),
      rgbToYiq: regl.texture(assets.rgbToYiq),
      yiqToRgb: regl.texture(assets.yiqToRgb),
      qamEq: regl.texture(assets.qamEq),
      qamLine: regl.texture(assets.qamLine),

      simGoals: regl.texture(assets.simGoals),
      sponsors: regl.texture(assets.sponsors),
      simModDemod: regl.texture(assets.simModDemod),
      modulate: regl.texture(assets.modulate),
      qamQuadrature: regl.texture(assets.qamQuadrature),
      demodulate: regl.texture(assets.demodulate),
      demodulateIq: regl.texture(assets.demodulateIq),
      demodulateCode1: regl.texture(assets.demodulateCode1),
      demodulateCode2: regl.texture(assets.demodulateCode2),
      demodulateCode3: regl.texture(assets.demodulateCode3),
      maskCode: regl.texture(assets.maskCode),

      vhsTapeLayout: regl.texture(assets.vhsTapeLayout),
      vhsVideoAzimuth: regl.texture(assets.vhsVideoAzimuth),
      vhsHiFi: regl.texture(assets.vhsHiFi),
      vhsSim: regl.texture(assets.vhsSim)
    }
    var channels = {
      empty: { signal: draw.blank, quality: 0 },
      63: { signal: () => draw.img({ img: img.intro }), quality: 85 },
      62: {
        signal: () => draw.img({ img: img.questions }),
        quality: (now) => 70 + Math.floor(Math.sin(now/2000)*4)/4*10
      },
      61: {
        signal: () => draw.img({ img: img.why }),
        quality: (now) => 70 - Math.pow(Math.sin(now/1000*2)*0.5+0.5,3)*55
      },
      60: {
        signal: ({time}) => {
          return draw.img({ img: time%1<0.5 ? img.television0 : img.television1 })
        },
        quality: (now) => 85 - Math.pow(Math.sin(now/1000*0.5)*0.5+0.5,3)*30
      },
      58: { signal: () => draw.img({ img: img.crt }), quality: 90 },
      57: { signal: () => draw.img({ img: img.shadowMask }), quality: 85 },
      56: { signal: () => draw.img({ img: img.world }), quality: 80 },

      54: { signal: () => draw.img({ img: img.frames }), quality: 75 },
      53: { signal: () => draw.img({ img: img.interlacing }), quality: 80 },
      52: { signal: () => draw.img({ img: img.radioWaves }), quality: 70 },
      51: { signal: () => draw.img({ img: img.line }), quality: 85 },
      50: { signal: () => draw.img({ img: img.field }), quality: 87 },

      47: { signal: () => draw.img({ img: img.yiq }), quality: 80 },
      46: { signal: () => draw.img({ img: img.rgbToYiq }), quality: 80 },
      45: { signal: () => draw.img({ img: img.yiqToRgb }), quality: 80 },
      44: { signal: () => draw.img({ img: img.qamEq }), quality: 80 },
      43: { signal: () => draw.img({ img: img.qamLine }), quality: 80 },

      
      41: { signal: () => draw.img({ img: img.simGoals }), quality: 80 },
      40: { signal: () => draw.img({ img: img.sponsors }), quality: 80 },
      39: { signal: () => draw.img({ img: img.simModDemod }), quality: 80 },
      38: { signal: () => draw.img({ img: img.modulate }), quality: 80 },
      37: { signal: () => draw.img({ img: img.qamQuadrature }), quality: 80 },
      36: { signal: () => draw.img({ img: img.demodulate }), quality: 80 },
      35: { signal: () => draw.img({ img: img.demodulateIq }), quality: 80 },
      34: { signal: () => draw.img({ img: img.demodulateCode1 }), quality: 80 },
      33: { signal: () => draw.img({ img: img.demodulateCode2 }), quality: 80 },
      32: { signal: () => draw.img({ img: img.demodulateCode3 }), quality: 80 },
      31: { signal: () => draw.img({ img: img.maskCode }), quality: 80 },

      29: {
        signal: draw.vhs,
        quality: (now) => 80 - Math.floor(
          Math.pow(Math.sin(now/1000*2)*0.5+0.5,8.0)*10
        )/10*50
      },
      28: {
        signal: draw.headAzimuth,
        quality: (now) => 95 - Math.floor(Math.pow(Math.sin(now/2000)*0.5+0.5,8)*4)/4*20
      },
      27: { signal: draw.helicalScan, quality: 75 },
      26: { signal: () => draw.img({ img: img.vhsTapeLayout }), quality: 80 },
      25: { signal: () => draw.img({ img: img.vhsVideoAzimuth }), quality: 80 },
      24: { signal: () => draw.img({ img: img.vhsHiFi }), quality: 75 },
      23: { signal: () => draw.img({ img: img.vhsSim }), quality: 80 },

      21: { signal: draw.hyperlinks, quality: 80 },
      20: { signal: draw.books, quality: 80 },
      19: { signal: draw.code, quality: 70 },
    }
    state.events.on('frame', () => {
      if (state.drawing) return
      state.drawing = true
      window.requestAnimationFrame(frame)
    })
    frame()
    window.addEventListener('resize', () => {
      if (state.drawing) return
      state.drawing = true
      window.requestAnimationFrame(frame)
    })
    function frame() {
      var now = performance.now()
      var ch = channels[state.channel.value] || channels.empty
      regl.clear({ color: [0,0,0,1], depth: true })
      tv.modulate(ch.signal)
      tv.filter(() => {
        var q = typeof ch.quality === 'function' ? ch.quality(now) : ch.quality
        draw.static({ quality: state.static ? q : 100 })
      })
      tv.demodulate()
      if (now - state.channel.changed < 2000) {
        draw.channel({ channel: state.channel.display, font })
      }
      check(now)
      if (!state.paused) {
        state.drawing = true
        window.requestAnimationFrame(frame)
      } else {
        state.drawing = false
      }
    }
  }
})

},{"./draw/blank.js":1,"./draw/books.js":2,"./draw/channel.js":3,"./draw/code.js":4,"./draw/head-azimuth.js":5,"./draw/helical-scan.js":6,"./draw/hyperlinks.js":7,"./draw/img.js":8,"./draw/static.js":12,"./draw/vhs.js":13,"choo/html":17,"events":15,"glslify":136,"ntsc-video-simulator":169,"regl":162,"resl":164}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],16:[function(require,module,exports){
var assert = require('assert')
var LRU = require('nanolru')

module.exports = ChooComponentCache

function ChooComponentCache (state, emit, lru) {
  assert.ok(this instanceof ChooComponentCache, 'ChooComponentCache should be created with `new`')

  assert.equal(typeof state, 'object', 'ChooComponentCache: state should be type object')
  assert.equal(typeof emit, 'function', 'ChooComponentCache: emit should be type function')

  if (typeof lru === 'number') this.cache = new LRU(lru)
  else this.cache = lru || new LRU(100)
  this.state = state
  this.emit = emit
}

// Get & create component instances.
ChooComponentCache.prototype.render = function (Component, id) {
  assert.equal(typeof Component, 'function', 'ChooComponentCache.render: Component should be type function')
  assert.ok(typeof id === 'string' || typeof id === 'number', 'ChooComponentCache.render: id should be type string or type number')

  var el = this.cache.get(id)
  if (!el) {
    var args = []
    for (var i = 2, len = arguments.length; i < len; i++) {
      args.push(arguments[i])
    }
    args.unshift(Component, id, this.state, this.emit)
    el = newCall.apply(newCall, args)
    this.cache.set(id, el)
  }

  return el
}

// Because you can't call `new` and `.apply()` at the same time. This is a mad
// hack, but hey it works so we gonna go for it. Whoop.
function newCall (Cls) {
  return new (Cls.bind.apply(Cls, arguments)) // eslint-disable-line
}

},{"assert":142,"nanolru":151}],17:[function(require,module,exports){
module.exports = require('nanohtml')

},{"nanohtml":147}],18:[function(require,module,exports){
var scrollToAnchor = require('scroll-to-anchor')
var documentReady = require('document-ready')
var nanotiming = require('nanotiming')
var nanorouter = require('nanorouter')
var nanomorph = require('nanomorph')
var nanoquery = require('nanoquery')
var nanohref = require('nanohref')
var nanoraf = require('nanoraf')
var nanobus = require('nanobus')
var assert = require('assert')

var Cache = require('./component/cache')

module.exports = Choo

var HISTORY_OBJECT = {}

function Choo (opts) {
  var timing = nanotiming('choo.constructor')
  if (!(this instanceof Choo)) return new Choo(opts)
  opts = opts || {}

  assert.equal(typeof opts, 'object', 'choo: opts should be type object')

  var self = this

  // define events used by choo
  this._events = {
    DOMCONTENTLOADED: 'DOMContentLoaded',
    DOMTITLECHANGE: 'DOMTitleChange',
    REPLACESTATE: 'replaceState',
    PUSHSTATE: 'pushState',
    NAVIGATE: 'navigate',
    POPSTATE: 'popState',
    RENDER: 'render'
  }

  // properties for internal use only
  this._historyEnabled = opts.history === undefined ? true : opts.history
  this._hrefEnabled = opts.href === undefined ? true : opts.href
  this._hashEnabled = opts.hash === undefined ? false : opts.hash
  this._hasWindow = typeof window !== 'undefined'
  this._cache = opts.cache
  this._loaded = false
  this._stores = [ondomtitlechange]
  this._tree = null

  // state
  var _state = {
    events: this._events,
    components: {}
  }
  if (this._hasWindow) {
    this.state = window.initialState
      ? Object.assign({}, window.initialState, _state)
      : _state
    delete window.initialState
  } else {
    this.state = _state
  }

  // properties that are part of the API
  this.router = nanorouter({ curry: true })
  this.emitter = nanobus('choo.emit')
  this.emit = this.emitter.emit.bind(this.emitter)

  // listen for title changes; available even when calling .toString()
  if (this._hasWindow) this.state.title = document.title
  function ondomtitlechange (state) {
    self.emitter.prependListener(self._events.DOMTITLECHANGE, function (title) {
      assert.equal(typeof title, 'string', 'events.DOMTitleChange: title should be type string')
      state.title = title
      if (self._hasWindow) document.title = title
    })
  }
  timing()
}

Choo.prototype.route = function (route, handler) {
  var routeTiming = nanotiming("choo.route('" + route + "')")
  assert.equal(typeof route, 'string', 'choo.route: route should be type string')
  assert.equal(typeof handler, 'function', 'choo.handler: route should be type function')
  this.router.on(route, handler)
  routeTiming()
}

Choo.prototype.use = function (cb) {
  assert.equal(typeof cb, 'function', 'choo.use: cb should be type function')
  var self = this
  this._stores.push(function (state) {
    var msg = 'choo.use'
    msg = cb.storeName ? msg + '(' + cb.storeName + ')' : msg
    var endTiming = nanotiming(msg)
    cb(state, self.emitter, self)
    endTiming()
  })
}

Choo.prototype.start = function () {
  assert.equal(typeof window, 'object', 'choo.start: window was not found. .start() must be called in a browser, use .toString() if running in Node')
  var startTiming = nanotiming('choo.start')

  var self = this
  if (this._historyEnabled) {
    this.emitter.prependListener(this._events.NAVIGATE, function () {
      self._matchRoute(self.state)
      if (self._loaded) {
        self.emitter.emit(self._events.RENDER)
        setTimeout(scrollToAnchor.bind(null, window.location.hash), 0)
      }
    })

    this.emitter.prependListener(this._events.POPSTATE, function () {
      self.emitter.emit(self._events.NAVIGATE)
    })

    this.emitter.prependListener(this._events.PUSHSTATE, function (href) {
      assert.equal(typeof href, 'string', 'events.pushState: href should be type string')
      window.history.pushState(HISTORY_OBJECT, null, href)
      self.emitter.emit(self._events.NAVIGATE)
    })

    this.emitter.prependListener(this._events.REPLACESTATE, function (href) {
      assert.equal(typeof href, 'string', 'events.replaceState: href should be type string')
      window.history.replaceState(HISTORY_OBJECT, null, href)
      self.emitter.emit(self._events.NAVIGATE)
    })

    window.onpopstate = function () {
      self.emitter.emit(self._events.POPSTATE)
    }

    if (self._hrefEnabled) {
      nanohref(function (location) {
        var href = location.href
        var hash = location.hash
        if (href === window.location.href) {
          if (!self._hashEnabled && hash) scrollToAnchor(hash)
          return
        }
        self.emitter.emit(self._events.PUSHSTATE, href)
      })
    }
  }

  this._setCache(this.state)
  this._matchRoute(this.state)
  this._stores.forEach(function (initStore) {
    initStore(self.state)
  })

  this._tree = this._prerender(this.state)
  assert.ok(this._tree, 'choo.start: no valid DOM node returned for location ' + this.state.href)

  this.emitter.prependListener(self._events.RENDER, nanoraf(function () {
    var renderTiming = nanotiming('choo.render')
    var newTree = self._prerender(self.state)
    assert.ok(newTree, 'choo.render: no valid DOM node returned for location ' + self.state.href)

    assert.equal(self._tree.nodeName, newTree.nodeName, 'choo.render: The target node <' +
      self._tree.nodeName.toLowerCase() + '> is not the same type as the new node <' +
      newTree.nodeName.toLowerCase() + '>.')

    var morphTiming = nanotiming('choo.morph')
    nanomorph(self._tree, newTree)
    morphTiming()

    renderTiming()
  }))

  documentReady(function () {
    self.emitter.emit(self._events.DOMCONTENTLOADED)
    self._loaded = true
  })

  startTiming()
  return this._tree
}

Choo.prototype.mount = function mount (selector) {
  var mountTiming = nanotiming("choo.mount('" + selector + "')")
  if (typeof window !== 'object') {
    assert.ok(typeof selector === 'string', 'choo.mount: selector should be type String')
    this.selector = selector
    mountTiming()
    return this
  }

  assert.ok(typeof selector === 'string' || typeof selector === 'object', 'choo.mount: selector should be type String or HTMLElement')

  var self = this

  documentReady(function () {
    var renderTiming = nanotiming('choo.render')
    var newTree = self.start()
    if (typeof selector === 'string') {
      self._tree = document.querySelector(selector)
    } else {
      self._tree = selector
    }

    assert.ok(self._tree, 'choo.mount: could not query selector: ' + selector)
    assert.equal(self._tree.nodeName, newTree.nodeName, 'choo.mount: The target node <' +
      self._tree.nodeName.toLowerCase() + '> is not the same type as the new node <' +
      newTree.nodeName.toLowerCase() + '>.')

    var morphTiming = nanotiming('choo.morph')
    nanomorph(self._tree, newTree)
    morphTiming()

    renderTiming()
  })
  mountTiming()
}

Choo.prototype.toString = function (location, state) {
  state = state || {}
  state.components = state.components || {}
  state.events = Object.assign({}, state.events, this._events)

  assert.notEqual(typeof window, 'object', 'choo.mount: window was found. .toString() must be called in Node, use .start() or .mount() if running in the browser')
  assert.equal(typeof location, 'string', 'choo.toString: location should be type string')
  assert.equal(typeof state, 'object', 'choo.toString: state should be type object')

  this._setCache(state)
  this._matchRoute(state, location)
  this.emitter.removeAllListeners()
  this._stores.forEach(function (initStore) {
    initStore(state)
  })

  var html = this._prerender(state)
  assert.ok(html, 'choo.toString: no valid value returned for the route ' + location)
  assert(!Array.isArray(html), 'choo.toString: return value was an array for the route ' + location)
  return typeof html.outerHTML === 'string' ? html.outerHTML : html.toString()
}

Choo.prototype._matchRoute = function (state, locationOverride) {
  var location, queryString
  if (locationOverride) {
    location = locationOverride.replace(/\?.+$/, '').replace(/\/$/, '')
    if (!this._hashEnabled) location = location.replace(/#.+$/, '')
    queryString = locationOverride
  } else {
    location = window.location.pathname.replace(/\/$/, '')
    if (this._hashEnabled) location += window.location.hash.replace(/^#/, '/')
    queryString = window.location.search
  }
  var matched = this.router.match(location)
  this._handler = matched.cb
  state.href = location
  state.query = nanoquery(queryString)
  state.route = matched.route
  state.params = matched.params
}

Choo.prototype._prerender = function (state) {
  var routeTiming = nanotiming("choo.prerender('" + state.route + "')")
  var res = this._handler(state, this.emit)
  routeTiming()
  return res
}

Choo.prototype._setCache = function (state) {
  var cache = new Cache(state, this.emitter.emit.bind(this.emitter), this._cache)
  state.cache = renderComponent

  function renderComponent (Component, id) {
    assert.equal(typeof Component, 'function', 'choo.state.cache: Component should be type function')
    var args = []
    for (var i = 0, len = arguments.length; i < len; i++) {
      args.push(arguments[i])
    }
    return cache.render.apply(cache, args)
  }

  // When the state gets stringified, make sure `state.cache` isn't
  // stringified too.
  renderComponent.toJSON = function () {
    return null
  }
}

},{"./component/cache":16,"assert":142,"document-ready":19,"nanobus":143,"nanohref":144,"nanomorph":152,"nanoquery":155,"nanoraf":156,"nanorouter":157,"nanotiming":159,"scroll-to-anchor":165}],19:[function(require,module,exports){
'use strict'

module.exports = ready

function ready (callback) {
  if (typeof document === 'undefined') {
    throw new Error('document-ready only runs in the browser')
  }
  var state = document.readyState
  if (state === 'complete' || state === 'interactive') {
    return setTimeout(callback, 0)
  }

  document.addEventListener('DOMContentLoaded', function onLoad () {
    callback()
  })
}

},{}],20:[function(require,module,exports){
var trmat = require('gl-vec3/transformMat4')
var add = require('gl-vec3/add')
var subtract = require('gl-vec3/subtract')
var normalize = require('gl-vec3/normalize')
var cross = require('gl-vec3/cross')
var dot = require('gl-vec3/dot')
var identity = require('gl-mat4/identity')
var rotate = require('gl-mat4/rotate')

var mat = [], v = [], axis = []

module.exports = function (opts) {
  var mesh = { positions: [], cells: [] }
  var path = opts.path
  var positions = opts.positions
  if (!positions) throw new Error('positions not provided')
  var edges = opts.edges
  if (!edges) throw new Error('edges not provided')
  var cells = opts.cells
  var closed = opts.closed
  var spl = positions.length, pl = path.length, sel = edges.length
  for (var i = 0; i < pl; i++) {
    var n = [0,0,1]
    if (closed) {
      subtract(v,path[(i-1+pl)%(pl-1)],path[(i+1)%(pl-1)])
    } else if (i === 0) {
      subtract(v,path[i],path[i+1])
    } else if (i === pl-1) {
      subtract(v,path[i-1],path[i])
    } else {
      subtract(v,path[i-1],path[i+1])
    }
    normalize(v,v)
    cross(axis,n,v)
    var angle = Math.acos(dot(n,v))
    identity(mat)
    rotate(mat,mat,angle,axis)
    var twist = path[i][3]
    if (twist) rotate(mat,mat,twist,n)
    for (var j = 0; j < spl; j++) {
      var p = positions[j]
      var pt = [p[0],p[1],p[2]||0]
      trmat(pt, pt, mat)
      add(pt,pt,path[i])
      mesh.positions.push(pt)
    }
  }
  for (var i = 0; i < pl-1; i++) {
    for (var j = 0; j < sel; j++) {
      var e = edges[j]
      mesh.cells.push([i*spl+e[0],i*spl+e[1],(i+1)*spl+e[0]])
      mesh.cells.push([i*spl+e[1],(i+1)*spl+e[0],(i+1)*spl+e[1]])
    }
  }
  if (cells && !closed && opts.startCap !== false && opts.caps !== false) {
    for (var i = 0; i < cells.length; i++) {
      var c = [], len = cells[i].length
      for (var j = 0; j < len; j++) {
        c.push(cells[i][j])
      }
      mesh.cells.push(c)
    }
  }
  if (cells && !closed && opts.endCap !== false && opts.caps !== false) {
    for (var i = 0; i < cells.length; i++) {
      var c = [], len = cells[i].length
      for (var j = 0; j < len; j++) {
        c.push(cells[i][j] + (pl-1)*spl)
      }
      mesh.cells.push(c)
    }
  }
  return mesh
}

},{"gl-mat4/identity":36,"gl-mat4/rotate":44,"gl-vec3/add":79,"gl-vec3/cross":85,"gl-vec3/dot":90,"gl-vec3/normalize":107,"gl-vec3/subtract":121,"gl-vec3/transformMat4":123}],21:[function(require,module,exports){
module.exports = create

/**
 * Creates a new identity mat3
 *
 * @alias mat3.create
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new Float32Array(9)
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 1
  out[5] = 0
  out[6] = 0
  out[7] = 0
  out[8] = 1
  return out
}

},{}],22:[function(require,module,exports){
module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};
},{}],23:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],24:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],25:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],26:[function(require,module,exports){
module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
},{}],27:[function(require,module,exports){
module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};
},{}],28:[function(require,module,exports){
module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],29:[function(require,module,exports){
module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};
},{}],30:[function(require,module,exports){
module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],31:[function(require,module,exports){
module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}

},{}],32:[function(require,module,exports){
module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],33:[function(require,module,exports){
module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],34:[function(require,module,exports){
module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],35:[function(require,module,exports){
module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};
},{}],36:[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],37:[function(require,module,exports){
module.exports = {
  create: require('./create')
  , clone: require('./clone')
  , copy: require('./copy')
  , identity: require('./identity')
  , transpose: require('./transpose')
  , invert: require('./invert')
  , adjoint: require('./adjoint')
  , determinant: require('./determinant')
  , multiply: require('./multiply')
  , translate: require('./translate')
  , scale: require('./scale')
  , rotate: require('./rotate')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , fromRotation: require('./fromRotation')
  , fromRotationTranslation: require('./fromRotationTranslation')
  , fromScaling: require('./fromScaling')
  , fromTranslation: require('./fromTranslation')
  , fromXRotation: require('./fromXRotation')
  , fromYRotation: require('./fromYRotation')
  , fromZRotation: require('./fromZRotation')
  , fromQuat: require('./fromQuat')
  , frustum: require('./frustum')
  , perspective: require('./perspective')
  , perspectiveFromFieldOfView: require('./perspectiveFromFieldOfView')
  , ortho: require('./ortho')
  , lookAt: require('./lookAt')
  , str: require('./str')
}

},{"./adjoint":22,"./clone":23,"./copy":24,"./create":25,"./determinant":26,"./fromQuat":27,"./fromRotation":28,"./fromRotationTranslation":29,"./fromScaling":30,"./fromTranslation":31,"./fromXRotation":32,"./fromYRotation":33,"./fromZRotation":34,"./frustum":35,"./identity":36,"./invert":38,"./lookAt":39,"./multiply":40,"./ortho":41,"./perspective":42,"./perspectiveFromFieldOfView":43,"./rotate":44,"./rotateX":45,"./rotateY":46,"./rotateZ":47,"./scale":48,"./str":49,"./translate":50,"./transpose":51}],38:[function(require,module,exports){
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
},{}],39:[function(require,module,exports){
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
},{"./identity":36}],40:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],41:[function(require,module,exports){
module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};
},{}],42:[function(require,module,exports){
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
},{}],43:[function(require,module,exports){
module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}


},{}],44:[function(require,module,exports){
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
},{}],45:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};
},{}],46:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};
},{}],47:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};
},{}],48:[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],49:[function(require,module,exports){
module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};
},{}],50:[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],51:[function(require,module,exports){
module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};
},{}],52:[function(require,module,exports){
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
module.exports = require('gl-vec4/add')

},{"gl-vec4/add":125}],53:[function(require,module,exports){
module.exports = calculateW

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW (out, a) {
  var x = a[0], y = a[1], z = a[2]

  out[0] = x
  out[1] = y
  out[2] = z
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z))
  return out
}

},{}],54:[function(require,module,exports){
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
module.exports = require('gl-vec4/clone')

},{"gl-vec4/clone":126}],55:[function(require,module,exports){
module.exports = conjugate

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate (out, a) {
  out[0] = -a[0]
  out[1] = -a[1]
  out[2] = -a[2]
  out[3] = a[3]
  return out
}

},{}],56:[function(require,module,exports){
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
module.exports = require('gl-vec4/copy')

},{"gl-vec4/copy":127}],57:[function(require,module,exports){
module.exports = create

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create () {
  var out = new Float32Array(4)
  out[0] = 0
  out[1] = 0
  out[2] = 0
  out[3] = 1
  return out
}

},{}],58:[function(require,module,exports){
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
module.exports = require('gl-vec4/dot')

},{"gl-vec4/dot":128}],59:[function(require,module,exports){
module.exports = fromMat3

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3 (out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8]
  var fRoot

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0)  // 2w
    out[3] = 0.5 * fRoot
    fRoot = 0.5 / fRoot  // 1/(4w)
    out[0] = (m[5] - m[7]) * fRoot
    out[1] = (m[6] - m[2]) * fRoot
    out[2] = (m[1] - m[3]) * fRoot
  } else {
    // |w| <= 1/2
    var i = 0
    if (m[4] > m[0]) {
      i = 1
    }
    if (m[8] > m[i * 3 + i]) {
      i = 2
    }
    var j = (i + 1) % 3
    var k = (i + 2) % 3

    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0)
    out[i] = 0.5 * fRoot
    fRoot = 0.5 / fRoot
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot
  }

  return out
}

},{}],60:[function(require,module,exports){
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
module.exports = require('gl-vec4/fromValues')

},{"gl-vec4/fromValues":129}],61:[function(require,module,exports){
module.exports = identity

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity (out) {
  out[0] = 0
  out[1] = 0
  out[2] = 0
  out[3] = 1
  return out
}

},{}],62:[function(require,module,exports){
module.exports = {
  add: require('./add'),
  calculateW: require('./calculateW'),
  clone: require('./clone'),
  conjugate: require('./conjugate'),
  copy: require('./copy'),
  create: require('./create'),
  dot: require('./dot'),
  fromMat3: require('./fromMat3'),
  fromValues: require('./fromValues'),
  identity: require('./identity'),
  invert: require('./invert'),
  length: require('./length'),
  lerp: require('./lerp'),
  multiply: require('./multiply'),
  normalize: require('./normalize'),
  rotateX: require('./rotateX'),
  rotateY: require('./rotateY'),
  rotateZ: require('./rotateZ'),
  rotationTo: require('./rotationTo'),
  scale: require('./scale'),
  set: require('./set'),
  setAxes: require('./setAxes'),
  setAxisAngle: require('./setAxisAngle'),
  slerp: require('./slerp'),
  sqlerp: require('./sqlerp'),
  squaredLength: require('./squaredLength')
}

},{"./add":52,"./calculateW":53,"./clone":54,"./conjugate":55,"./copy":56,"./create":57,"./dot":58,"./fromMat3":59,"./fromValues":60,"./identity":61,"./invert":63,"./length":64,"./lerp":65,"./multiply":66,"./normalize":67,"./rotateX":68,"./rotateY":69,"./rotateZ":70,"./rotationTo":71,"./scale":72,"./set":73,"./setAxes":74,"./setAxisAngle":75,"./slerp":76,"./sqlerp":77,"./squaredLength":78}],63:[function(require,module,exports){
module.exports = invert

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert (out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
    dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,
    invDot = dot ? 1.0 / dot : 0

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot
  out[1] = -a1 * invDot
  out[2] = -a2 * invDot
  out[3] = a3 * invDot
  return out
}

},{}],64:[function(require,module,exports){
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
module.exports = require('gl-vec4/length')

},{"gl-vec4/length":130}],65:[function(require,module,exports){
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
module.exports = require('gl-vec4/lerp')

},{"gl-vec4/lerp":131}],66:[function(require,module,exports){
module.exports = multiply

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply (out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
    bx = b[0], by = b[1], bz = b[2], bw = b[3]

  out[0] = ax * bw + aw * bx + ay * bz - az * by
  out[1] = ay * bw + aw * by + az * bx - ax * bz
  out[2] = az * bw + aw * bz + ax * by - ay * bx
  out[3] = aw * bw - ax * bx - ay * by - az * bz
  return out
}

},{}],67:[function(require,module,exports){
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
module.exports = require('gl-vec4/normalize')

},{"gl-vec4/normalize":132}],68:[function(require,module,exports){
module.exports = rotateX

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX (out, a, rad) {
  rad *= 0.5

  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
    bx = Math.sin(rad), bw = Math.cos(rad)

  out[0] = ax * bw + aw * bx
  out[1] = ay * bw + az * bx
  out[2] = az * bw - ay * bx
  out[3] = aw * bw - ax * bx
  return out
}

},{}],69:[function(require,module,exports){
module.exports = rotateY

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY (out, a, rad) {
  rad *= 0.5

  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
    by = Math.sin(rad), bw = Math.cos(rad)

  out[0] = ax * bw - az * by
  out[1] = ay * bw + aw * by
  out[2] = az * bw + ax * by
  out[3] = aw * bw - ay * by
  return out
}

},{}],70:[function(require,module,exports){
module.exports = rotateZ

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ (out, a, rad) {
  rad *= 0.5

  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
    bz = Math.sin(rad), bw = Math.cos(rad)

  out[0] = ax * bw + ay * bz
  out[1] = ay * bw - ax * bz
  out[2] = az * bw + aw * bz
  out[3] = aw * bw - az * bz
  return out
}

},{}],71:[function(require,module,exports){
var vecDot = require('gl-vec3/dot')
var vecCross = require('gl-vec3/cross')
var vecLength = require('gl-vec3/length')
var vecNormalize = require('gl-vec3/normalize')

var quatNormalize = require('./normalize')
var quatAxisAngle = require('./setAxisAngle')

module.exports = rotationTo

var tmpvec3 = [0, 0, 0]
var xUnitVec3 = [1, 0, 0]
var yUnitVec3 = [0, 1, 0]

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
function rotationTo (out, a, b) {
  var dot = vecDot(a, b)
  if (dot < -0.999999) {
    vecCross(tmpvec3, xUnitVec3, a)
    if (vecLength(tmpvec3) < 0.000001) {
      vecCross(tmpvec3, yUnitVec3, a)
    }
    vecNormalize(tmpvec3, tmpvec3)
    quatAxisAngle(out, tmpvec3, Math.PI)
    return out
  } else if (dot > 0.999999) {
    out[0] = 0
    out[1] = 0
    out[2] = 0
    out[3] = 1
    return out
  } else {
    vecCross(tmpvec3, a, b)
    out[0] = tmpvec3[0]
    out[1] = tmpvec3[1]
    out[2] = tmpvec3[2]
    out[3] = 1 + dot
    return quatNormalize(out, out)
  }
}

},{"./normalize":67,"./setAxisAngle":75,"gl-vec3/cross":85,"gl-vec3/dot":90,"gl-vec3/length":100,"gl-vec3/normalize":107}],72:[function(require,module,exports){
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
module.exports = require('gl-vec4/scale')

},{"gl-vec4/scale":133}],73:[function(require,module,exports){
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
module.exports = require('gl-vec4/set')

},{"gl-vec4/set":134}],74:[function(require,module,exports){
var mat3create = require('gl-mat3/create')
var fromMat3 = require('./fromMat3')
var normalize = require('./normalize')

module.exports = setAxes

var matr = mat3create()

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
function setAxes (out, view, right, up) {
  matr[0] = right[0]
  matr[3] = right[1]
  matr[6] = right[2]

  matr[1] = up[0]
  matr[4] = up[1]
  matr[7] = up[2]

  matr[2] = -view[0]
  matr[5] = -view[1]
  matr[8] = -view[2]

  return normalize(out, fromMat3(out, matr))
}

},{"./fromMat3":59,"./normalize":67,"gl-mat3/create":21}],75:[function(require,module,exports){
module.exports = setAxisAngle

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle (out, axis, rad) {
  rad = rad * 0.5
  var s = Math.sin(rad)
  out[0] = s * axis[0]
  out[1] = s * axis[1]
  out[2] = s * axis[2]
  out[3] = Math.cos(rad)
  return out
}

},{}],76:[function(require,module,exports){
module.exports = slerp

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp (out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations

  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
    bx = b[0], by = b[1], bz = b[2], bw = b[3]

  var omega, cosom, sinom, scale0, scale1

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw
  // adjust signs (if necessary)
  if (cosom < 0.0) {
    cosom = -cosom
    bx = -bx
    by = -by
    bz = -bz
    bw = -bw
  }
  // calculate coefficients
  if ((1.0 - cosom) > 0.000001) {
    // standard case (slerp)
    omega = Math.acos(cosom)
    sinom = Math.sin(omega)
    scale0 = Math.sin((1.0 - t) * omega) / sinom
    scale1 = Math.sin(t * omega) / sinom
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t
    scale1 = t
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx
  out[1] = scale0 * ay + scale1 * by
  out[2] = scale0 * az + scale1 * bz
  out[3] = scale0 * aw + scale1 * bw

  return out
}

},{}],77:[function(require,module,exports){
var slerp = require('./slerp')

module.exports = sqlerp

var temp1 = [0, 0, 0, 1]
var temp2 = [0, 0, 0, 1]

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
function sqlerp (out, a, b, c, d, t) {
  slerp(temp1, a, d, t)
  slerp(temp2, b, c, t)
  slerp(out, temp1, temp2, 2 * t * (1 - t))

  return out
}

},{"./slerp":76}],78:[function(require,module,exports){
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
module.exports = require('gl-vec4/squaredLength')

},{"gl-vec4/squaredLength":135}],79:[function(require,module,exports){
module.exports = add;

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
    out[0] = a[0] + b[0]
    out[1] = a[1] + b[1]
    out[2] = a[2] + b[2]
    return out
}
},{}],80:[function(require,module,exports){
module.exports = angle

var fromValues = require('./fromValues')
var normalize = require('./normalize')
var dot = require('./dot')

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
    var tempA = fromValues(a[0], a[1], a[2])
    var tempB = fromValues(b[0], b[1], b[2])
 
    normalize(tempA, tempA)
    normalize(tempB, tempB)
 
    var cosine = dot(tempA, tempB)

    if(cosine > 1.0){
        return 0
    } else {
        return Math.acos(cosine)
    }     
}

},{"./dot":90,"./fromValues":96,"./normalize":107}],81:[function(require,module,exports){
module.exports = ceil

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0])
  out[1] = Math.ceil(a[1])
  out[2] = Math.ceil(a[2])
  return out
}

},{}],82:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
    var out = new Float32Array(3)
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}
},{}],83:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}
},{}],84:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
    var out = new Float32Array(3)
    out[0] = 0
    out[1] = 0
    out[2] = 0
    return out
}
},{}],85:[function(require,module,exports){
module.exports = cross;

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2]

    out[0] = ay * bz - az * by
    out[1] = az * bx - ax * bz
    out[2] = ax * by - ay * bx
    return out
}
},{}],86:[function(require,module,exports){
module.exports = require('./distance')

},{"./distance":87}],87:[function(require,module,exports){
module.exports = distance;

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return Math.sqrt(x*x + y*y + z*z)
}
},{}],88:[function(require,module,exports){
module.exports = require('./divide')

},{"./divide":89}],89:[function(require,module,exports){
module.exports = divide;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
    out[0] = a[0] / b[0]
    out[1] = a[1] / b[1]
    out[2] = a[2] / b[2]
    return out
}
},{}],90:[function(require,module,exports){
module.exports = dot;

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}
},{}],91:[function(require,module,exports){
module.exports = 0.000001

},{}],92:[function(require,module,exports){
module.exports = equals

var EPSILON = require('./epsilon')

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0]
  var a1 = a[1]
  var a2 = a[2]
  var b0 = b[0]
  var b1 = b[1]
  var b2 = b[2]
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))
}

},{"./epsilon":91}],93:[function(require,module,exports){
module.exports = exactEquals

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]
}

},{}],94:[function(require,module,exports){
module.exports = floor

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0])
  out[1] = Math.floor(a[1])
  out[2] = Math.floor(a[2])
  return out
}

},{}],95:[function(require,module,exports){
module.exports = forEach;

var vec = require('./create')()

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
function forEach(a, stride, offset, count, fn, arg) {
        var i, l
        if(!stride) {
            stride = 3
        }

        if(!offset) {
            offset = 0
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length)
        } else {
            l = a.length
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i] 
            vec[1] = a[i+1] 
            vec[2] = a[i+2]
            fn(vec, vec, arg)
            a[i] = vec[0] 
            a[i+1] = vec[1] 
            a[i+2] = vec[2]
        }
        
        return a
}
},{"./create":84}],96:[function(require,module,exports){
module.exports = fromValues;

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
    var out = new Float32Array(3)
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],97:[function(require,module,exports){
module.exports = {
  EPSILON: require('./epsilon')
  , create: require('./create')
  , clone: require('./clone')
  , angle: require('./angle')
  , fromValues: require('./fromValues')
  , copy: require('./copy')
  , set: require('./set')
  , equals: require('./equals')
  , exactEquals: require('./exactEquals')
  , add: require('./add')
  , subtract: require('./subtract')
  , sub: require('./sub')
  , multiply: require('./multiply')
  , mul: require('./mul')
  , divide: require('./divide')
  , div: require('./div')
  , min: require('./min')
  , max: require('./max')
  , floor: require('./floor')
  , ceil: require('./ceil')
  , round: require('./round')
  , scale: require('./scale')
  , scaleAndAdd: require('./scaleAndAdd')
  , distance: require('./distance')
  , dist: require('./dist')
  , squaredDistance: require('./squaredDistance')
  , sqrDist: require('./sqrDist')
  , length: require('./length')
  , len: require('./len')
  , squaredLength: require('./squaredLength')
  , sqrLen: require('./sqrLen')
  , negate: require('./negate')
  , inverse: require('./inverse')
  , normalize: require('./normalize')
  , dot: require('./dot')
  , cross: require('./cross')
  , lerp: require('./lerp')
  , random: require('./random')
  , transformMat4: require('./transformMat4')
  , transformMat3: require('./transformMat3')
  , transformQuat: require('./transformQuat')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , forEach: require('./forEach')
}

},{"./add":79,"./angle":80,"./ceil":81,"./clone":82,"./copy":83,"./create":84,"./cross":85,"./dist":86,"./distance":87,"./div":88,"./divide":89,"./dot":90,"./epsilon":91,"./equals":92,"./exactEquals":93,"./floor":94,"./forEach":95,"./fromValues":96,"./inverse":98,"./len":99,"./length":100,"./lerp":101,"./max":102,"./min":103,"./mul":104,"./multiply":105,"./negate":106,"./normalize":107,"./random":108,"./rotateX":109,"./rotateY":110,"./rotateZ":111,"./round":112,"./scale":113,"./scaleAndAdd":114,"./set":115,"./sqrDist":116,"./sqrLen":117,"./squaredDistance":118,"./squaredLength":119,"./sub":120,"./subtract":121,"./transformMat3":122,"./transformMat4":123,"./transformQuat":124}],98:[function(require,module,exports){
module.exports = inverse;

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0]
  out[1] = 1.0 / a[1]
  out[2] = 1.0 / a[2]
  return out
}
},{}],99:[function(require,module,exports){
module.exports = require('./length')

},{"./length":100}],100:[function(require,module,exports){
module.exports = length;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return Math.sqrt(x*x + y*y + z*z)
}
},{}],101:[function(require,module,exports){
module.exports = lerp;

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2]
    out[0] = ax + t * (b[0] - ax)
    out[1] = ay + t * (b[1] - ay)
    out[2] = az + t * (b[2] - az)
    return out
}
},{}],102:[function(require,module,exports){
module.exports = max;

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0])
    out[1] = Math.max(a[1], b[1])
    out[2] = Math.max(a[2], b[2])
    return out
}
},{}],103:[function(require,module,exports){
module.exports = min;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0])
    out[1] = Math.min(a[1], b[1])
    out[2] = Math.min(a[2], b[2])
    return out
}
},{}],104:[function(require,module,exports){
module.exports = require('./multiply')

},{"./multiply":105}],105:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
    out[0] = a[0] * b[0]
    out[1] = a[1] * b[1]
    out[2] = a[2] * b[2]
    return out
}
},{}],106:[function(require,module,exports){
module.exports = negate;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
    out[0] = -a[0]
    out[1] = -a[1]
    out[2] = -a[2]
    return out
}
},{}],107:[function(require,module,exports){
module.exports = normalize;

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    var len = x*x + y*y + z*z
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len)
        out[0] = a[0] * len
        out[1] = a[1] * len
        out[2] = a[2] * len
    }
    return out
}
},{}],108:[function(require,module,exports){
module.exports = random;

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
    scale = scale || 1.0

    var r = Math.random() * 2.0 * Math.PI
    var z = (Math.random() * 2.0) - 1.0
    var zScale = Math.sqrt(1.0-z*z) * scale

    out[0] = Math.cos(r) * zScale
    out[1] = Math.sin(r) * zScale
    out[2] = z * scale
    return out
}
},{}],109:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
    var by = b[1]
    var bz = b[2]

    // Translate point to the origin
    var py = a[1] - by
    var pz = a[2] - bz

    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = a[0]
    out[1] = by + py * cc - pz * sc
    out[2] = bz + py * sc + pz * cc

    return out
}

},{}],110:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
    var bx = b[0]
    var bz = b[2]

    // translate point to the origin
    var px = a[0] - bx
    var pz = a[2] - bz
    
    var sc = Math.sin(c)
    var cc = Math.cos(c)
  
    // perform rotation and translate to correct position
    out[0] = bx + pz * sc + px * cc
    out[1] = a[1]
    out[2] = bz + pz * cc - px * sc
  
    return out
}

},{}],111:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
    var bx = b[0]
    var by = b[1]

    //Translate point to the origin
    var px = a[0] - bx
    var py = a[1] - by
  
    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = bx + px * cc - py * sc
    out[1] = by + px * sc + py * cc
    out[2] = a[2]
  
    return out
}

},{}],112:[function(require,module,exports){
module.exports = round

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0])
  out[1] = Math.round(a[1])
  out[2] = Math.round(a[2])
  return out
}

},{}],113:[function(require,module,exports){
module.exports = scale;

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
    out[0] = a[0] * b
    out[1] = a[1] * b
    out[2] = a[2] * b
    return out
}
},{}],114:[function(require,module,exports){
module.exports = scaleAndAdd;

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale)
    out[1] = a[1] + (b[1] * scale)
    out[2] = a[2] + (b[2] * scale)
    return out
}
},{}],115:[function(require,module,exports){
module.exports = set;

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],116:[function(require,module,exports){
module.exports = require('./squaredDistance')

},{"./squaredDistance":118}],117:[function(require,module,exports){
module.exports = require('./squaredLength')

},{"./squaredLength":119}],118:[function(require,module,exports){
module.exports = squaredDistance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return x*x + y*y + z*z
}
},{}],119:[function(require,module,exports){
module.exports = squaredLength;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return x*x + y*y + z*z
}
},{}],120:[function(require,module,exports){
module.exports = require('./subtract')

},{"./subtract":121}],121:[function(require,module,exports){
module.exports = subtract;

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
    out[0] = a[0] - b[0]
    out[1] = a[1] - b[1]
    out[2] = a[2] - b[2]
    return out
}
},{}],122:[function(require,module,exports){
module.exports = transformMat3;

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2]
    out[0] = x * m[0] + y * m[3] + z * m[6]
    out[1] = x * m[1] + y * m[4] + z * m[7]
    out[2] = x * m[2] + y * m[5] + z * m[8]
    return out
}
},{}],123:[function(require,module,exports){
module.exports = transformMat4;

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15]
    w = w || 1.0
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
    return out
}
},{}],124:[function(require,module,exports){
module.exports = transformQuat;

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx
    return out
}
},{}],125:[function(require,module,exports){
module.exports = add

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add (out, a, b) {
  out[0] = a[0] + b[0]
  out[1] = a[1] + b[1]
  out[2] = a[2] + b[2]
  out[3] = a[3] + b[3]
  return out
}

},{}],126:[function(require,module,exports){
module.exports = clone

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone (a) {
  var out = new Float32Array(4)
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[3]
  return out
}

},{}],127:[function(require,module,exports){
module.exports = copy

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy (out, a) {
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[3]
  return out
}

},{}],128:[function(require,module,exports){
module.exports = dot

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot (a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
}

},{}],129:[function(require,module,exports){
module.exports = fromValues

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues (x, y, z, w) {
  var out = new Float32Array(4)
  out[0] = x
  out[1] = y
  out[2] = z
  out[3] = w
  return out
}

},{}],130:[function(require,module,exports){
module.exports = length

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length (a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3]
  return Math.sqrt(x * x + y * y + z * z + w * w)
}

},{}],131:[function(require,module,exports){
module.exports = lerp

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp (out, a, b, t) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3]
  out[0] = ax + t * (b[0] - ax)
  out[1] = ay + t * (b[1] - ay)
  out[2] = az + t * (b[2] - az)
  out[3] = aw + t * (b[3] - aw)
  return out
}

},{}],132:[function(require,module,exports){
module.exports = normalize

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize (out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3]
  var len = x * x + y * y + z * z + w * w
  if (len > 0) {
    len = 1 / Math.sqrt(len)
    out[0] = x * len
    out[1] = y * len
    out[2] = z * len
    out[3] = w * len
  }
  return out
}

},{}],133:[function(require,module,exports){
module.exports = scale

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale (out, a, b) {
  out[0] = a[0] * b
  out[1] = a[1] * b
  out[2] = a[2] * b
  out[3] = a[3] * b
  return out
}

},{}],134:[function(require,module,exports){
module.exports = set

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set (out, x, y, z, w) {
  out[0] = x
  out[1] = y
  out[2] = z
  out[3] = w
  return out
}

},{}],135:[function(require,module,exports){
module.exports = squaredLength

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3]
  return x * x + y * y + z * z + w * w
}

},{}],136:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],137:[function(require,module,exports){
module.exports = attributeToProperty

var transform = {
  'class': 'className',
  'for': 'htmlFor',
  'http-equiv': 'httpEquiv'
}

function attributeToProperty (h) {
  return function (tagName, attrs, children) {
    for (var attr in attrs) {
      if (attr in transform) {
        attrs[transform[attr]] = attrs[attr]
        delete attrs[attr]
      }
    }
    return h(tagName, attrs, children)
  }
}

},{}],138:[function(require,module,exports){
var attrToProp = require('hyperscript-attribute-to-property')

var VAR = 0, TEXT = 1, OPEN = 2, CLOSE = 3, ATTR = 4
var ATTR_KEY = 5, ATTR_KEY_W = 6
var ATTR_VALUE_W = 7, ATTR_VALUE = 8
var ATTR_VALUE_SQ = 9, ATTR_VALUE_DQ = 10
var ATTR_EQ = 11, ATTR_BREAK = 12
var COMMENT = 13

module.exports = function (h, opts) {
  if (!opts) opts = {}
  var concat = opts.concat || function (a, b) {
    return String(a) + String(b)
  }
  if (opts.attrToProp !== false) {
    h = attrToProp(h)
  }

  return function (strings) {
    var state = TEXT, reg = ''
    var arglen = arguments.length
    var parts = []

    for (var i = 0; i < strings.length; i++) {
      if (i < arglen - 1) {
        var arg = arguments[i+1]
        var p = parse(strings[i])
        var xstate = state
        if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE
        if (xstate === ATTR) xstate = ATTR_KEY
        if (xstate === OPEN) {
          if (reg === '/') {
            p.push([ OPEN, '/', arg ])
            reg = ''
          } else {
            p.push([ OPEN, arg ])
          }
        } else if (xstate === COMMENT && opts.comments) {
          reg += String(arg)
        } else if (xstate !== COMMENT) {
          p.push([ VAR, xstate, arg ])
        }
        parts.push.apply(parts, p)
      } else parts.push.apply(parts, parse(strings[i]))
    }

    var tree = [null,{},[]]
    var stack = [[tree,-1]]
    for (var i = 0; i < parts.length; i++) {
      var cur = stack[stack.length-1][0]
      var p = parts[i], s = p[0]
      if (s === OPEN && /^\//.test(p[1])) {
        var ix = stack[stack.length-1][1]
        if (stack.length > 1) {
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === OPEN) {
        var c = [p[1],{},[]]
        cur[2].push(c)
        stack.push([c,cur[2].length-1])
      } else if (s === ATTR_KEY || (s === VAR && p[1] === ATTR_KEY)) {
        var key = ''
        var copyKey
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_KEY) {
            key = concat(key, parts[i][1])
          } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {
            if (typeof parts[i][2] === 'object' && !key) {
              for (copyKey in parts[i][2]) {
                if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {
                  cur[1][copyKey] = parts[i][2][copyKey]
                }
              }
            } else {
              key = concat(key, parts[i][2])
            }
          } else break
        }
        if (parts[i][0] === ATTR_EQ) i++
        var j = i
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][1])
            else parts[i][1]==="" || (cur[1][key] = concat(cur[1][key], parts[i][1]));
          } else if (parts[i][0] === VAR
          && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][2])
            else parts[i][2]==="" || (cur[1][key] = concat(cur[1][key], parts[i][2]));
          } else {
            if (key.length && !cur[1][key] && i === j
            && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
              // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
              // empty string is falsy, not well behaved value in browser
              cur[1][key] = key.toLowerCase()
            }
            if (parts[i][0] === CLOSE) {
              i--
            }
            break
          }
        }
      } else if (s === ATTR_KEY) {
        cur[1][p[1]] = true
      } else if (s === VAR && p[1] === ATTR_KEY) {
        cur[1][p[2]] = true
      } else if (s === CLOSE) {
        if (selfClosing(cur[0]) && stack.length) {
          var ix = stack[stack.length-1][1]
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === VAR && p[1] === TEXT) {
        if (p[2] === undefined || p[2] === null) p[2] = ''
        else if (!p[2]) p[2] = concat('', p[2])
        if (Array.isArray(p[2][0])) {
          cur[2].push.apply(cur[2], p[2])
        } else {
          cur[2].push(p[2])
        }
      } else if (s === TEXT) {
        cur[2].push(p[1])
      } else if (s === ATTR_EQ || s === ATTR_BREAK) {
        // no-op
      } else {
        throw new Error('unhandled: ' + s)
      }
    }

    if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) {
      tree[2].shift()
    }

    if (tree[2].length > 2
    || (tree[2].length === 2 && /\S/.test(tree[2][1]))) {
      if (opts.createFragment) return opts.createFragment(tree[2])
      throw new Error(
        'multiple root elements must be wrapped in an enclosing tag'
      )
    }
    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === 'string'
    && Array.isArray(tree[2][0][2])) {
      tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2])
    }
    return tree[2][0]

    function parse (str) {
      var res = []
      if (state === ATTR_VALUE_W) state = ATTR
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i)
        if (state === TEXT && c === '<') {
          if (reg.length) res.push([TEXT, reg])
          reg = ''
          state = OPEN
        } else if (c === '>' && !quot(state) && state !== COMMENT) {
          if (state === OPEN && reg.length) {
            res.push([OPEN,reg])
          } else if (state === ATTR_KEY) {
            res.push([ATTR_KEY,reg])
          } else if (state === ATTR_VALUE && reg.length) {
            res.push([ATTR_VALUE,reg])
          }
          res.push([CLOSE])
          reg = ''
          state = TEXT
        } else if (state === COMMENT && /-$/.test(reg) && c === '-') {
          if (opts.comments) {
            res.push([ATTR_VALUE,reg.substr(0, reg.length - 1)])
          }
          reg = ''
          state = TEXT
        } else if (state === OPEN && /^!--$/.test(reg)) {
          if (opts.comments) {
            res.push([OPEN, reg],[ATTR_KEY,'comment'],[ATTR_EQ])
          }
          reg = c
          state = COMMENT
        } else if (state === TEXT || state === COMMENT) {
          reg += c
        } else if (state === OPEN && c === '/' && reg.length) {
          // no-op, self closing tag without a space <br/>
        } else if (state === OPEN && /\s/.test(c)) {
          if (reg.length) {
            res.push([OPEN, reg])
          }
          reg = ''
          state = ATTR
        } else if (state === OPEN) {
          reg += c
        } else if (state === ATTR && /[^\s"'=/]/.test(c)) {
          state = ATTR_KEY
          reg = c
        } else if (state === ATTR && /\s/.test(c)) {
          if (reg.length) res.push([ATTR_KEY,reg])
          res.push([ATTR_BREAK])
        } else if (state === ATTR_KEY && /\s/.test(c)) {
          res.push([ATTR_KEY,reg])
          reg = ''
          state = ATTR_KEY_W
        } else if (state === ATTR_KEY && c === '=') {
          res.push([ATTR_KEY,reg],[ATTR_EQ])
          reg = ''
          state = ATTR_VALUE_W
        } else if (state === ATTR_KEY) {
          reg += c
        } else if ((state === ATTR_KEY_W || state === ATTR) && c === '=') {
          res.push([ATTR_EQ])
          state = ATTR_VALUE_W
        } else if ((state === ATTR_KEY_W || state === ATTR) && !/\s/.test(c)) {
          res.push([ATTR_BREAK])
          if (/[\w-]/.test(c)) {
            reg += c
            state = ATTR_KEY
          } else state = ATTR
        } else if (state === ATTR_VALUE_W && c === '"') {
          state = ATTR_VALUE_DQ
        } else if (state === ATTR_VALUE_W && c === "'") {
          state = ATTR_VALUE_SQ
        } else if (state === ATTR_VALUE_DQ && c === '"') {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_SQ && c === "'") {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_W && !/\s/.test(c)) {
          state = ATTR_VALUE
          i--
        } else if (state === ATTR_VALUE && /\s/.test(c)) {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ
        || state === ATTR_VALUE_DQ) {
          reg += c
        }
      }
      if (state === TEXT && reg.length) {
        res.push([TEXT,reg])
        reg = ''
      } else if (state === ATTR_VALUE && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_DQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_SQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_KEY) {
        res.push([ATTR_KEY,reg])
        reg = ''
      }
      return res
    }
  }

  function strfn (x) {
    if (typeof x === 'function') return x
    else if (typeof x === 'string') return x
    else if (x && typeof x === 'object') return x
    else if (x === null || x === undefined) return x
    else return concat('', x)
  }
}

function quot (state) {
  return state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ
}

var closeRE = RegExp('^(' + [
  'area', 'base', 'basefont', 'bgsound', 'br', 'col', 'command', 'embed',
  'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param',
  'source', 'track', 'wbr', '!--',
  // SVG TAGS
  'animate', 'animateTransform', 'circle', 'cursor', 'desc', 'ellipse',
  'feBlend', 'feColorMatrix', 'feComposite',
  'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap',
  'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR',
  'feGaussianBlur', 'feImage', 'feMergeNode', 'feMorphology',
  'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile',
  'feTurbulence', 'font-face-format', 'font-face-name', 'font-face-uri',
  'glyph', 'glyphRef', 'hkern', 'image', 'line', 'missing-glyph', 'mpath',
  'path', 'polygon', 'polyline', 'rect', 'set', 'stop', 'tref', 'use', 'view',
  'vkern'
].join('|') + ')(?:[\.#][a-zA-Z0-9\u007F-\uFFFF_:-]+)*$')
function selfClosing (tag) { return closeRE.test(tag) }

},{"hyperscript-attribute-to-property":137}],139:[function(require,module,exports){
'use strict'

module.exports = mouseListen

var mouse = require('mouse-event')

function mouseListen (element, callback) {
  if (!callback) {
    callback = element
    element = window
  }

  var buttonState = 0
  var x = 0
  var y = 0
  var mods = {
    shift: false,
    alt: false,
    control: false,
    meta: false
  }
  var attached = false

  function updateMods (ev) {
    var changed = false
    if ('altKey' in ev) {
      changed = changed || ev.altKey !== mods.alt
      mods.alt = !!ev.altKey
    }
    if ('shiftKey' in ev) {
      changed = changed || ev.shiftKey !== mods.shift
      mods.shift = !!ev.shiftKey
    }
    if ('ctrlKey' in ev) {
      changed = changed || ev.ctrlKey !== mods.control
      mods.control = !!ev.ctrlKey
    }
    if ('metaKey' in ev) {
      changed = changed || ev.metaKey !== mods.meta
      mods.meta = !!ev.metaKey
    }
    return changed
  }

  function handleEvent (nextButtons, ev) {
    var nextX = mouse.x(ev)
    var nextY = mouse.y(ev)
    if ('buttons' in ev) {
      nextButtons = ev.buttons | 0
    }
    if (nextButtons !== buttonState ||
      nextX !== x ||
      nextY !== y ||
      updateMods(ev)) {
      buttonState = nextButtons | 0
      x = nextX || 0
      y = nextY || 0
      callback && callback(buttonState, x, y, mods)
    }
  }

  function clearState (ev) {
    handleEvent(0, ev)
  }

  function handleBlur () {
    if (buttonState ||
      x ||
      y ||
      mods.shift ||
      mods.alt ||
      mods.meta ||
      mods.control) {
      x = y = 0
      buttonState = 0
      mods.shift = mods.alt = mods.control = mods.meta = false
      callback && callback(0, 0, 0, mods)
    }
  }

  function handleMods (ev) {
    if (updateMods(ev)) {
      callback && callback(buttonState, x, y, mods)
    }
  }

  function handleMouseMove (ev) {
    if (mouse.buttons(ev) === 0) {
      handleEvent(0, ev)
    } else {
      handleEvent(buttonState, ev)
    }
  }

  function handleMouseDown (ev) {
    handleEvent(buttonState | mouse.buttons(ev), ev)
  }

  function handleMouseUp (ev) {
    handleEvent(buttonState & ~mouse.buttons(ev), ev)
  }

  function attachListeners () {
    if (attached) {
      return
    }
    attached = true

    element.addEventListener('mousemove', handleMouseMove)

    element.addEventListener('mousedown', handleMouseDown)

    element.addEventListener('mouseup', handleMouseUp)

    element.addEventListener('mouseleave', clearState)
    element.addEventListener('mouseenter', clearState)
    element.addEventListener('mouseout', clearState)
    element.addEventListener('mouseover', clearState)

    element.addEventListener('blur', handleBlur)

    element.addEventListener('keyup', handleMods)
    element.addEventListener('keydown', handleMods)
    element.addEventListener('keypress', handleMods)

    if (element !== window) {
      window.addEventListener('blur', handleBlur)

      window.addEventListener('keyup', handleMods)
      window.addEventListener('keydown', handleMods)
      window.addEventListener('keypress', handleMods)
    }
  }

  function detachListeners () {
    if (!attached) {
      return
    }
    attached = false

    element.removeEventListener('mousemove', handleMouseMove)

    element.removeEventListener('mousedown', handleMouseDown)

    element.removeEventListener('mouseup', handleMouseUp)

    element.removeEventListener('mouseleave', clearState)
    element.removeEventListener('mouseenter', clearState)
    element.removeEventListener('mouseout', clearState)
    element.removeEventListener('mouseover', clearState)

    element.removeEventListener('blur', handleBlur)

    element.removeEventListener('keyup', handleMods)
    element.removeEventListener('keydown', handleMods)
    element.removeEventListener('keypress', handleMods)

    if (element !== window) {
      window.removeEventListener('blur', handleBlur)

      window.removeEventListener('keyup', handleMods)
      window.removeEventListener('keydown', handleMods)
      window.removeEventListener('keypress', handleMods)
    }
  }

  // Attach listeners
  attachListeners()

  var result = {
    element: element
  }

  Object.defineProperties(result, {
    enabled: {
      get: function () { return attached },
      set: function (f) {
        if (f) {
          attachListeners()
        } else {
          detachListeners()
        }
      },
      enumerable: true
    },
    buttons: {
      get: function () { return buttonState },
      enumerable: true
    },
    x: {
      get: function () { return x },
      enumerable: true
    },
    y: {
      get: function () { return y },
      enumerable: true
    },
    mods: {
      get: function () { return mods },
      enumerable: true
    }
  })

  return result
}

},{"mouse-event":140}],140:[function(require,module,exports){
'use strict'

function mouseButtons(ev) {
  if(typeof ev === 'object') {
    if('buttons' in ev) {
      return ev.buttons
    } else if('which' in ev) {
      var b = ev.which
      if(b === 2) {
        return 4
      } else if(b === 3) {
        return 2
      } else if(b > 0) {
        return 1<<(b-1)
      }
    } else if('button' in ev) {
      var b = ev.button
      if(b === 1) {
        return 4
      } else if(b === 2) {
        return 2
      } else if(b >= 0) {
        return 1<<b
      }
    }
  }
  return 0
}
exports.buttons = mouseButtons

function mouseElement(ev) {
  return ev.target || ev.srcElement || window
}
exports.element = mouseElement

function mouseRelativeX(ev) {
  if(typeof ev === 'object') {
    if('offsetX' in ev) {
      return ev.offsetX
    }
    var target = mouseElement(ev)
    var bounds = target.getBoundingClientRect()
    return ev.clientX - bounds.left
  }
  return 0
}
exports.x = mouseRelativeX

function mouseRelativeY(ev) {
  if(typeof ev === 'object') {
    if('offsetY' in ev) {
      return ev.offsetY
    }
    var target = mouseElement(ev)
    var bounds = target.getBoundingClientRect()
    return ev.clientY - bounds.top
  }
  return 0
}
exports.y = mouseRelativeY

},{}],141:[function(require,module,exports){
'use strict'

var toPX = require('to-px')

module.exports = mouseWheelListen

function mouseWheelListen(element, callback, noScroll) {
  if(typeof element === 'function') {
    noScroll = !!callback
    callback = element
    element = window
  }
  var lineHeight = toPX('ex', element)
  var listener = function(ev) {
    if(noScroll) {
      ev.preventDefault()
    }
    var dx = ev.deltaX || 0
    var dy = ev.deltaY || 0
    var dz = ev.deltaZ || 0
    var mode = ev.deltaMode
    var scale = 1
    switch(mode) {
      case 1:
        scale = lineHeight
      break
      case 2:
        scale = window.innerHeight
      break
    }
    dx *= scale
    dy *= scale
    dz *= scale
    if(dx || dy || dz) {
      return callback(dx, dy, dz, ev)
    }
  }
  element.addEventListener('wheel', listener)
  return listener
}

},{"to-px":166}],142:[function(require,module,exports){
assert.notEqual = notEqual
assert.notOk = notOk
assert.equal = equal
assert.ok = assert

module.exports = assert

function equal (a, b, m) {
  assert(a == b, m) // eslint-disable-line eqeqeq
}

function notEqual (a, b, m) {
  assert(a != b, m) // eslint-disable-line eqeqeq
}

function notOk (t, m) {
  assert(!t, m)
}

function assert (t, m) {
  if (!t) throw new Error(m || 'AssertionError')
}

},{}],143:[function(require,module,exports){
var splice = require('remove-array-items')
var nanotiming = require('nanotiming')
var assert = require('assert')

module.exports = Nanobus

function Nanobus (name) {
  if (!(this instanceof Nanobus)) return new Nanobus(name)

  this._name = name || 'nanobus'
  this._starListeners = []
  this._listeners = {}
}

Nanobus.prototype.emit = function (eventName) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.emit: eventName should be type string or symbol')

  var data = []
  for (var i = 1, len = arguments.length; i < len; i++) {
    data.push(arguments[i])
  }

  var emitTiming = nanotiming(this._name + "('" + eventName.toString() + "')")
  var listeners = this._listeners[eventName]
  if (listeners && listeners.length > 0) {
    this._emit(this._listeners[eventName], data)
  }

  if (this._starListeners.length > 0) {
    this._emit(this._starListeners, eventName, data, emitTiming.uuid)
  }
  emitTiming()

  return this
}

Nanobus.prototype.on = Nanobus.prototype.addListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.on: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.on: listener should be type function')

  if (eventName === '*') {
    this._starListeners.push(listener)
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = []
    this._listeners[eventName].push(listener)
  }
  return this
}

Nanobus.prototype.prependListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.prependListener: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.prependListener: listener should be type function')

  if (eventName === '*') {
    this._starListeners.unshift(listener)
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = []
    this._listeners[eventName].unshift(listener)
  }
  return this
}

Nanobus.prototype.once = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.once: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.once: listener should be type function')

  var self = this
  this.on(eventName, once)
  function once () {
    listener.apply(self, arguments)
    self.removeListener(eventName, once)
  }
  return this
}

Nanobus.prototype.prependOnceListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.prependOnceListener: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.prependOnceListener: listener should be type function')

  var self = this
  this.prependListener(eventName, once)
  function once () {
    listener.apply(self, arguments)
    self.removeListener(eventName, once)
  }
  return this
}

Nanobus.prototype.removeListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.removeListener: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.removeListener: listener should be type function')

  if (eventName === '*') {
    this._starListeners = this._starListeners.slice()
    return remove(this._starListeners, listener)
  } else {
    if (typeof this._listeners[eventName] !== 'undefined') {
      this._listeners[eventName] = this._listeners[eventName].slice()
    }

    return remove(this._listeners[eventName], listener)
  }

  function remove (arr, listener) {
    if (!arr) return
    var index = arr.indexOf(listener)
    if (index !== -1) {
      splice(arr, index, 1)
      return true
    }
  }
}

Nanobus.prototype.removeAllListeners = function (eventName) {
  if (eventName) {
    if (eventName === '*') {
      this._starListeners = []
    } else {
      this._listeners[eventName] = []
    }
  } else {
    this._starListeners = []
    this._listeners = {}
  }
  return this
}

Nanobus.prototype.listeners = function (eventName) {
  var listeners = eventName !== '*'
    ? this._listeners[eventName]
    : this._starListeners

  var ret = []
  if (listeners) {
    var ilength = listeners.length
    for (var i = 0; i < ilength; i++) ret.push(listeners[i])
  }
  return ret
}

Nanobus.prototype._emit = function (arr, eventName, data, uuid) {
  if (typeof arr === 'undefined') return
  if (arr.length === 0) return
  if (data === undefined) {
    data = eventName
    eventName = null
  }

  if (eventName) {
    if (uuid !== undefined) {
      data = [eventName].concat(data, uuid)
    } else {
      data = [eventName].concat(data)
    }
  }

  var length = arr.length
  for (var i = 0; i < length; i++) {
    var listener = arr[i]
    listener.apply(listener, data)
  }
}

},{"assert":142,"nanotiming":159,"remove-array-items":163}],144:[function(require,module,exports){
var assert = require('assert')

var safeExternalLink = /(noopener|noreferrer) (noopener|noreferrer)/
var protocolLink = /^[\w-_]+:/

module.exports = href

function href (cb, root) {
  assert.notEqual(typeof window, 'undefined', 'nanohref: expected window to exist')

  root = root || window.document

  assert.equal(typeof cb, 'function', 'nanohref: cb should be type function')
  assert.equal(typeof root, 'object', 'nanohref: root should be type object')

  window.addEventListener('click', function (e) {
    if ((e.button && e.button !== 0) ||
      e.ctrlKey || e.metaKey || e.altKey || e.shiftKey ||
      e.defaultPrevented) return

    var anchor = (function traverse (node) {
      if (!node || node === root) return
      if (node.localName !== 'a' || node.href === undefined) {
        return traverse(node.parentNode)
      }
      return node
    })(e.target)

    if (!anchor) return

    if (window.location.protocol !== anchor.protocol ||
        window.location.hostname !== anchor.hostname ||
        window.location.port !== anchor.port ||
      anchor.hasAttribute('data-nanohref-ignore') ||
      anchor.hasAttribute('download') ||
      (anchor.getAttribute('target') === '_blank' &&
        safeExternalLink.test(anchor.getAttribute('rel'))) ||
      protocolLink.test(anchor.getAttribute('href'))) return

    e.preventDefault()
    cb(anchor)
  })
}

},{"assert":142}],145:[function(require,module,exports){
'use strict'

var trailingNewlineRegex = /\n[\s]+$/
var leadingNewlineRegex = /^\n[\s]+/
var trailingSpaceRegex = /[\s]+$/
var leadingSpaceRegex = /^[\s]+/
var multiSpaceRegex = /[\n\s]+/g

var TEXT_TAGS = [
  'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'data', 'dfn', 'em', 'i',
  'kbd', 'mark', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'amp', 'small', 'span',
  'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr'
]

var VERBATIM_TAGS = [
  'code', 'pre', 'textarea'
]

module.exports = function appendChild (el, childs) {
  if (!Array.isArray(childs)) return

  var nodeName = el.nodeName.toLowerCase()

  var hadText = false
  var value, leader

  for (var i = 0, len = childs.length; i < len; i++) {
    var node = childs[i]
    if (Array.isArray(node)) {
      appendChild(el, node)
      continue
    }

    if (typeof node === 'number' ||
      typeof node === 'boolean' ||
      typeof node === 'function' ||
      node instanceof Date ||
      node instanceof RegExp) {
      node = node.toString()
    }

    var lastChild = el.childNodes[el.childNodes.length - 1]

    // Iterate over text nodes
    if (typeof node === 'string') {
      hadText = true

      // If we already had text, append to the existing text
      if (lastChild && lastChild.nodeName === '#text') {
        lastChild.nodeValue += node

      // We didn't have a text node yet, create one
      } else {
        node = el.ownerDocument.createTextNode(node)
        el.appendChild(node)
        lastChild = node
      }

      // If this is the last of the child nodes, make sure we close it out
      // right
      if (i === len - 1) {
        hadText = false
        // Trim the child text nodes if the current node isn't a
        // node where whitespace matters.
        if (TEXT_TAGS.indexOf(nodeName) === -1 &&
          VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, '')
            .replace(trailingSpaceRegex, '')
            .replace(trailingNewlineRegex, '')
            .replace(multiSpaceRegex, ' ')
          if (value === '') {
            el.removeChild(lastChild)
          } else {
            lastChild.nodeValue = value
          }
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          // The very first node in the list should not have leading
          // whitespace. Sibling text nodes should have whitespace if there
          // was any.
          leader = i === 0 ? '' : ' '
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, leader)
            .replace(leadingSpaceRegex, ' ')
            .replace(trailingSpaceRegex, '')
            .replace(trailingNewlineRegex, '')
            .replace(multiSpaceRegex, ' ')
          lastChild.nodeValue = value
        }
      }

    // Iterate over DOM nodes
    } else if (node && node.nodeType) {
      // If the last node was a text node, make sure it is properly closed out
      if (hadText) {
        hadText = false

        // Trim the child text nodes if the current node isn't a
        // text node or a code node
        if (TEXT_TAGS.indexOf(nodeName) === -1 &&
          VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, '')
            .replace(trailingNewlineRegex, ' ')
            .replace(multiSpaceRegex, ' ')

          // Remove empty text nodes, append otherwise
          if (value === '') {
            el.removeChild(lastChild)
          } else {
            lastChild.nodeValue = value
          }
        // Trim the child nodes but preserve the appropriate whitespace
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingSpaceRegex, ' ')
            .replace(leadingNewlineRegex, '')
            .replace(trailingNewlineRegex, ' ')
            .replace(multiSpaceRegex, ' ')
          lastChild.nodeValue = value
        }
      }

      // Store the last nodename
      var _nodeName = node.nodeName
      if (_nodeName) nodeName = _nodeName.toLowerCase()

      // Append the node to the DOM
      el.appendChild(node)
    }
  }
}

},{}],146:[function(require,module,exports){
'use strict'

module.exports = [
  'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default',
  'defaultchecked', 'defer', 'disabled', 'formnovalidate', 'hidden',
  'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'open', 'playsinline',
  'readonly', 'required', 'reversed', 'selected'
]

},{}],147:[function(require,module,exports){
module.exports = require('./dom')(document)

},{"./dom":149}],148:[function(require,module,exports){
'use strict'

module.exports = [
  'indeterminate'
]

},{}],149:[function(require,module,exports){
'use strict'

var hyperx = require('hyperx')
var appendChild = require('./append-child')
var SVG_TAGS = require('./svg-tags')
var BOOL_PROPS = require('./bool-props')
// Props that need to be set directly rather than with el.setAttribute()
var DIRECT_PROPS = require('./direct-props')

var SVGNS = 'http://www.w3.org/2000/svg'
var XLINKNS = 'http://www.w3.org/1999/xlink'

var COMMENT_TAG = '!--'

module.exports = function (document) {
  function nanoHtmlCreateElement (tag, props, children) {
    var el

    // If an svg tag, it needs a namespace
    if (SVG_TAGS.indexOf(tag) !== -1) {
      props.namespace = SVGNS
    }

    // If we are using a namespace
    var ns = false
    if (props.namespace) {
      ns = props.namespace
      delete props.namespace
    }

    // If we are extending a builtin element
    var isCustomElement = false
    if (props.is) {
      isCustomElement = props.is
      delete props.is
    }

    // Create the element
    if (ns) {
      if (isCustomElement) {
        el = document.createElementNS(ns, tag, { is: isCustomElement })
      } else {
        el = document.createElementNS(ns, tag)
      }
    } else if (tag === COMMENT_TAG) {
      return document.createComment(props.comment)
    } else if (isCustomElement) {
      el = document.createElement(tag, { is: isCustomElement })
    } else {
      el = document.createElement(tag)
    }

    // Create the properties
    for (var p in props) {
      if (props.hasOwnProperty(p)) {
        var key = p.toLowerCase()
        var val = props[p]
        // Normalize className
        if (key === 'classname') {
          key = 'class'
          p = 'class'
        }
        // The for attribute gets transformed to htmlFor, but we just set as for
        if (p === 'htmlFor') {
          p = 'for'
        }
        // If a property is boolean, set itself to the key
        if (BOOL_PROPS.indexOf(key) !== -1) {
          if (String(val) === 'true') val = key
          else if (String(val) === 'false') continue
        }
        // If a property prefers being set directly vs setAttribute
        if (key.slice(0, 2) === 'on' || DIRECT_PROPS.indexOf(key) !== -1) {
          el[p] = val
        } else {
          if (ns) {
            if (p === 'xlink:href') {
              el.setAttributeNS(XLINKNS, p, val)
            } else if (/^xmlns($|:)/i.test(p)) {
              // skip xmlns definitions
            } else {
              el.setAttributeNS(null, p, val)
            }
          } else {
            el.setAttribute(p, val)
          }
        }
      }
    }

    appendChild(el, children)
    return el
  }

  function createFragment (nodes) {
    var fragment = document.createDocumentFragment()
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] == null) continue
      if (Array.isArray(nodes[i])) {
        fragment.appendChild(createFragment(nodes[i]))
      } else {
        if (typeof nodes[i] === 'string') nodes[i] = document.createTextNode(nodes[i])
        fragment.appendChild(nodes[i])
      }
    }
    return fragment
  }

  var exports = hyperx(nanoHtmlCreateElement, {
    comments: true,
    createFragment: createFragment
  })
  exports.default = exports
  exports.createComment = nanoHtmlCreateElement
  return exports
}

},{"./append-child":145,"./bool-props":146,"./direct-props":148,"./svg-tags":150,"hyperx":138}],150:[function(require,module,exports){
'use strict'

module.exports = [
  'svg', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor',
  'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile',
  'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
  'feComponentTransfer', 'feComposite', 'feConvolveMatrix',
  'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood',
  'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage',
  'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight',
  'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter',
  'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src',
  'font-face-uri', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image',
  'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph',
  'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect',
  'set', 'stop', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref',
  'tspan', 'use', 'view', 'vkern'
]

},{}],151:[function(require,module,exports){
module.exports = LRU

function LRU (opts) {
  if (!(this instanceof LRU)) return new LRU(opts)
  if (typeof opts === 'number') opts = {max: opts}
  if (!opts) opts = {}
  this.cache = {}
  this.head = this.tail = null
  this.length = 0
  this.max = opts.max || 1000
  this.maxAge = opts.maxAge || 0
}

Object.defineProperty(LRU.prototype, 'keys', {
  get: function () { return Object.keys(this.cache) }
})

LRU.prototype.clear = function () {
  this.cache = {}
  this.head = this.tail = null
  this.length = 0
}

LRU.prototype.remove = function (key) {
  if (typeof key !== 'string') key = '' + key
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]
  delete this.cache[key]
  this._unlink(key, element.prev, element.next)
  return element.value
}

LRU.prototype._unlink = function (key, prev, next) {
  this.length--

  if (this.length === 0) {
    this.head = this.tail = null
  } else {
    if (this.head === key) {
      this.head = prev
      this.cache[this.head].next = null
    } else if (this.tail === key) {
      this.tail = next
      this.cache[this.tail].prev = null
    } else {
      this.cache[prev].next = next
      this.cache[next].prev = prev
    }
  }
}

LRU.prototype.peek = function (key) {
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]

  if (!this._checkAge(key, element)) return
  return element.value
}

LRU.prototype.set = function (key, value) {
  if (typeof key !== 'string') key = '' + key

  var element

  if (this.cache.hasOwnProperty(key)) {
    element = this.cache[key]
    element.value = value
    if (this.maxAge) element.modified = Date.now()

    // If it's already the head, there's nothing more to do:
    if (key === this.head) return value
    this._unlink(key, element.prev, element.next)
  } else {
    element = {value: value, modified: 0, next: null, prev: null}
    if (this.maxAge) element.modified = Date.now()
    this.cache[key] = element

    // Eviction is only possible if the key didn't already exist:
    if (this.length === this.max) this.evict()
  }

  this.length++
  element.next = null
  element.prev = this.head

  if (this.head) this.cache[this.head].next = key
  this.head = key

  if (!this.tail) this.tail = key
  return value
}

LRU.prototype._checkAge = function (key, element) {
  if (this.maxAge && (Date.now() - element.modified) > this.maxAge) {
    this.remove(key)
    return false
  }
  return true
}

LRU.prototype.get = function (key) {
  if (typeof key !== 'string') key = '' + key
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]

  if (!this._checkAge(key, element)) return

  if (this.head !== key) {
    if (key === this.tail) {
      this.tail = element.next
      this.cache[this.tail].prev = null
    } else {
      // Set prev.next -> element.next:
      this.cache[element.prev].next = element.next
    }

    // Set element.next.prev -> element.prev:
    this.cache[element.next].prev = element.prev

    // Element is the new head
    this.cache[this.head].next = key
    element.prev = this.head
    element.next = null
    this.head = key
  }

  return element.value
}

LRU.prototype.evict = function () {
  if (!this.tail) return
  this.remove(this.tail)
}

},{}],152:[function(require,module,exports){
var assert = require('nanoassert')
var morph = require('./lib/morph')

var TEXT_NODE = 3
// var DEBUG = false

module.exports = nanomorph

// Morph one tree into another tree
//
// no parent
//   -> same: diff and walk children
//   -> not same: replace and return
// old node doesn't exist
//   -> insert new node
// new node doesn't exist
//   -> delete old node
// nodes are not the same
//   -> diff nodes and apply patch to old node
// nodes are the same
//   -> walk all child nodes and append to old node
function nanomorph (oldTree, newTree, options) {
  // if (DEBUG) {
  //   console.log(
  //   'nanomorph\nold\n  %s\nnew\n  %s',
  //   oldTree && oldTree.outerHTML,
  //   newTree && newTree.outerHTML
  // )
  // }
  assert.equal(typeof oldTree, 'object', 'nanomorph: oldTree should be an object')
  assert.equal(typeof newTree, 'object', 'nanomorph: newTree should be an object')

  if (options && options.childrenOnly) {
    updateChildren(newTree, oldTree)
    return oldTree
  }

  assert.notEqual(
    newTree.nodeType,
    11,
    'nanomorph: newTree should have one root node (which is not a DocumentFragment)'
  )

  return walk(newTree, oldTree)
}

// Walk and morph a dom tree
function walk (newNode, oldNode) {
  // if (DEBUG) {
  //   console.log(
  //   'walk\nold\n  %s\nnew\n  %s',
  //   oldNode && oldNode.outerHTML,
  //   newNode && newNode.outerHTML
  // )
  // }
  if (!oldNode) {
    return newNode
  } else if (!newNode) {
    return null
  } else if (newNode.isSameNode && newNode.isSameNode(oldNode)) {
    return oldNode
  } else if (newNode.tagName !== oldNode.tagName || getComponentId(newNode) !== getComponentId(oldNode)) {
    return newNode
  } else {
    morph(newNode, oldNode)
    updateChildren(newNode, oldNode)
    return oldNode
  }
}

function getComponentId (node) {
  return node.dataset ? node.dataset.nanomorphComponentId : undefined
}

// Update the children of elements
// (obj, obj) -> null
function updateChildren (newNode, oldNode) {
  // if (DEBUG) {
  //   console.log(
  //   'updateChildren\nold\n  %s\nnew\n  %s',
  //   oldNode && oldNode.outerHTML,
  //   newNode && newNode.outerHTML
  // )
  // }
  var oldChild, newChild, morphed, oldMatch

  // The offset is only ever increased, and used for [i - offset] in the loop
  var offset = 0

  for (var i = 0; ; i++) {
    oldChild = oldNode.childNodes[i]
    newChild = newNode.childNodes[i - offset]
    // if (DEBUG) {
    //   console.log(
    //   '===\n- old\n  %s\n- new\n  %s',
    //   oldChild && oldChild.outerHTML,
    //   newChild && newChild.outerHTML
    // )
    // }
    // Both nodes are empty, do nothing
    if (!oldChild && !newChild) {
      break

    // There is no new child, remove old
    } else if (!newChild) {
      oldNode.removeChild(oldChild)
      i--

    // There is no old child, add new
    } else if (!oldChild) {
      oldNode.appendChild(newChild)
      offset++

    // Both nodes are the same, morph
    } else if (same(newChild, oldChild)) {
      morphed = walk(newChild, oldChild)
      if (morphed !== oldChild) {
        oldNode.replaceChild(morphed, oldChild)
        offset++
      }

    // Both nodes do not share an ID or a placeholder, try reorder
    } else {
      oldMatch = null

      // Try and find a similar node somewhere in the tree
      for (var j = i; j < oldNode.childNodes.length; j++) {
        if (same(oldNode.childNodes[j], newChild)) {
          oldMatch = oldNode.childNodes[j]
          break
        }
      }

      // If there was a node with the same ID or placeholder in the old list
      if (oldMatch) {
        morphed = walk(newChild, oldMatch)
        if (morphed !== oldMatch) offset++
        oldNode.insertBefore(morphed, oldChild)

      // It's safe to morph two nodes in-place if neither has an ID
      } else if (!newChild.id && !oldChild.id) {
        morphed = walk(newChild, oldChild)
        if (morphed !== oldChild) {
          oldNode.replaceChild(morphed, oldChild)
          offset++
        }

      // Insert the node at the index if we couldn't morph or find a matching node
      } else {
        oldNode.insertBefore(newChild, oldChild)
        offset++
      }
    }
  }
}

function same (a, b) {
  if (a.id) return a.id === b.id
  if (a.isSameNode) return a.isSameNode(b)
  if (a.tagName !== b.tagName) return false
  if (a.type === TEXT_NODE) return a.nodeValue === b.nodeValue
  return false
}

},{"./lib/morph":154,"nanoassert":142}],153:[function(require,module,exports){
module.exports = [
  // attribute events (can be set with attributes)
  'onclick',
  'ondblclick',
  'onmousedown',
  'onmouseup',
  'onmouseover',
  'onmousemove',
  'onmouseout',
  'onmouseenter',
  'onmouseleave',
  'ontouchcancel',
  'ontouchend',
  'ontouchmove',
  'ontouchstart',
  'ondragstart',
  'ondrag',
  'ondragenter',
  'ondragleave',
  'ondragover',
  'ondrop',
  'ondragend',
  'onkeydown',
  'onkeypress',
  'onkeyup',
  'onunload',
  'onabort',
  'onerror',
  'onresize',
  'onscroll',
  'onselect',
  'onchange',
  'onsubmit',
  'onreset',
  'onfocus',
  'onblur',
  'oninput',
  // other common events
  'oncontextmenu',
  'onfocusin',
  'onfocusout'
]

},{}],154:[function(require,module,exports){
var events = require('./events')
var eventsLength = events.length

var ELEMENT_NODE = 1
var TEXT_NODE = 3
var COMMENT_NODE = 8

module.exports = morph

// diff elements and apply the resulting patch to the old node
// (obj, obj) -> null
function morph (newNode, oldNode) {
  var nodeType = newNode.nodeType
  var nodeName = newNode.nodeName

  if (nodeType === ELEMENT_NODE) {
    copyAttrs(newNode, oldNode)
  }

  if (nodeType === TEXT_NODE || nodeType === COMMENT_NODE) {
    if (oldNode.nodeValue !== newNode.nodeValue) {
      oldNode.nodeValue = newNode.nodeValue
    }
  }

  // Some DOM nodes are weird
  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js
  if (nodeName === 'INPUT') updateInput(newNode, oldNode)
  else if (nodeName === 'OPTION') updateOption(newNode, oldNode)
  else if (nodeName === 'TEXTAREA') updateTextarea(newNode, oldNode)

  copyEvents(newNode, oldNode)
}

function copyAttrs (newNode, oldNode) {
  var oldAttrs = oldNode.attributes
  var newAttrs = newNode.attributes
  var attrNamespaceURI = null
  var attrValue = null
  var fromValue = null
  var attrName = null
  var attr = null

  for (var i = newAttrs.length - 1; i >= 0; --i) {
    attr = newAttrs[i]
    attrName = attr.name
    attrNamespaceURI = attr.namespaceURI
    attrValue = attr.value
    if (attrNamespaceURI) {
      attrName = attr.localName || attrName
      fromValue = oldNode.getAttributeNS(attrNamespaceURI, attrName)
      if (fromValue !== attrValue) {
        oldNode.setAttributeNS(attrNamespaceURI, attrName, attrValue)
      }
    } else {
      if (!oldNode.hasAttribute(attrName)) {
        oldNode.setAttribute(attrName, attrValue)
      } else {
        fromValue = oldNode.getAttribute(attrName)
        if (fromValue !== attrValue) {
          // apparently values are always cast to strings, ah well
          if (attrValue === 'null' || attrValue === 'undefined') {
            oldNode.removeAttribute(attrName)
          } else {
            oldNode.setAttribute(attrName, attrValue)
          }
        }
      }
    }
  }

  // Remove any extra attributes found on the original DOM element that
  // weren't found on the target element.
  for (var j = oldAttrs.length - 1; j >= 0; --j) {
    attr = oldAttrs[j]
    if (attr.specified !== false) {
      attrName = attr.name
      attrNamespaceURI = attr.namespaceURI

      if (attrNamespaceURI) {
        attrName = attr.localName || attrName
        if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          oldNode.removeAttributeNS(attrNamespaceURI, attrName)
        }
      } else {
        if (!newNode.hasAttributeNS(null, attrName)) {
          oldNode.removeAttribute(attrName)
        }
      }
    }
  }
}

function copyEvents (newNode, oldNode) {
  for (var i = 0; i < eventsLength; i++) {
    var ev = events[i]
    if (newNode[ev]) {           // if new element has a whitelisted attribute
      oldNode[ev] = newNode[ev]  // update existing element
    } else if (oldNode[ev]) {    // if existing element has it and new one doesnt
      oldNode[ev] = undefined    // remove it from existing element
    }
  }
}

function updateOption (newNode, oldNode) {
  updateAttribute(newNode, oldNode, 'selected')
}

// The "value" attribute is special for the <input> element since it sets the
// initial value. Changing the "value" attribute without changing the "value"
// property will have no effect since it is only used to the set the initial
// value. Similar for the "checked" attribute, and "disabled".
function updateInput (newNode, oldNode) {
  var newValue = newNode.value
  var oldValue = oldNode.value

  updateAttribute(newNode, oldNode, 'checked')
  updateAttribute(newNode, oldNode, 'disabled')

  // The "indeterminate" property can not be set using an HTML attribute.
  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox
  if (newNode.indeterminate !== oldNode.indeterminate) {
    oldNode.indeterminate = newNode.indeterminate
  }

  // Persist file value since file inputs can't be changed programatically
  if (oldNode.type === 'file') return

  if (newValue !== oldValue) {
    oldNode.setAttribute('value', newValue)
    oldNode.value = newValue
  }

  if (newValue === 'null') {
    oldNode.value = ''
    oldNode.removeAttribute('value')
  }

  if (!newNode.hasAttributeNS(null, 'value')) {
    oldNode.removeAttribute('value')
  } else if (oldNode.type === 'range') {
    // this is so elements like slider move their UI thingy
    oldNode.value = newValue
  }
}

function updateTextarea (newNode, oldNode) {
  var newValue = newNode.value
  if (newValue !== oldNode.value) {
    oldNode.value = newValue
  }

  if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {
    // Needed for IE. Apparently IE sets the placeholder as the
    // node value and vise versa. This ignores an empty update.
    if (newValue === '' && oldNode.firstChild.nodeValue === oldNode.placeholder) {
      return
    }

    oldNode.firstChild.nodeValue = newValue
  }
}

function updateAttribute (newNode, oldNode, name) {
  if (newNode[name] !== oldNode[name]) {
    oldNode[name] = newNode[name]
    if (newNode[name]) {
      oldNode.setAttribute(name, '')
    } else {
      oldNode.removeAttribute(name)
    }
  }
}

},{"./events":153}],155:[function(require,module,exports){
var reg = /([^?=&]+)(=([^&]*))?/g
var assert = require('assert')

module.exports = qs

function qs (url) {
  assert.equal(typeof url, 'string', 'nanoquery: url should be type string')

  var obj = {}
  url.replace(/^.*\?/, '').replace(reg, function (a0, a1, a2, a3) {
    var value = decodeURIComponent(a3)
    var key = decodeURIComponent(a1)
    if (obj.hasOwnProperty(key)) {
      if (Array.isArray(obj[key])) obj[key].push(value)
      else obj[key] = [obj[key], value]
    } else {
      obj[key] = value
    }
  })

  return obj
}

},{"assert":142}],156:[function(require,module,exports){
'use strict'

var assert = require('assert')

module.exports = nanoraf

// Only call RAF when needed
// (fn, fn?) -> fn
function nanoraf (render, raf) {
  assert.equal(typeof render, 'function', 'nanoraf: render should be a function')
  assert.ok(typeof raf === 'function' || typeof raf === 'undefined', 'nanoraf: raf should be a function or undefined')

  if (!raf) raf = window.requestAnimationFrame
  var redrawScheduled = false
  var args = null

  return function frame () {
    if (args === null && !redrawScheduled) {
      redrawScheduled = true

      raf(function redraw () {
        redrawScheduled = false

        var length = args.length
        var _args = new Array(length)
        for (var i = 0; i < length; i++) _args[i] = args[i]

        render.apply(render, _args)
        args = null
      })
    }

    args = arguments
  }
}

},{"assert":142}],157:[function(require,module,exports){
var assert = require('assert')
var wayfarer = require('wayfarer')

// electron support
var isLocalFile = (/file:\/\//.test(
  typeof window === 'object' &&
  window.location &&
  window.location.origin
))

/* eslint-disable no-useless-escape */
var electron = '^(file:\/\/|\/)(.*\.html?\/?)?'
var protocol = '^(http(s)?(:\/\/))?(www\.)?'
var domain = '[a-zA-Z0-9-_\.]+(:[0-9]{1,5})?(\/{1})?'
var qs = '[\?].*$'
/* eslint-enable no-useless-escape */

var stripElectron = new RegExp(electron)
var prefix = new RegExp(protocol + domain)
var normalize = new RegExp('#')
var suffix = new RegExp(qs)

module.exports = Nanorouter

function Nanorouter (opts) {
  if (!(this instanceof Nanorouter)) return new Nanorouter(opts)
  opts = opts || {}
  this.router = wayfarer(opts.default || '/404')
}

Nanorouter.prototype.on = function (routename, listener) {
  assert.equal(typeof routename, 'string')
  routename = routename.replace(/^[#/]/, '')
  this.router.on(routename, listener)
}

Nanorouter.prototype.emit = function (routename) {
  assert.equal(typeof routename, 'string')
  routename = pathname(routename, isLocalFile)
  return this.router.emit(routename)
}

Nanorouter.prototype.match = function (routename) {
  assert.equal(typeof routename, 'string')
  routename = pathname(routename, isLocalFile)
  return this.router.match(routename)
}

// replace everything in a route but the pathname and hash
function pathname (routename, isElectron) {
  if (isElectron) routename = routename.replace(stripElectron, '')
  else routename = routename.replace(prefix, '')
  return decodeURI(routename.replace(suffix, '').replace(normalize, '/'))
}

},{"assert":142,"wayfarer":167}],158:[function(require,module,exports){
var assert = require('assert')

var hasWindow = typeof window !== 'undefined'

function createScheduler () {
  var scheduler
  if (hasWindow) {
    if (!window._nanoScheduler) window._nanoScheduler = new NanoScheduler(true)
    scheduler = window._nanoScheduler
  } else {
    scheduler = new NanoScheduler()
  }
  return scheduler
}

function NanoScheduler (hasWindow) {
  this.hasWindow = hasWindow
  this.hasIdle = this.hasWindow && window.requestIdleCallback
  this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout
  this.scheduled = false
  this.queue = []
}

NanoScheduler.prototype.push = function (cb) {
  assert.equal(typeof cb, 'function', 'nanoscheduler.push: cb should be type function')

  this.queue.push(cb)
  this.schedule()
}

NanoScheduler.prototype.schedule = function () {
  if (this.scheduled) return

  this.scheduled = true
  var self = this
  this.method(function (idleDeadline) {
    var cb
    while (self.queue.length && idleDeadline.timeRemaining() > 0) {
      cb = self.queue.shift()
      cb(idleDeadline)
    }
    self.scheduled = false
    if (self.queue.length) self.schedule()
  })
}

NanoScheduler.prototype.setTimeout = function (cb) {
  setTimeout(cb, 0, {
    timeRemaining: function () {
      return 1
    }
  })
}

module.exports = createScheduler

},{"assert":142}],159:[function(require,module,exports){
var scheduler = require('nanoscheduler')()
var assert = require('assert')

var perf
nanotiming.disabled = true
try {
  perf = window.performance
  nanotiming.disabled = window.localStorage.DISABLE_NANOTIMING === 'true' || !perf.mark
} catch (e) { }

module.exports = nanotiming

function nanotiming (name) {
  assert.equal(typeof name, 'string', 'nanotiming: name should be type string')

  if (nanotiming.disabled) return noop

  var uuid = (perf.now() * 10000).toFixed() % Number.MAX_SAFE_INTEGER
  var startName = 'start-' + uuid + '-' + name
  perf.mark(startName)

  function end (cb) {
    var endName = 'end-' + uuid + '-' + name
    perf.mark(endName)

    scheduler.push(function () {
      var err = null
      try {
        var measureName = name + ' [' + uuid + ']'
        perf.measure(measureName, startName, endName)
        perf.clearMarks(startName)
        perf.clearMarks(endName)
      } catch (e) { err = e }
      if (cb) cb(err, name)
    })
  }

  end.uuid = uuid
  return end
}

function noop (cb) {
  if (cb) {
    scheduler.push(function () {
      cb(new Error('nanotiming: performance API unavailable'))
    })
  }
}

},{"assert":142,"nanoscheduler":158}],160:[function(require,module,exports){
module.exports = function parseUnit(str, out) {
    if (!out)
        out = [ 0, '' ]

    str = String(str)
    var num = parseFloat(str, 10)
    out[0] = num
    out[1] = str.match(/[\d.\-\+]*\s*(.*)/)[1] || ''
    return out
}
},{}],161:[function(require,module,exports){
function createCylinderMesh(
  radiusTop,
  radiusBottom,
  height,
  radialSegments,
  heightSegments
) {
  var index = 0
  var indexOffset = 0
  var indexArray = []

  radiusTop = typeof radiusTop !== 'undefined' ? radiusTop : 1
  radiusBottom = typeof radiusBottom !== 'undefined' ? radiusBottom : 1
  height = typeof height !== 'undefined' ? height : 5
  radialSegments = typeof radialSegments !== 'undefined' ? radialSegments : 64
  heightSegments = typeof heightSegments !== 'undefined' ? heightSegments : 8

  var capCount = 0
  if (radiusTop > 0) {
    capCount++
  }
  if (radiusBottom > 0) {
    capCount++
  }

  var vertexCount = ((radialSegments + 1) * (heightSegments + 1)) +
    ((radialSegments + 2) * capCount)
  var cellCount = (radialSegments * heightSegments * 2) + (radialSegments * capCount)

  var normals = new Array(vertexCount)
  var vertices = new Array(vertexCount)
  var uvs = new Array(vertexCount)
  var cells = new Array(cellCount)

  var slope = (radiusBottom - radiusTop) / height
  var thetaLength = 2.0 * Math.PI

  for (var y = 0; y <= heightSegments; y++) {
    var indexRow = []
    var v = y / heightSegments
    var radius = v * (radiusBottom - radiusTop) + radiusTop

    for (var x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments
      var theta = u * thetaLength
      var sinTheta = Math.sin(theta)
      var cosTheta = Math.cos(theta)
      vertices[index] = [radius * sinTheta, -v * height + (height / 2), radius * cosTheta]
      normals[index] = [sinTheta, slope, cosTheta]
      uvs[index] = [u, 1 - v]

      indexRow.push(index)
      index++
    }

    indexArray.push(indexRow)
  }

  for (var x = 0; x < radialSegments; x++) {
    for (var y = 0; y < heightSegments; y++) {
      var i1 = indexArray[y][x]
      var i2 = indexArray[y + 1][x]
      var i3 = indexArray[y + 1][x + 1]
      var i4 = indexArray[y][x + 1]

      // face one
      cells[indexOffset] = [i1, i2, i4]
      indexOffset++

      // face two
      cells[indexOffset] = [i2, i3, i4]
      indexOffset++
    }
  }

  var generateCap = function (top) {
    var vertex = new Array(3).fill(0)

    var radius = (top === true) ? radiusTop : radiusBottom
    var sign = (top === true) ? 1 : -1

    var centerIndexStart = index

    for (var x = 1; x <= radialSegments; x++) {
      vertices[index] = [0, height * sign / 2, 0]
      normals[index] = [0, sign, 0]
      uvs[index] = [0.5, 0.5]
      index++
    }

    var centerIndexEnd = index

    for (var x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments
      var theta = u * thetaLength
      var cosTheta = Math.cos(theta)
      var sinTheta = Math.sin(theta)
      vertices[index] = [radius * sinTheta, height * sign / 2, radius * cosTheta]
      normals[index] = [0, sign, 0]
      uvs[index] = [(cosTheta * 0.5) + 0.5, (sinTheta * 0.5 * sign) + 0.5]
      index++
    }

    for (var x = 0; x < radialSegments; x++) {
      var c = centerIndexStart + x
      var i = centerIndexEnd + x

      if ( top === true ) {
        // face top
        cells[indexOffset] = [i, i + 1, c]
        indexOffset++
      } else {
        // face bottom
        cells[indexOffset] = [i + 1, i, c]
        indexOffset++
      }
    }
  }

  if (radiusTop > 0) {
    generateCap(true)
  }

  if (radiusBottom > 0) {
    generateCap(false)
  }

  return {
    uvs: uvs,
    cells: cells,
    normals: normals,
    positions: vertices
  }
}

module.exports = createCylinderMesh

},{}],162:[function(require,module,exports){
(function(Z,ia){"object"===typeof exports&&"undefined"!==typeof module?module.exports=ia():"function"===typeof define&&define.amd?define(ia):Z.createREGL=ia()})(this,function(){function Z(a,b){this.id=Db++;this.type=a;this.data=b}function ia(a){if(0===a.length)return[];var b=a.charAt(0),c=a.charAt(a.length-1);if(1<a.length&&b===c&&('"'===b||"'"===b))return['"'+a.substr(1,a.length-2).replace(/\\/g,"\\\\").replace(/"/g,'\\"')+'"'];if(b=/\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(a))return ia(a.substr(0,
b.index)).concat(ia(b[1])).concat(ia(a.substr(b.index+b[0].length)));b=a.split(".");if(1===b.length)return['"'+a.replace(/\\/g,"\\\\").replace(/"/g,'\\"')+'"'];a=[];for(c=0;c<b.length;++c)a=a.concat(ia(b[c]));return a}function cb(a){return"["+ia(a).join("][")+"]"}function db(a,b){if("function"===typeof a)return new Z(0,a);if("number"===typeof a||"boolean"===typeof a)return new Z(5,a);if(Array.isArray(a))return new Z(6,a.map(function(a,e){return db(a,b+"["+e+"]")}));if(a instanceof Z)return a}function Eb(){var a=
{"":0},b=[""];return{id:function(c){var e=a[c];if(e)return e;e=a[c]=b.length;b.push(c);return e},str:function(a){return b[a]}}}function Fb(a,b,c){function e(){var b=window.innerWidth,e=window.innerHeight;a!==document.body&&(e=a.getBoundingClientRect(),b=e.right-e.left,e=e.bottom-e.top);f.width=c*b;f.height=c*e;K(f.style,{width:b+"px",height:e+"px"})}var f=document.createElement("canvas");K(f.style,{border:0,margin:0,padding:0,top:0,left:0});a.appendChild(f);a===document.body&&(f.style.position="absolute",
K(a.style,{margin:0,padding:0}));var d;a!==document.body&&"function"===typeof ResizeObserver?(d=new ResizeObserver(function(){setTimeout(e)}),d.observe(a)):window.addEventListener("resize",e,!1);e();return{canvas:f,onDestroy:function(){d?d.disconnect():window.removeEventListener("resize",e);a.removeChild(f)}}}function Gb(a,b){function c(c){try{return a.getContext(c,b)}catch(f){return null}}return c("webgl")||c("experimental-webgl")||c("webgl-experimental")}function eb(a){return"string"===typeof a?
a.split():a}function fb(a){return"string"===typeof a?document.querySelector(a):a}function Hb(a){var b=a||{},c,e,f,d;a={};var q=[],m=[],w="undefined"===typeof window?1:window.devicePixelRatio,h=!1,t=function(a){},l=function(){};"string"===typeof b?c=document.querySelector(b):"object"===typeof b&&("string"===typeof b.nodeName&&"function"===typeof b.appendChild&&"function"===typeof b.getBoundingClientRect?c=b:"function"===typeof b.drawArrays||"function"===typeof b.drawElements?(d=b,f=d.canvas):("gl"in
b?d=b.gl:"canvas"in b?f=fb(b.canvas):"container"in b&&(e=fb(b.container)),"attributes"in b&&(a=b.attributes),"extensions"in b&&(q=eb(b.extensions)),"optionalExtensions"in b&&(m=eb(b.optionalExtensions)),"onDone"in b&&(t=b.onDone),"profile"in b&&(h=!!b.profile),"pixelRatio"in b&&(w=+b.pixelRatio)));c&&("canvas"===c.nodeName.toLowerCase()?f=c:e=c);if(!d){if(!f){c=Fb(e||document.body,t,w);if(!c)return null;f=c.canvas;l=c.onDestroy}void 0===a.premultipliedAlpha&&(a.premultipliedAlpha=!0);d=Gb(f,a)}return d?
{gl:d,canvas:f,container:e,extensions:q,optionalExtensions:m,pixelRatio:w,profile:h,onDone:t,onDestroy:l}:(l(),t("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"),null)}function Ib(a,b){function c(b){b=b.toLowerCase();var c;try{c=e[b]=a.getExtension(b)}catch(f){}return!!c}for(var e={},f=0;f<b.extensions.length;++f){var d=b.extensions[f];if(!c(d))return b.onDestroy(),b.onDone('"'+d+'" extension is not supported by the current WebGL context, try upgrading your system or a different browser'),
null}b.optionalExtensions.forEach(c);return{extensions:e,restore:function(){Object.keys(e).forEach(function(a){if(e[a]&&!c(a))throw Error("(regl): error restoring extension "+a);})}}}function S(a,b){for(var c=Array(a),e=0;e<a;++e)c[e]=b(e);return c}function gb(a){var b,c;b=(65535<a)<<4;a>>>=b;c=(255<a)<<3;a>>>=c;b|=c;c=(15<a)<<2;a>>>=c;b|=c;c=(3<a)<<1;return b|c|a>>>c>>1}function hb(){function a(a){a:{for(var b=16;268435456>=b;b*=16)if(a<=b){a=b;break a}a=0}b=c[gb(a)>>2];return 0<b.length?b.pop():
new ArrayBuffer(a)}function b(a){c[gb(a.byteLength)>>2].push(a)}var c=S(8,function(){return[]});return{alloc:a,free:b,allocType:function(b,c){var d=null;switch(b){case 5120:d=new Int8Array(a(c),0,c);break;case 5121:d=new Uint8Array(a(c),0,c);break;case 5122:d=new Int16Array(a(2*c),0,c);break;case 5123:d=new Uint16Array(a(2*c),0,c);break;case 5124:d=new Int32Array(a(4*c),0,c);break;case 5125:d=new Uint32Array(a(4*c),0,c);break;case 5126:d=new Float32Array(a(4*c),0,c);break;default:return null}return d.length!==
c?d.subarray(0,c):d},freeType:function(a){b(a.buffer)}}}function ja(a){return!!a&&"object"===typeof a&&Array.isArray(a.shape)&&Array.isArray(a.stride)&&"number"===typeof a.offset&&a.shape.length===a.stride.length&&(Array.isArray(a.data)||Q(a.data))}function ib(a,b,c,e,f,d){for(var q=0;q<b;++q)for(var m=a[q],w=0;w<c;++w)for(var h=m[w],t=0;t<e;++t)f[d++]=h[t]}function jb(a,b,c,e,f){for(var d=1,q=c+1;q<b.length;++q)d*=b[q];var m=b[c];if(4===b.length-c){var w=b[c+1],h=b[c+2];b=b[c+3];for(q=0;q<m;++q)ib(a[q],
w,h,b,e,f),f+=d}else for(q=0;q<m;++q)jb(a[q],b,c+1,e,f),f+=d}function Ga(a){return Ha[Object.prototype.toString.call(a)]|0}function kb(a,b){for(var c=0;c<b.length;++c)a[c]=b[c]}function lb(a,b,c,e,f,d,q){for(var m=0,w=0;w<c;++w)for(var h=0;h<e;++h)a[m++]=b[f*w+d*h+q]}function Jb(a,b,c,e){function f(b){this.id=w++;this.buffer=a.createBuffer();this.type=b;this.usage=35044;this.byteLength=0;this.dimension=1;this.dtype=5121;this.persistentData=null;c.profile&&(this.stats={size:0})}function d(b,c,n){b.byteLength=
c.byteLength;a.bufferData(b.type,c,n)}function q(a,b,c,g,k,v){a.usage=c;if(Array.isArray(b)){if(a.dtype=g||5126,0<b.length)if(Array.isArray(b[0])){k=mb(b);for(var p=g=1;p<k.length;++p)g*=k[p];a.dimension=g;b=Ua(b,k,a.dtype);d(a,b,c);v?a.persistentData=b:G.freeType(b)}else"number"===typeof b[0]?(a.dimension=k,k=G.allocType(a.dtype,b.length),kb(k,b),d(a,k,c),v?a.persistentData=k:G.freeType(k)):Q(b[0])&&(a.dimension=b[0].length,a.dtype=g||Ga(b[0])||5126,b=Ua(b,[b.length,b[0].length],a.dtype),d(a,b,c),
v?a.persistentData=b:G.freeType(b))}else if(Q(b))a.dtype=g||Ga(b),a.dimension=k,d(a,b,c),v&&(a.persistentData=new Uint8Array(new Uint8Array(b.buffer)));else if(ja(b)){k=b.shape;var e=b.stride,p=b.offset,u=0,f=0,h=0,m=0;1===k.length?(u=k[0],f=1,h=e[0],m=0):2===k.length&&(u=k[0],f=k[1],h=e[0],m=e[1]);a.dtype=g||Ga(b.data)||5126;a.dimension=f;k=G.allocType(a.dtype,u*f);lb(k,b.data,u,f,h,m,p);d(a,k,c);v?a.persistentData=k:G.freeType(k)}else b instanceof ArrayBuffer&&(a.dtype=5121,a.dimension=k,d(a,b,
c),v&&(a.persistentData=new Uint8Array(new Uint8Array(b))))}function m(c){b.bufferCount--;e(c);a.deleteBuffer(c.buffer);c.buffer=null;delete h[c.id]}var w=0,h={};f.prototype.bind=function(){a.bindBuffer(this.type,this.buffer)};f.prototype.destroy=function(){m(this)};var t=[];c.profile&&(b.getTotalBufferSize=function(){var a=0;Object.keys(h).forEach(function(b){a+=h[b].stats.size});return a});return{create:function(l,e,d,g){function k(b){var e=35044,u=null,d=0,l=0,f=1;Array.isArray(b)||Q(b)||ja(b)||
b instanceof ArrayBuffer?u=b:"number"===typeof b?d=b|0:b&&("data"in b&&(u=b.data),"usage"in b&&(e=nb[b.usage]),"type"in b&&(l=Ja[b.type]),"dimension"in b&&(f=b.dimension|0),"length"in b&&(d=b.length|0));v.bind();u?q(v,u,e,l,f,g):(d&&a.bufferData(v.type,d,e),v.dtype=l||5121,v.usage=e,v.dimension=f,v.byteLength=d);c.profile&&(v.stats.size=v.byteLength*ma[v.dtype]);return k}b.bufferCount++;var v=new f(e);h[v.id]=v;d||k(l);k._reglType="buffer";k._buffer=v;k.subdata=function(b,c){var u=(c||0)|0,e;v.bind();
if(Q(b)||b instanceof ArrayBuffer)a.bufferSubData(v.type,u,b);else if(Array.isArray(b)){if(0<b.length)if("number"===typeof b[0]){var d=G.allocType(v.dtype,b.length);kb(d,b);a.bufferSubData(v.type,u,d);G.freeType(d)}else if(Array.isArray(b[0])||Q(b[0]))e=mb(b),d=Ua(b,e,v.dtype),a.bufferSubData(v.type,u,d),G.freeType(d)}else if(ja(b)){e=b.shape;var l=b.stride,f=d=0,g=0,r=0;1===e.length?(d=e[0],f=1,g=l[0],r=0):2===e.length&&(d=e[0],f=e[1],g=l[0],r=l[1]);e=Array.isArray(b.data)?v.dtype:Ga(b.data);e=G.allocType(e,
d*f);lb(e,b.data,d,f,g,r,b.offset);a.bufferSubData(v.type,u,e);G.freeType(e)}return k};c.profile&&(k.stats=v.stats);k.destroy=function(){m(v)};return k},createStream:function(a,b){var c=t.pop();c||(c=new f(a));c.bind();q(c,b,35040,0,1,!1);return c},destroyStream:function(a){t.push(a)},clear:function(){I(h).forEach(m);t.forEach(m)},getBuffer:function(a){return a&&a._buffer instanceof f?a._buffer:null},restore:function(){I(h).forEach(function(b){b.buffer=a.createBuffer();a.bindBuffer(b.type,b.buffer);
a.bufferData(b.type,b.persistentData||b.byteLength,b.usage)})},_initBuffer:q}}function Kb(a,b,c,e){function f(a){this.id=w++;m[this.id]=this;this.buffer=a;this.primType=4;this.type=this.vertCount=0}function d(e,d,f,g,k,v,p){e.buffer.bind();var h;d?((h=p)||Q(d)&&(!ja(d)||Q(d.data))||(h=b.oes_element_index_uint?5125:5123),c._initBuffer(e.buffer,d,f,h,3)):(a.bufferData(34963,v,f),e.buffer.dtype=h||5121,e.buffer.usage=f,e.buffer.dimension=3,e.buffer.byteLength=v);h=p;if(!p){switch(e.buffer.dtype){case 5121:case 5120:h=
5121;break;case 5123:case 5122:h=5123;break;case 5125:case 5124:h=5125}e.buffer.dtype=h}e.type=h;d=k;0>d&&(d=e.buffer.byteLength,5123===h?d>>=1:5125===h&&(d>>=2));e.vertCount=d;d=g;0>g&&(d=4,g=e.buffer.dimension,1===g&&(d=0),2===g&&(d=1),3===g&&(d=4));e.primType=d}function q(a){e.elementsCount--;delete m[a.id];a.buffer.destroy();a.buffer=null}var m={},w=0,h={uint8:5121,uint16:5123};b.oes_element_index_uint&&(h.uint32=5125);f.prototype.bind=function(){this.buffer.bind()};var t=[];return{create:function(a,
b){function n(a){if(a)if("number"===typeof a)g(a),k.primType=4,k.vertCount=a|0,k.type=5121;else{var b=null,c=35044,e=-1,f=-1,m=0,l=0;if(Array.isArray(a)||Q(a)||ja(a))b=a;else if("data"in a&&(b=a.data),"usage"in a&&(c=nb[a.usage]),"primitive"in a&&(e=Ka[a.primitive]),"count"in a&&(f=a.count|0),"type"in a&&(l=h[a.type]),"length"in a)m=a.length|0;else if(m=f,5123===l||5122===l)m*=2;else if(5125===l||5124===l)m*=4;d(k,b,c,e,f,m,l)}else g(),k.primType=4,k.vertCount=0,k.type=5121;return n}var g=c.create(null,
34963,!0),k=new f(g._buffer);e.elementsCount++;n(a);n._reglType="elements";n._elements=k;n.subdata=function(a,b){g.subdata(a,b);return n};n.destroy=function(){q(k)};return n},createStream:function(a){var b=t.pop();b||(b=new f(c.create(null,34963,!0,!1)._buffer));d(b,a,35040,-1,-1,0,0);return b},destroyStream:function(a){t.push(a)},getElements:function(a){return"function"===typeof a&&a._elements instanceof f?a._elements:null},clear:function(){I(m).forEach(q)}}}function ob(a){for(var b=G.allocType(5123,
a.length),c=0;c<a.length;++c)if(isNaN(a[c]))b[c]=65535;else if(Infinity===a[c])b[c]=31744;else if(-Infinity===a[c])b[c]=64512;else{pb[0]=a[c];var e=Lb[0],f=e>>>31<<15,d=(e<<1>>>24)-127,e=e>>13&1023;b[c]=-24>d?f:-14>d?f+(e+1024>>-14-d):15<d?f+31744:f+(d+15<<10)+e}return b}function qa(a){return Array.isArray(a)||Q(a)}function ra(a){return"[object "+a+"]"}function qb(a){return Array.isArray(a)&&(0===a.length||"number"===typeof a[0])}function rb(a){return Array.isArray(a)&&0!==a.length&&qa(a[0])?!0:!1}
function aa(a){return Object.prototype.toString.call(a)}function Va(a){if(!a)return!1;var b=aa(a);return 0<=Mb.indexOf(b)?!0:qb(a)||rb(a)||ja(a)}function sb(a,b){36193===a.type?(a.data=ob(b),G.freeType(b)):a.data=b}function La(a,b,c,e,f,d){a="undefined"!==typeof C[a]?C[a]:V[a]*ya[b];d&&(a*=6);if(f){for(e=0;1<=c;)e+=a*c*c,c/=2;return e}return a*c*e}function Nb(a,b,c,e,f,d,q){function m(){this.format=this.internalformat=6408;this.type=5121;this.flipY=this.premultiplyAlpha=this.compressed=!1;this.unpackAlignment=
1;this.colorSpace=37444;this.channels=this.height=this.width=0}function w(a,b){a.internalformat=b.internalformat;a.format=b.format;a.type=b.type;a.compressed=b.compressed;a.premultiplyAlpha=b.premultiplyAlpha;a.flipY=b.flipY;a.unpackAlignment=b.unpackAlignment;a.colorSpace=b.colorSpace;a.width=b.width;a.height=b.height;a.channels=b.channels}function h(a,b){if("object"===typeof b&&b){"premultiplyAlpha"in b&&(a.premultiplyAlpha=b.premultiplyAlpha);"flipY"in b&&(a.flipY=b.flipY);"alignment"in b&&(a.unpackAlignment=
b.alignment);"colorSpace"in b&&(a.colorSpace=Ob[b.colorSpace]);"type"in b&&(a.type=N[b.type]);var c=a.width,e=a.height,d=a.channels,f=!1;"shape"in b?(c=b.shape[0],e=b.shape[1],3===b.shape.length&&(d=b.shape[2],f=!0)):("radius"in b&&(c=e=b.radius),"width"in b&&(c=b.width),"height"in b&&(e=b.height),"channels"in b&&(d=b.channels,f=!0));a.width=c|0;a.height=e|0;a.channels=d|0;c=!1;"format"in b&&(c=b.format,e=a.internalformat=E[c],a.format=W[e],c in N&&!("type"in b)&&(a.type=N[c]),c in ga&&(a.compressed=
!0),c=!0);!f&&c?a.channels=V[a.format]:f&&!c&&a.channels!==Oa[a.format]&&(a.format=a.internalformat=Oa[a.channels])}}function t(b){a.pixelStorei(37440,b.flipY);a.pixelStorei(37441,b.premultiplyAlpha);a.pixelStorei(37443,b.colorSpace);a.pixelStorei(3317,b.unpackAlignment)}function l(){m.call(this);this.yOffset=this.xOffset=0;this.data=null;this.needsFree=!1;this.element=null;this.needsCopy=!1}function D(a,b){var c=null;Va(b)?c=b:b&&(h(a,b),"x"in b&&(a.xOffset=b.x|0),"y"in b&&(a.yOffset=b.y|0),Va(b.data)&&
(c=b.data));if(b.copy){var e=f.viewportWidth,d=f.viewportHeight;a.width=a.width||e-a.xOffset;a.height=a.height||d-a.yOffset;a.needsCopy=!0}else if(!c)a.width=a.width||1,a.height=a.height||1,a.channels=a.channels||4;else if(Q(c))a.channels=a.channels||4,a.data=c,"type"in b||5121!==a.type||(a.type=Ha[Object.prototype.toString.call(c)]|0);else if(qb(c)){a.channels=a.channels||4;e=c;d=e.length;switch(a.type){case 5121:case 5123:case 5125:case 5126:d=G.allocType(a.type,d);d.set(e);a.data=d;break;case 36193:a.data=
ob(e)}a.alignment=1;a.needsFree=!0}else if(ja(c)){e=c.data;Array.isArray(e)||5121!==a.type||(a.type=Ha[Object.prototype.toString.call(e)]|0);var d=c.shape,k=c.stride,r,u,g,p;3===d.length?(g=d[2],p=k[2]):p=g=1;r=d[0];u=d[1];d=k[0];k=k[1];a.alignment=1;a.width=r;a.height=u;a.channels=g;a.format=a.internalformat=Oa[g];a.needsFree=!0;r=p;c=c.offset;g=a.width;p=a.height;u=a.channels;for(var y=G.allocType(36193===a.type?5126:a.type,g*p*u),O=0,ka=0;ka<p;++ka)for(var na=0;na<g;++na)for(var Wa=0;Wa<u;++Wa)y[O++]=
e[d*na+k*ka+r*Wa+c];sb(a,y)}else if(aa(c)===Xa||aa(c)===Ya||aa(c)===ub)aa(c)===Xa||aa(c)===Ya?a.element=c:a.element=c.canvas,a.width=a.element.width,a.height=a.element.height,a.channels=4;else if(aa(c)===vb)a.element=c,a.width=c.width,a.height=c.height,a.channels=4;else if(aa(c)===wb)a.element=c,a.width=c.naturalWidth,a.height=c.naturalHeight,a.channels=4;else if(aa(c)===xb)a.element=c,a.width=c.videoWidth,a.height=c.videoHeight,a.channels=4;else if(rb(c)){e=a.width||c[0].length;d=a.height||c.length;
k=a.channels;k=qa(c[0][0])?k||c[0][0].length:k||1;r=Qa.shape(c);g=1;for(p=0;p<r.length;++p)g*=r[p];g=G.allocType(36193===a.type?5126:a.type,g);Qa.flatten(c,r,"",g);sb(a,g);a.alignment=1;a.width=e;a.height=d;a.channels=k;a.format=a.internalformat=Oa[k];a.needsFree=!0}}function n(b,c,d,k,f){var g=b.element,r=b.data,p=b.internalformat,u=b.format,h=b.type,y=b.width,O=b.height;t(b);g?a.texSubImage2D(c,f,d,k,u,h,g):b.compressed?a.compressedTexSubImage2D(c,f,d,k,p,y,O,r):b.needsCopy?(e(),a.copyTexSubImage2D(c,
f,d,k,b.xOffset,b.yOffset,y,O)):a.texSubImage2D(c,f,d,k,y,O,u,h,r)}function g(){return S.pop()||new l}function k(a){a.needsFree&&G.freeType(a.data);l.call(a);S.push(a)}function v(){m.call(this);this.genMipmaps=!1;this.mipmapHint=4352;this.mipmask=0;this.images=Array(16)}function p(a,b,c){var d=a.images[0]=g();a.mipmask=1;d.width=a.width=b;d.height=a.height=c;d.channels=a.channels=4}function B(a,b){var c=null;if(Va(b))c=a.images[0]=g(),w(c,a),D(c,b),a.mipmask=1;else if(h(a,b),Array.isArray(b.mipmap))for(var d=
b.mipmap,e=0;e<d.length;++e)c=a.images[e]=g(),w(c,a),c.width>>=e,c.height>>=e,D(c,d[e]),a.mipmask|=1<<e;else c=a.images[0]=g(),w(c,a),D(c,b),a.mipmask=1;w(a,a.images[0])}function u(b,c){for(var d=b.images,k=0;k<d.length&&d[k];++k){var f=d[k],g=c,r=k,p=f.element,u=f.data,h=f.internalformat,y=f.format,O=f.type,ka=f.width,na=f.height;t(f);p?a.texImage2D(g,r,y,y,O,p):f.compressed?a.compressedTexImage2D(g,r,h,ka,na,0,u):f.needsCopy?(e(),a.copyTexImage2D(g,r,y,f.xOffset,f.yOffset,ka,na,0)):a.texImage2D(g,
r,y,ka,na,0,y,O,u||null)}}function Ia(){var a=Y.pop()||new v;m.call(a);for(var b=a.mipmask=0;16>b;++b)a.images[b]=null;return a}function xa(a){for(var b=a.images,c=0;c<b.length;++c)b[c]&&k(b[c]),b[c]=null;Y.push(a)}function x(){this.magFilter=this.minFilter=9728;this.wrapT=this.wrapS=33071;this.anisotropic=1;this.genMipmaps=!1;this.mipmapHint=4352}function H(a,b){"min"in b&&(a.minFilter=za[b.min],0<=Pb.indexOf(a.minFilter)&&!("faces"in b)&&(a.genMipmaps=!0));"mag"in b&&(a.magFilter=T[b.mag]);var c=
a.wrapS,d=a.wrapT;if("wrap"in b){var e=b.wrap;"string"===typeof e?c=d=ha[e]:Array.isArray(e)&&(c=ha[e[0]],d=ha[e[1]])}else"wrapS"in b&&(c=ha[b.wrapS]),"wrapT"in b&&(d=ha[b.wrapT]);a.wrapS=c;a.wrapT=d;"anisotropic"in b&&(a.anisotropic=b.anisotropic);if("mipmap"in b){c=!1;switch(typeof b.mipmap){case "string":a.mipmapHint=A[b.mipmap];c=a.genMipmaps=!0;break;case "boolean":c=a.genMipmaps=b.mipmap;break;case "object":a.genMipmaps=!1,c=!0}!c||"min"in b||(a.minFilter=9984)}}function M(c,d){a.texParameteri(d,
10241,c.minFilter);a.texParameteri(d,10240,c.magFilter);a.texParameteri(d,10242,c.wrapS);a.texParameteri(d,10243,c.wrapT);b.ext_texture_filter_anisotropic&&a.texParameteri(d,34046,c.anisotropic);c.genMipmaps&&(a.hint(33170,c.mipmapHint),a.generateMipmap(d))}function r(b){m.call(this);this.mipmask=0;this.internalformat=6408;this.id=Qb++;this.refCount=1;this.target=b;this.texture=a.createTexture();this.unit=-1;this.bindCount=0;this.texInfo=new x;q.profile&&(this.stats={size:0})}function U(b){a.activeTexture(33984);
a.bindTexture(b.target,b.texture)}function va(){var b=X[0];b?a.bindTexture(b.target,b.texture):a.bindTexture(3553,null)}function F(b){var c=b.texture,e=b.unit,f=b.target;0<=e&&(a.activeTexture(33984+e),a.bindTexture(f,null),X[e]=null);a.deleteTexture(c);b.texture=null;b.params=null;b.pixels=null;b.refCount=0;delete ea[b.id];d.textureCount--}var A={"don't care":4352,"dont care":4352,nice:4354,fast:4353},ha={repeat:10497,clamp:33071,mirror:33648},T={nearest:9728,linear:9729},za=K({mipmap:9987,"nearest mipmap nearest":9984,
"linear mipmap nearest":9985,"nearest mipmap linear":9986,"linear mipmap linear":9987},T),Ob={none:0,browser:37444},N={uint8:5121,rgba4:32819,rgb565:33635,"rgb5 a1":32820},E={alpha:6406,luminance:6409,"luminance alpha":6410,rgb:6407,rgba:6408,rgba4:32854,"rgb5 a1":32855,rgb565:36194},ga={};b.ext_srgb&&(E.srgb=35904,E.srgba=35906);b.oes_texture_float&&(N.float32=N["float"]=5126);b.oes_texture_half_float&&(N.float16=N["half float"]=36193);b.webgl_depth_texture&&(K(E,{depth:6402,"depth stencil":34041}),
K(N,{uint16:5123,uint32:5125,"depth stencil":34042}));b.webgl_compressed_texture_s3tc&&K(ga,{"rgb s3tc dxt1":33776,"rgba s3tc dxt1":33777,"rgba s3tc dxt3":33778,"rgba s3tc dxt5":33779});b.webgl_compressed_texture_atc&&K(ga,{"rgb atc":35986,"rgba atc explicit alpha":35987,"rgba atc interpolated alpha":34798});b.webgl_compressed_texture_pvrtc&&K(ga,{"rgb pvrtc 4bppv1":35840,"rgb pvrtc 2bppv1":35841,"rgba pvrtc 4bppv1":35842,"rgba pvrtc 2bppv1":35843});b.webgl_compressed_texture_etc1&&(ga["rgb etc1"]=
36196);var J=Array.prototype.slice.call(a.getParameter(34467));Object.keys(ga).forEach(function(a){var b=ga[a];0<=J.indexOf(b)&&(E[a]=b)});var C=Object.keys(E);c.textureFormats=C;var ca=[];Object.keys(E).forEach(function(a){ca[E[a]]=a});var L=[];Object.keys(N).forEach(function(a){L[N[a]]=a});var Ea=[];Object.keys(T).forEach(function(a){Ea[T[a]]=a});var oa=[];Object.keys(za).forEach(function(a){oa[za[a]]=a});var pa=[];Object.keys(ha).forEach(function(a){pa[ha[a]]=a});var W=C.reduce(function(a,c){var d=
E[c];6409===d||6406===d||6409===d||6410===d||6402===d||34041===d||b.ext_srgb&&(35904===d||35906===d)?a[d]=d:32855===d||0<=c.indexOf("rgba")?a[d]=6408:a[d]=6407;return a},{}),S=[],Y=[],Qb=0,ea={},fa=c.maxTextureUnits,X=Array(fa).map(function(){return null});K(r.prototype,{bind:function(){this.bindCount+=1;var b=this.unit;if(0>b){for(var c=0;c<fa;++c){var e=X[c];if(e){if(0<e.bindCount)continue;e.unit=-1}X[c]=this;b=c;break}q.profile&&d.maxTextureUnits<b+1&&(d.maxTextureUnits=b+1);this.unit=b;a.activeTexture(33984+
b);a.bindTexture(this.target,this.texture)}return b},unbind:function(){--this.bindCount},decRef:function(){0>=--this.refCount&&F(this)}});q.profile&&(d.getTotalTextureSize=function(){var a=0;Object.keys(ea).forEach(function(b){a+=ea[b].stats.size});return a});return{create2D:function(b,c){function e(a,b){var c=f.texInfo;x.call(c);var d=Ia();"number"===typeof a?"number"===typeof b?p(d,a|0,b|0):p(d,a|0,a|0):a?(H(c,a),B(d,a)):p(d,1,1);c.genMipmaps&&(d.mipmask=(d.width<<1)-1);f.mipmask=d.mipmask;w(f,
d);f.internalformat=d.internalformat;e.width=d.width;e.height=d.height;U(f);u(d,3553);M(c,3553);va();xa(d);q.profile&&(f.stats.size=La(f.internalformat,f.type,d.width,d.height,c.genMipmaps,!1));e.format=ca[f.internalformat];e.type=L[f.type];e.mag=Ea[c.magFilter];e.min=oa[c.minFilter];e.wrapS=pa[c.wrapS];e.wrapT=pa[c.wrapT];return e}var f=new r(3553);ea[f.id]=f;d.textureCount++;e(b,c);e.subimage=function(a,b,c,d){b|=0;c|=0;d|=0;var r=g();w(r,f);r.width=0;r.height=0;D(r,a);r.width=r.width||(f.width>>
d)-b;r.height=r.height||(f.height>>d)-c;U(f);n(r,3553,b,c,d);va();k(r);return e};e.resize=function(b,c){var d=b|0,r=c|0||d;if(d===f.width&&r===f.height)return e;e.width=f.width=d;e.height=f.height=r;U(f);for(var k=0;f.mipmask>>k;++k){var g=d>>k,y=r>>k;if(!g||!y)break;a.texImage2D(3553,k,f.format,g,y,0,f.format,f.type,null)}va();q.profile&&(f.stats.size=La(f.internalformat,f.type,d,r,!1,!1));return e};e._reglType="texture2d";e._texture=f;q.profile&&(e.stats=f.stats);e.destroy=function(){f.decRef()};
return e},createCube:function(b,c,e,f,m,v){function A(a,b,c,d,e,f){var r,da=l.texInfo;x.call(da);for(r=0;6>r;++r)F[r]=Ia();if("number"===typeof a||!a)for(a=a|0||1,r=0;6>r;++r)p(F[r],a,a);else if("object"===typeof a)if(b)B(F[0],a),B(F[1],b),B(F[2],c),B(F[3],d),B(F[4],e),B(F[5],f);else if(H(da,a),h(l,a),"faces"in a)for(a=a.faces,r=0;6>r;++r)w(F[r],l),B(F[r],a[r]);else for(r=0;6>r;++r)B(F[r],a);w(l,F[0]);l.mipmask=da.genMipmaps?(F[0].width<<1)-1:F[0].mipmask;l.internalformat=F[0].internalformat;A.width=
F[0].width;A.height=F[0].height;U(l);for(r=0;6>r;++r)u(F[r],34069+r);M(da,34067);va();q.profile&&(l.stats.size=La(l.internalformat,l.type,A.width,A.height,da.genMipmaps,!0));A.format=ca[l.internalformat];A.type=L[l.type];A.mag=Ea[da.magFilter];A.min=oa[da.minFilter];A.wrapS=pa[da.wrapS];A.wrapT=pa[da.wrapT];for(r=0;6>r;++r)xa(F[r]);return A}var l=new r(34067);ea[l.id]=l;d.cubeCount++;var F=Array(6);A(b,c,e,f,m,v);A.subimage=function(a,b,c,d,e){c|=0;d|=0;e|=0;var f=g();w(f,l);f.width=0;f.height=0;
D(f,b);f.width=f.width||(l.width>>e)-c;f.height=f.height||(l.height>>e)-d;U(l);n(f,34069+a,c,d,e);va();k(f);return A};A.resize=function(b){b|=0;if(b!==l.width){A.width=l.width=b;A.height=l.height=b;U(l);for(var c=0;6>c;++c)for(var d=0;l.mipmask>>d;++d)a.texImage2D(34069+c,d,l.format,b>>d,b>>d,0,l.format,l.type,null);va();q.profile&&(l.stats.size=La(l.internalformat,l.type,A.width,A.height,!1,!0));return A}};A._reglType="textureCube";A._texture=l;q.profile&&(A.stats=l.stats);A.destroy=function(){l.decRef()};
return A},clear:function(){for(var b=0;b<fa;++b)a.activeTexture(33984+b),a.bindTexture(3553,null),X[b]=null;I(ea).forEach(F);d.cubeCount=0;d.textureCount=0},getTexture:function(a){return null},restore:function(){for(var b=0;b<fa;++b){var c=X[b];c&&(c.bindCount=0,c.unit=-1,X[b]=null)}I(ea).forEach(function(b){b.texture=a.createTexture();a.bindTexture(b.target,b.texture);for(var c=0;32>c;++c)if(0!==(b.mipmask&1<<c))if(3553===b.target)a.texImage2D(3553,c,b.internalformat,b.width>>c,b.height>>c,0,b.internalformat,
b.type,null);else for(var d=0;6>d;++d)a.texImage2D(34069+d,c,b.internalformat,b.width>>c,b.height>>c,0,b.internalformat,b.type,null);M(b.texInfo,b.target)})},refresh:function(){for(var b=0;b<fa;++b){var c=X[b];c&&(c.bindCount=0,c.unit=-1,X[b]=null);a.activeTexture(33984+b);a.bindTexture(3553,null);a.bindTexture(34067,null)}}}}function Rb(a,b,c,e,f,d){function q(a,b,c){this.target=a;this.texture=b;this.renderbuffer=c;var d=a=0;b?(a=b.width,d=b.height):c&&(a=c.width,d=c.height);this.width=a;this.height=
d}function m(a){a&&(a.texture&&a.texture._texture.decRef(),a.renderbuffer&&a.renderbuffer._renderbuffer.decRef())}function w(a,b,c){a&&(a.texture?a.texture._texture.refCount+=1:a.renderbuffer._renderbuffer.refCount+=1)}function h(b,c){c&&(c.texture?a.framebufferTexture2D(36160,b,c.target,c.texture._texture.texture,0):a.framebufferRenderbuffer(36160,b,36161,c.renderbuffer._renderbuffer.renderbuffer))}function t(a){var b=3553,c=null,d=null,e=a;"object"===typeof a&&(e=a.data,"target"in a&&(b=a.target|
0));a=e._reglType;"texture2d"===a?c=e:"textureCube"===a?c=e:"renderbuffer"===a&&(d=e,b=36161);return new q(b,c,d)}function l(a,b,c,d,k){if(c)return a=e.create2D({width:a,height:b,format:d,type:k}),a._texture.refCount=0,new q(3553,a,null);a=f.create({width:a,height:b,format:d});a._renderbuffer.refCount=0;return new q(36161,null,a)}function D(a){return a&&(a.texture||a.renderbuffer)}function n(a,b,c){a&&(a.texture?a.texture.resize(b,c):a.renderbuffer&&a.renderbuffer.resize(b,c),a.width=b,a.height=c)}
function g(){this.id=H++;M[this.id]=this;this.framebuffer=a.createFramebuffer();this.height=this.width=0;this.colorAttachments=[];this.depthStencilAttachment=this.stencilAttachment=this.depthAttachment=null}function k(a){a.colorAttachments.forEach(m);m(a.depthAttachment);m(a.stencilAttachment);m(a.depthStencilAttachment)}function v(b){a.deleteFramebuffer(b.framebuffer);b.framebuffer=null;d.framebufferCount--;delete M[b.id]}function p(b){var d;a.bindFramebuffer(36160,b.framebuffer);var e=b.colorAttachments;
for(d=0;d<e.length;++d)h(36064+d,e[d]);for(d=e.length;d<c.maxColorAttachments;++d)a.framebufferTexture2D(36160,36064+d,3553,null,0);a.framebufferTexture2D(36160,33306,3553,null,0);a.framebufferTexture2D(36160,36096,3553,null,0);a.framebufferTexture2D(36160,36128,3553,null,0);h(36096,b.depthAttachment);h(36128,b.stencilAttachment);h(33306,b.depthStencilAttachment);a.checkFramebufferStatus(36160);a.isContextLost();a.bindFramebuffer(36160,u.next?u.next.framebuffer:null);u.cur=u.next;a.getError()}function B(a,
b){function c(a,b){var d,f=0,g=0,u=!0,r=!0;d=null;var h=!0,m="rgba",n="uint8",v=1,q=null,B=null,oa=null,M=!1;if("number"===typeof a)f=a|0,g=b|0||f;else if(a){"shape"in a?(g=a.shape,f=g[0],g=g[1]):("radius"in a&&(f=g=a.radius),"width"in a&&(f=a.width),"height"in a&&(g=a.height));if("color"in a||"colors"in a)d=a.color||a.colors,Array.isArray(d);if(!d){"colorCount"in a&&(v=a.colorCount|0);"colorTexture"in a&&(h=!!a.colorTexture,m="rgba4");if("colorType"in a&&(n=a.colorType,!h))if("half float"===n||"float16"===
n)m="rgba16f";else if("float"===n||"float32"===n)m="rgba32f";"colorFormat"in a&&(m=a.colorFormat,0<=Ia.indexOf(m)?h=!0:0<=xa.indexOf(m)&&(h=!1))}if("depthTexture"in a||"depthStencilTexture"in a)M=!(!a.depthTexture&&!a.depthStencilTexture);"depth"in a&&("boolean"===typeof a.depth?u=a.depth:(q=a.depth,r=!1));"stencil"in a&&("boolean"===typeof a.stencil?r=a.stencil:(B=a.stencil,u=!1));"depthStencil"in a&&("boolean"===typeof a.depthStencil?u=r=a.depthStencil:(oa=a.depthStencil,r=u=!1))}else f=g=1;var W=
null,H=null,U=null,x=null;if(Array.isArray(d))W=d.map(t);else if(d)W=[t(d)];else for(W=Array(v),d=0;d<v;++d)W[d]=l(f,g,h,m,n);f=f||W[0].width;g=g||W[0].height;q?H=t(q):u&&!r&&(H=l(f,g,M,"depth","uint32"));B?U=t(B):r&&!u&&(U=l(f,g,!1,"stencil","uint8"));oa?x=t(oa):!q&&!B&&r&&u&&(x=l(f,g,M,"depth stencil","depth stencil"));u=null;for(d=0;d<W.length;++d)w(W[d],f,g),W[d]&&W[d].texture&&(r=Za[W[d].texture._texture.format]*Ra[W[d].texture._texture.type],null===u&&(u=r));w(H,f,g);w(U,f,g);w(x,f,g);k(e);
e.width=f;e.height=g;e.colorAttachments=W;e.depthAttachment=H;e.stencilAttachment=U;e.depthStencilAttachment=x;c.color=W.map(D);c.depth=D(H);c.stencil=D(U);c.depthStencil=D(x);c.width=e.width;c.height=e.height;p(e);return c}var e=new g;d.framebufferCount++;c(a,b);return K(c,{resize:function(a,b){var d=Math.max(a|0,1),f=Math.max(b|0||d,1);if(d===e.width&&f===e.height)return c;for(var g=e.colorAttachments,k=0;k<g.length;++k)n(g[k],d,f);n(e.depthAttachment,d,f);n(e.stencilAttachment,d,f);n(e.depthStencilAttachment,
d,f);e.width=c.width=d;e.height=c.height=f;p(e);return c},_reglType:"framebuffer",_framebuffer:e,destroy:function(){v(e);k(e)},use:function(a){u.setFBO({framebuffer:c},a)}})}var u={cur:null,next:null,dirty:!1,setFBO:null},Ia=["rgba"],xa=["rgba4","rgb565","rgb5 a1"];b.ext_srgb&&xa.push("srgba");b.ext_color_buffer_half_float&&xa.push("rgba16f","rgb16f");b.webgl_color_buffer_float&&xa.push("rgba32f");var x=["uint8"];b.oes_texture_half_float&&x.push("half float","float16");b.oes_texture_float&&x.push("float",
"float32");var H=0,M={};return K(u,{getFramebuffer:function(a){return"function"===typeof a&&"framebuffer"===a._reglType&&(a=a._framebuffer,a instanceof g)?a:null},create:B,createCube:function(a){function b(a){var d,f={color:null},g=0,k=null;d="rgba";var u="uint8",p=1;if("number"===typeof a)g=a|0;else if(a){"shape"in a?g=a.shape[0]:("radius"in a&&(g=a.radius|0),"width"in a?g=a.width|0:"height"in a&&(g=a.height|0));if("color"in a||"colors"in a)k=a.color||a.colors,Array.isArray(k);k||("colorCount"in
a&&(p=a.colorCount|0),"colorType"in a&&(u=a.colorType),"colorFormat"in a&&(d=a.colorFormat));"depth"in a&&(f.depth=a.depth);"stencil"in a&&(f.stencil=a.stencil);"depthStencil"in a&&(f.depthStencil=a.depthStencil)}else g=1;if(k)if(Array.isArray(k))for(a=[],d=0;d<k.length;++d)a[d]=k[d];else a=[k];else for(a=Array(p),k={radius:g,format:d,type:u},d=0;d<p;++d)a[d]=e.createCube(k);f.color=Array(a.length);for(d=0;d<a.length;++d)p=a[d],g=g||p.width,f.color[d]={target:34069,data:a[d]};for(d=0;6>d;++d){for(p=
0;p<a.length;++p)f.color[p].target=34069+d;0<d&&(f.depth=c[0].depth,f.stencil=c[0].stencil,f.depthStencil=c[0].depthStencil);if(c[d])c[d](f);else c[d]=B(f)}return K(b,{width:g,height:g,color:a})}var c=Array(6);b(a);return K(b,{faces:c,resize:function(a){var d=a|0;if(d===b.width)return b;var e=b.color;for(a=0;a<e.length;++a)e[a].resize(d);for(a=0;6>a;++a)c[a].resize(d);b.width=b.height=d;return b},_reglType:"framebufferCube",destroy:function(){c.forEach(function(a){a.destroy()})}})},clear:function(){I(M).forEach(v)},
restore:function(){u.cur=null;u.next=null;u.dirty=!0;I(M).forEach(function(b){b.framebuffer=a.createFramebuffer();p(b)})}})}function $a(){this.w=this.z=this.y=this.x=this.state=0;this.buffer=null;this.size=0;this.normalized=!1;this.type=5126;this.divisor=this.stride=this.offset=0}function Sb(a,b,c,e,f,d,q){function m(a){if(a!==v.currentVAO){var c=b.oes_vertex_array_object;a?c.bindVertexArrayOES(a.vao):c.bindVertexArrayOES(null);v.currentVAO=a}}function w(c){if(c!==v.currentVAO){if(c)c.bindAttrs();
else{for(var d=b.angle_instanced_arrays,e=0;e<n.length;++e){var f=n[e];f.buffer?(a.enableVertexAttribArray(e),f.buffer.bind(),a.vertexAttribPointer(e,f.size,f.type,f.normalized,f.stride,f.offfset),d&&f.divisor&&d.vertexAttribDivisorANGLE(e,f.divisor)):(a.disableVertexAttribArray(e),a.vertexAttrib4f(e,f.x,f.y,f.z,f.w))}q.elements?a.bindBuffer(34963,q.elements.buffer.buffer):a.bindBuffer(34963,null)}v.currentVAO=c}}function h(){I(k).forEach(function(a){a.destroy()})}function t(){this.id=++g;this.attributes=
[];this.elements=null;this.ownsElements=!1;this.offset=this.count=0;this.instances=-1;this.primitive=4;var a=b.oes_vertex_array_object;this.vao=a?a.createVertexArrayOES():null;k[this.id]=this;this.buffers=[]}function l(){b.oes_vertex_array_object&&I(k).forEach(function(a){a.refresh()})}var D=c.maxAttributes,n=Array(D);for(c=0;c<D;++c)n[c]=new $a;var g=0,k={},v={Record:$a,scope:{},state:n,currentVAO:null,targetVAO:null,restore:b.oes_vertex_array_object?l:function(){},createVAO:function(a){function b(a){var e;
Array.isArray(a)?(e=a,c.elements&&c.ownsElements&&c.elements.destroy(),c.elements=null,c.ownsElements=!1,c.offset=0,c.count=0,c.instances=-1,c.primitive=4):(a.elements?(e=a.elements,c.ownsElements?("function"===typeof e&&"elements"===e._reglType?c.elements.destroy():c.elements(e),c.ownsElements=!1):d.getElements(a.elements)?(c.elements=a.elements,c.ownsElements=!1):(c.elements=d.create(a.elements),c.ownsElements=!0)):(c.elements=null,c.ownsElements=!1),e=a.attributes,c.offset=0,c.count=-1,c.instances=
-1,c.primitive=4,c.elements&&(c.count=c.elements._elements.vertCount,c.primitive=c.elements._elements.primType),"offset"in a&&(c.offset=a.offset|0),"count"in a&&(c.count=a.count|0),"instances"in a&&(c.instances=a.instances|0),"primitive"in a&&(c.primitive=Ka[a.primitive]));a={};var g=c.attributes;g.length=e.length;for(var k=0;k<e.length;++k){var p=e[k],h=g[k]=new $a,l=p.data||p;if(Array.isArray(l)||Q(l)||ja(l)){var m;c.buffers[k]&&(m=c.buffers[k],Q(l)&&m._buffer.byteLength>=l.byteLength?m.subdata(l):
(m.destroy(),c.buffers[k]=null));c.buffers[k]||(m=c.buffers[k]=f.create(p,34962,!1,!0));h.buffer=f.getBuffer(m);h.size=h.buffer.dimension|0;h.normalized=!1;h.type=h.buffer.dtype;h.offset=0;h.stride=0;h.divisor=0;h.state=1;a[k]=1}else f.getBuffer(p)?(h.buffer=f.getBuffer(p),h.size=h.buffer.dimension|0,h.normalized=!1,h.type=h.buffer.dtype,h.offset=0,h.stride=0,h.divisor=0,h.state=1):f.getBuffer(p.buffer)?(h.buffer=f.getBuffer(p.buffer),h.size=(+p.size||h.buffer.dimension)|0,h.normalized=!!p.normalized||
!1,h.type="type"in p?Ja[p.type]:h.buffer.dtype,h.offset=(p.offset||0)|0,h.stride=(p.stride||0)|0,h.divisor=(p.divisor||0)|0,h.state=1):"x"in p&&(h.x=+p.x||0,h.y=+p.y||0,h.z=+p.z||0,h.w=+p.w||0,h.state=2)}for(m=0;m<c.buffers.length;++m)!a[m]&&c.buffers[m]&&(c.buffers[m].destroy(),c.buffers[m]=null);c.refresh();return b}var c=new t;e.vaoCount+=1;b.destroy=function(){for(var a=0;a<c.buffers.length;++a)c.buffers[a]&&c.buffers[a].destroy();c.buffers.length=0;c.ownsElements&&(c.elements.destroy(),c.elements=
null,c.ownsElements=!1);c.destroy()};b._vao=c;b._reglType="vao";return b(a)},getVAO:function(a){return"function"===typeof a&&a._vao?a._vao:null},destroyBuffer:function(b){for(var c=0;c<n.length;++c){var d=n[c];d.buffer===b&&(a.disableVertexAttribArray(c),d.buffer=null)}},setVAO:b.oes_vertex_array_object?m:w,clear:b.oes_vertex_array_object?h:function(){}};t.prototype.bindAttrs=function(){for(var c=b.angle_instanced_arrays,e=this.attributes,f=0;f<e.length;++f){var g=e[f];g.buffer?(a.enableVertexAttribArray(f),
a.bindBuffer(34962,g.buffer.buffer),a.vertexAttribPointer(f,g.size,g.type,g.normalized,g.stride,g.offset),c&&g.divisor&&c.vertexAttribDivisorANGLE(f,g.divisor)):(a.disableVertexAttribArray(f),a.vertexAttrib4f(f,g.x,g.y,g.z,g.w))}for(c=e.length;c<D;++c)a.disableVertexAttribArray(c);(c=d.getElements(this.elements))?a.bindBuffer(34963,c.buffer.buffer):a.bindBuffer(34963,null)};t.prototype.refresh=function(){var a=b.oes_vertex_array_object;a&&(a.bindVertexArrayOES(this.vao),this.bindAttrs(),v.currentVAO=
this)};t.prototype.destroy=function(){if(this.vao){var a=b.oes_vertex_array_object;this===v.currentVAO&&(v.currentVAO=null,a.bindVertexArrayOES(null));a.deleteVertexArrayOES(this.vao);this.vao=null}this.ownsElements&&(this.elements.destroy(),this.elements=null,this.ownsElements=!1);k[this.id]&&(delete k[this.id],--e.vaoCount)};return v}function Tb(a,b,c,e){function f(a,b,c,d){this.name=a;this.id=b;this.location=c;this.info=d}function d(a,b){for(var c=0;c<a.length;++c)if(a[c].id===b.id){a[c].location=
b.location;return}a.push(b)}function q(c,d,e){e=35632===c?h:t;var f=e[d];if(!f){var l=b.str(d),f=a.createShader(c);a.shaderSource(f,l);a.compileShader(f);e[d]=f}return f}function m(a,b){this.id=n++;this.fragId=a;this.vertId=b;this.program=null;this.uniforms=[];this.attributes=[];this.refCount=1;e.profile&&(this.stats={uniformsCount:0,attributesCount:0})}function w(c,k,h){var l;l=q(35632,c.fragId);var m=q(35633,c.vertId);k=c.program=a.createProgram();a.attachShader(k,l);a.attachShader(k,m);if(h)for(l=
0;l<h.length;++l)m=h[l],a.bindAttribLocation(k,m[0],m[1]);a.linkProgram(k);m=a.getProgramParameter(k,35718);e.profile&&(c.stats.uniformsCount=m);var n=c.uniforms;for(l=0;l<m;++l)if(h=a.getActiveUniform(k,l))if(1<h.size)for(var w=0;w<h.size;++w){var t=h.name.replace("[0]","["+w+"]");d(n,new f(t,b.id(t),a.getUniformLocation(k,t),h))}else d(n,new f(h.name,b.id(h.name),a.getUniformLocation(k,h.name),h));m=a.getProgramParameter(k,35721);e.profile&&(c.stats.attributesCount=m);c=c.attributes;for(l=0;l<m;++l)(h=
a.getActiveAttrib(k,l))&&d(c,new f(h.name,b.id(h.name),a.getAttribLocation(k,h.name),h))}var h={},t={},l={},D=[],n=0;e.profile&&(c.getMaxUniformsCount=function(){var a=0;D.forEach(function(b){b.stats.uniformsCount>a&&(a=b.stats.uniformsCount)});return a},c.getMaxAttributesCount=function(){var a=0;D.forEach(function(b){b.stats.attributesCount>a&&(a=b.stats.attributesCount)});return a});return{clear:function(){var b=a.deleteShader.bind(a);I(h).forEach(b);h={};I(t).forEach(b);t={};D.forEach(function(b){a.deleteProgram(b.program)});
D.length=0;l={};c.shaderCount=0},program:function(b,d,e,f){var n=l[d];n||(n=l[d]={});var q=n[b];if(q&&(q.refCount++,!f))return q;var x=new m(d,b);c.shaderCount++;w(x,e,f);q||(n[b]=x);D.push(x);return K(x,{destroy:function(){x.refCount--;if(0>=x.refCount){a.deleteProgram(x.program);var b=D.indexOf(x);D.splice(b,1);c.shaderCount--}0>=n[x.vertId].refCount&&(a.deleteShader(t[x.vertId]),delete t[x.vertId],delete l[x.fragId][x.vertId]);Object.keys(l[x.fragId]).length||(a.deleteShader(h[x.fragId]),delete h[x.fragId],
delete l[x.fragId])}})},restore:function(){h={};t={};for(var a=0;a<D.length;++a)w(D[a],null,D[a].attributes.map(function(a){return[a.location,a.name]}))},shader:q,frag:-1,vert:-1}}function Ub(a,b,c,e,f,d,q){function m(d){var f;f=null===b.next?5121:b.next.colorAttachments[0].texture._texture.type;var l=0,m=0,n=e.framebufferWidth,g=e.framebufferHeight,k=null;Q(d)?k=d:d&&(l=d.x|0,m=d.y|0,n=(d.width||e.framebufferWidth-l)|0,g=(d.height||e.framebufferHeight-m)|0,k=d.data||null);c();d=n*g*4;k||(5121===
f?k=new Uint8Array(d):5126===f&&(k=k||new Float32Array(d)));a.pixelStorei(3333,4);a.readPixels(l,m,n,g,6408,f,k);return k}function w(a){var c;b.setFBO({framebuffer:a.framebuffer},function(){c=m(a)});return c}return function(a){return a&&"framebuffer"in a?w(a):m(a)}}function Aa(a){return Array.prototype.slice.call(a)}function Ba(a){return Aa(a).join("")}function Vb(){function a(){var a=[],b=[];return K(function(){a.push.apply(a,Aa(arguments))},{def:function(){var d="v"+c++;b.push(d);0<arguments.length&&
(a.push(d,"="),a.push.apply(a,Aa(arguments)),a.push(";"));return d},toString:function(){return Ba([0<b.length?"var "+b.join(",")+";":"",Ba(a)])}})}function b(){function b(a,e){d(a,e,"=",c.def(a,e),";")}var c=a(),d=a(),e=c.toString,f=d.toString;return K(function(){c.apply(c,Aa(arguments))},{def:c.def,entry:c,exit:d,save:b,set:function(a,d,e){b(a,d);c(a,d,"=",e,";")},toString:function(){return e()+f()}})}var c=0,e=[],f=[],d=a(),q={};return{global:d,link:function(a){for(var b=0;b<f.length;++b)if(f[b]===
a)return e[b];b="g"+c++;e.push(b);f.push(a);return b},block:a,proc:function(a,c){function d(){var a="a"+e.length;e.push(a);return a}var e=[];c=c||0;for(var f=0;f<c;++f)d();var f=b(),D=f.toString;return q[a]=K(f,{arg:d,toString:function(){return Ba(["function(",e.join(),"){",D(),"}"])}})},scope:b,cond:function(){var a=Ba(arguments),c=b(),d=b(),e=c.toString,f=d.toString;return K(c,{then:function(){c.apply(c,Aa(arguments));return this},"else":function(){d.apply(d,Aa(arguments));return this},toString:function(){var b=
f();b&&(b="else{"+b+"}");return Ba(["if(",a,"){",e(),"}",b])}})},compile:function(){var a=['"use strict";',d,"return {"];Object.keys(q).forEach(function(b){a.push('"',b,'":',q[b].toString(),",")});a.push("}");var b=Ba(a).replace(/;/g,";\n").replace(/}/g,"}\n").replace(/{/g,"{\n");return Function.apply(null,e.concat(b)).apply(null,f)}}}function Sa(a){return Array.isArray(a)||Q(a)||ja(a)}function yb(a){return a.sort(function(a,c){return"viewport"===a?-1:"viewport"===c?1:a<c?-1:1})}function J(a,b,c,
e){this.thisDep=a;this.contextDep=b;this.propDep=c;this.append=e}function wa(a){return a&&!(a.thisDep||a.contextDep||a.propDep)}function x(a){return new J(!1,!1,!1,a)}function L(a,b){var c=a.type;if(0===c)return c=a.data.length,new J(!0,1<=c,2<=c,b);if(4===c)return c=a.data,new J(c.thisDep,c.contextDep,c.propDep,b);if(5===c)return new J(!1,!1,!1,b);if(6===c){for(var e=c=!1,f=!1,d=0;d<a.data.length;++d){var q=a.data[d];1===q.type?f=!0:2===q.type?e=!0:3===q.type?c=!0:0===q.type?(c=!0,q=q.data,1<=q&&
(e=!0),2<=q&&(f=!0)):4===q.type&&(c=c||q.data.thisDep,e=e||q.data.contextDep,f=f||q.data.propDep)}return new J(c,e,f,b)}return new J(3===c,2===c,1===c,b)}function Wb(a,b,c,e,f,d,q,m,w,h,t,l,D,n,g){function k(a){return a.replace(".","_")}function v(a,b,c){var d=k(a);Na.push(a);Da[d]=sa[d]=!!c;ta[d]=b}function p(a,b,c){var d=k(a);Na.push(a);Array.isArray(c)?(sa[d]=c.slice(),Da[d]=c.slice()):sa[d]=Da[d]=c;ua[d]=b}function B(){var a=Vb(),c=a.link,d=a.global;a.id=ra++;a.batchId="0";var e=c(tb),f=a.shared=
{props:"a0"};Object.keys(tb).forEach(function(a){f[a]=d.def(e,".",a)});var k=a.next={},da=a.current={};Object.keys(ua).forEach(function(a){Array.isArray(sa[a])&&(k[a]=d.def(f.next,".",a),da[a]=d.def(f.current,".",a))});var z=a.constants={};Object.keys(Pa).forEach(function(a){z[a]=d.def(JSON.stringify(Pa[a]))});a.invoke=function(b,d){switch(d.type){case 0:var e=["this",f.context,f.props,a.batchId];return b.def(c(d.data),".call(",e.slice(0,Math.max(d.data.length+1,4)),")");case 1:return b.def(f.props,
d.data);case 2:return b.def(f.context,d.data);case 3:return b.def("this",d.data);case 4:return d.data.append(a,b),d.data.ref;case 5:return d.data.toString();case 6:return d.data.map(function(c){return a.invoke(b,c)})}};a.attribCache={};var P={};a.scopeAttrib=function(a){a=b.id(a);if(a in P)return P[a];var d=h.scope[a];d||(d=h.scope[a]=new ea);return P[a]=c(d)};return a}function u(a){var b=a["static"];a=a.dynamic;var c;if("profile"in b){var d=!!b.profile;c=x(function(a,b){return d});c.enable=d}else if("profile"in
a){var e=a.profile;c=L(e,function(a,b){return a.invoke(b,e)})}return c}function G(a,b){var c=a["static"],d=a.dynamic;if("framebuffer"in c){var e=c.framebuffer;return e?(e=m.getFramebuffer(e),x(function(a,b){var c=a.link(e),d=a.shared;b.set(d.framebuffer,".next",c);d=d.context;b.set(d,".framebufferWidth",c+".width");b.set(d,".framebufferHeight",c+".height");return c})):x(function(a,b){var c=a.shared;b.set(c.framebuffer,".next","null");c=c.context;b.set(c,".framebufferWidth",c+".drawingBufferWidth");
b.set(c,".framebufferHeight",c+".drawingBufferHeight");return"null"})}if("framebuffer"in d){var f=d.framebuffer;return L(f,function(a,b){var c=a.invoke(b,f),d=a.shared,e=d.framebuffer,c=b.def(e,".getFramebuffer(",c,")");b.set(e,".next",c);d=d.context;b.set(d,".framebufferWidth",c+"?"+c+".width:"+d+".drawingBufferWidth");b.set(d,".framebufferHeight",c+"?"+c+".height:"+d+".drawingBufferHeight");return c})}return null}function C(a,b,c){function d(a){if(a in e){var c=e[a];a=!0;var y=c.x|0,ba=c.y|0,k,
g;"width"in c?k=c.width|0:a=!1;"height"in c?g=c.height|0:a=!1;return new J(!a&&b&&b.thisDep,!a&&b&&b.contextDep,!a&&b&&b.propDep,function(a,b){var d=a.shared.context,e=k;"width"in c||(e=b.def(d,".","framebufferWidth","-",y));var f=g;"height"in c||(f=b.def(d,".","framebufferHeight","-",ba));return[y,ba,e,f]})}if(a in f){var da=f[a];a=L(da,function(a,b){var c=a.invoke(b,da),d=a.shared.context,e=b.def(c,".x|0"),f=b.def(c,".y|0"),y=b.def('"width" in ',c,"?",c,".width|0:","(",d,".","framebufferWidth",
"-",e,")"),c=b.def('"height" in ',c,"?",c,".height|0:","(",d,".","framebufferHeight","-",f,")");return[e,f,y,c]});b&&(a.thisDep=a.thisDep||b.thisDep,a.contextDep=a.contextDep||b.contextDep,a.propDep=a.propDep||b.propDep);return a}return b?new J(b.thisDep,b.contextDep,b.propDep,function(a,b){var c=a.shared.context;return[0,0,b.def(c,".","framebufferWidth"),b.def(c,".","framebufferHeight")]}):null}var e=a["static"],f=a.dynamic;if(a=d("viewport")){var k=a;a=new J(a.thisDep,a.contextDep,a.propDep,function(a,
b){var c=k.append(a,b),d=a.shared.context;b.set(d,".viewportWidth",c[2]);b.set(d,".viewportHeight",c[3]);return c})}return{viewport:a,scissor_box:d("scissor.box")}}function Q(a,b){var c=a["static"];if("string"===typeof c.frag&&"string"===typeof c.vert){if(0<Object.keys(b.dynamic).length)return null;var c=b["static"],d=Object.keys(c);if(0<d.length&&"number"===typeof c[d[0]]){for(var e=[],f=0;f<d.length;++f)e.push([c[d[f]]|0,d[f]]);return e}}return null}function H(a,c,d){function e(a){if(a in f){var c=
b.id(f[a]);a=x(function(){return c});a.id=c;return a}if(a in k){var d=k[a];return L(d,function(a,b){var c=a.invoke(b,d);return b.def(a.shared.strings,".id(",c,")")})}return null}var f=a["static"],k=a.dynamic,g=e("frag"),z=e("vert"),P=null;wa(g)&&wa(z)?(P=t.program(z.id,g.id,null,d),a=x(function(a,b){return a.link(P)})):a=new J(g&&g.thisDep||z&&z.thisDep,g&&g.contextDep||z&&z.contextDep,g&&g.propDep||z&&z.propDep,function(a,b){var c=a.shared.shader,d;d=g?g.append(a,b):b.def(c,".","frag");var e;e=z?
z.append(a,b):b.def(c,".","vert");return b.def(c+".program("+e+","+d+")")});return{frag:g,vert:z,progVar:a,program:P}}function M(a,b){function c(a,b){if(a in e){var d=e[a]|0;b?g.offset=d:g.instances=d;return x(function(a,c){b&&(a.OFFSET=d);return d})}if(a in f){var y=f[a];return L(y,function(a,c){var d=a.invoke(c,y);b&&(a.OFFSET=d);return d})}if(b){if(P)return x(function(a,b){return a.OFFSET=0});if(k)return new J(z.thisDep,z.contextDep,z.propDep,function(a,b){return b.def(a.shared.vao+".currentVAO?"+
a.shared.vao+".currentVAO.offset:0")})}else if(k)return new J(z.thisDep,z.contextDep,z.propDep,function(a,b){return b.def(a.shared.vao+".currentVAO?"+a.shared.vao+".currentVAO.instances:-1")});return null}var e=a["static"],f=a.dynamic,g={},k=!1,z=function(){if("vao"in e){var a=e.vao;null!==a&&null===h.getVAO(a)&&(a=h.createVAO(a));k=!0;g.vao=a;return x(function(b){var c=h.getVAO(a);return c?b.link(c):"null"})}if("vao"in f){k=!0;var b=f.vao;return L(b,function(a,c){var d=a.invoke(c,b);return c.def(a.shared.vao+
".getVAO("+d+")")})}return null}(),P=!1,la=function(){if("elements"in e){var a=e.elements;g.elements=a;if(Sa(a)){var b=g.elements=d.create(a,!0),a=d.getElements(b);P=!0}else a&&(a=d.getElements(a),P=!0);b=x(function(b,c){if(a){var d=b.link(a);return b.ELEMENTS=d}return b.ELEMENTS=null});b.value=a;return b}if("elements"in f){P=!0;var c=f.elements;return L(c,function(a,b){var d=a.shared,e=d.isBufferArgs,d=d.elements,f=a.invoke(b,c),P=b.def("null"),e=b.def(e,"(",f,")"),f=a.cond(e).then(P,"=",d,".createStream(",
f,");")["else"](P,"=",d,".getElements(",f,");");b.entry(f);b.exit(a.cond(e).then(d,".destroyStream(",P,");"));return a.ELEMENTS=P})}return k?new J(z.thisDep,z.contextDep,z.propDep,function(a,b){return b.def(a.shared.vao+".currentVAO?"+a.shared.elements+".getElements("+a.shared.vao+".currentVAO.elements):null")}):null}();P&&(z=x(function(){return"null"}));var ba=c("offset",!0),l=function(){if("primitive"in e){var a=e.primitive;g.primitive=a;return x(function(b,c){return Ka[a]})}if("primitive"in f){var b=
f.primitive;return L(b,function(a,c){var d=a.constants.primTypes,e=a.invoke(c,b);return c.def(d,"[",e,"]")})}return P?wa(la)?la.value?x(function(a,b){return b.def(a.ELEMENTS,".primType")}):x(function(){return 4}):new J(la.thisDep,la.contextDep,la.propDep,function(a,b){var c=a.ELEMENTS;return b.def(c,"?",c,".primType:",4)}):k?new J(z.thisDep,z.contextDep,z.propDep,function(a,b){return b.def(a.shared.vao+".currentVAO?"+a.shared.vao+".currentVAO.primitive:4")}):null}(),m=function(){if("count"in e){var a=
e.count|0;g.count=a;return x(function(){return a})}if("count"in f){var b=f.count;return L(b,function(a,c){return a.invoke(c,b)})}return P?wa(la)?la?ba?new J(ba.thisDep,ba.contextDep,ba.propDep,function(a,b){return b.def(a.ELEMENTS,".vertCount-",a.OFFSET)}):x(function(a,b){return b.def(a.ELEMENTS,".vertCount")}):x(function(){return-1}):new J(la.thisDep||ba.thisDep,la.contextDep||ba.contextDep,la.propDep||ba.propDep,function(a,b){var c=a.ELEMENTS;return a.OFFSET?b.def(c,"?",c,".vertCount-",a.OFFSET,
":-1"):b.def(c,"?",c,".vertCount:-1")}):k?new J(z.thisDep,z.contextDep,z.propDep,function(a,b){return b.def(a.shared.vao,".currentVAO?",a.shared.vao,".currentVAO.count:-1")}):null}(),n=c("instances",!1);return{elements:la,primitive:l,count:m,instances:n,offset:ba,vao:z,vaoActive:k,elementsActive:P,"static":g}}function r(a,b){var c=a["static"],d=a.dynamic,e={};Na.forEach(function(a){function b(P,y){if(a in c){var O=P(c[a]);e[f]=x(function(){return O})}else if(a in d){var g=d[a];e[f]=L(g,function(a,
b){return y(a,b,a.invoke(b,g))})}}var f=k(a);switch(a){case "cull.enable":case "blend.enable":case "dither":case "stencil.enable":case "depth.enable":case "scissor.enable":case "polygonOffset.enable":case "sample.alpha":case "sample.enable":case "depth.mask":return b(function(a){return a},function(a,b,c){return c});case "depth.func":return b(function(a){return ab[a]},function(a,b,c){return b.def(a.constants.compareFuncs,"[",c,"]")});case "depth.range":return b(function(a){return a},function(a,b,c){a=
b.def("+",c,"[0]");b=b.def("+",c,"[1]");return[a,b]});case "blend.func":return b(function(a){return[Fa["srcRGB"in a?a.srcRGB:a.src],Fa["dstRGB"in a?a.dstRGB:a.dst],Fa["srcAlpha"in a?a.srcAlpha:a.src],Fa["dstAlpha"in a?a.dstAlpha:a.dst]]},function(a,b,c){function d(a,e){return b.def('"',a,e,'" in ',c,"?",c,".",a,e,":",c,".",a)}a=a.constants.blendFuncs;var e=d("src","RGB"),f=d("dst","RGB"),e=b.def(a,"[",e,"]"),y=b.def(a,"[",d("src","Alpha"),"]"),f=b.def(a,"[",f,"]");a=b.def(a,"[",d("dst","Alpha"),"]");
return[e,f,y,a]});case "blend.equation":return b(function(a){if("string"===typeof a)return[fa[a],fa[a]];if("object"===typeof a)return[fa[a.rgb],fa[a.alpha]]},function(a,b,c){var d=a.constants.blendEquations,e=b.def(),f=b.def();a=a.cond("typeof ",c,'==="string"');a.then(e,"=",f,"=",d,"[",c,"];");a["else"](e,"=",d,"[",c,".rgb];",f,"=",d,"[",c,".alpha];");b(a);return[e,f]});case "blend.color":return b(function(a){return S(4,function(b){return+a[b]})},function(a,b,c){return S(4,function(a){return b.def("+",
c,"[",a,"]")})});case "stencil.mask":return b(function(a){return a|0},function(a,b,c){return b.def(c,"|0")});case "stencil.func":return b(function(a){return[ab[a.cmp||"keep"],a.ref||0,"mask"in a?a.mask:-1]},function(a,b,c){a=b.def('"cmp" in ',c,"?",a.constants.compareFuncs,"[",c,".cmp]",":",7680);var d=b.def(c,".ref|0");b=b.def('"mask" in ',c,"?",c,".mask|0:-1");return[a,d,b]});case "stencil.opFront":case "stencil.opBack":return b(function(b){return["stencil.opBack"===a?1029:1028,Ta[b.fail||"keep"],
Ta[b.zfail||"keep"],Ta[b.zpass||"keep"]]},function(b,c,d){function e(a){return c.def('"',a,'" in ',d,"?",f,"[",d,".",a,"]:",7680)}var f=b.constants.stencilOps;return["stencil.opBack"===a?1029:1028,e("fail"),e("zfail"),e("zpass")]});case "polygonOffset.offset":return b(function(a){return[a.factor|0,a.units|0]},function(a,b,c){a=b.def(c,".factor|0");b=b.def(c,".units|0");return[a,b]});case "cull.face":return b(function(a){var b=0;"front"===a?b=1028:"back"===a&&(b=1029);return b},function(a,b,c){return b.def(c,
'==="front"?',1028,":",1029)});case "lineWidth":return b(function(a){return a},function(a,b,c){return c});case "frontFace":return b(function(a){return zb[a]},function(a,b,c){return b.def(c+'==="cw"?2304:2305')});case "colorMask":return b(function(a){return a.map(function(a){return!!a})},function(a,b,c){return S(4,function(a){return"!!"+c+"["+a+"]"})});case "sample.coverage":return b(function(a){return["value"in a?a.value:1,!!a.invert]},function(a,b,c){a=b.def('"value" in ',c,"?+",c,".value:1");b=
b.def("!!",c,".invert");return[a,b]})}});return e}function U(a,b){var c=a["static"],d=a.dynamic,e={};Object.keys(c).forEach(function(a){var b=c[a],d;if("number"===typeof b||"boolean"===typeof b)d=x(function(){return b});else if("function"===typeof b){var f=b._reglType;if("texture2d"===f||"textureCube"===f)d=x(function(a){return a.link(b)});else if("framebuffer"===f||"framebufferCube"===f)d=x(function(a){return a.link(b.color[0])})}else qa(b)&&(d=x(function(a){return a.global.def("[",S(b.length,function(a){return b[a]}),
"]")}));d.value=b;e[a]=d});Object.keys(d).forEach(function(a){var b=d[a];e[a]=L(b,function(a,c){return a.invoke(c,b)})});return e}function va(a,c){var d=a["static"],e=a.dynamic,g={};Object.keys(d).forEach(function(a){var c=d[a],e=b.id(a),y=new ea;if(Sa(c))y.state=1,y.buffer=f.getBuffer(f.create(c,34962,!1,!0)),y.type=0;else{var O=f.getBuffer(c);if(O)y.state=1,y.buffer=O,y.type=0;else if("constant"in c){var k=c.constant;y.buffer="null";y.state=2;"number"===typeof k?y.x=k:Ca.forEach(function(a,b){b<
k.length&&(y[a]=k[b])})}else{var O=Sa(c.buffer)?f.getBuffer(f.create(c.buffer,34962,!1,!0)):f.getBuffer(c.buffer),h=c.offset|0,l=c.stride|0,m=c.size|0,n=!!c.normalized,na=0;"type"in c&&(na=Ja[c.type]);c=c.divisor|0;y.buffer=O;y.state=1;y.size=m;y.normalized=n;y.type=na||O.dtype;y.offset=h;y.stride=l;y.divisor=c}}g[a]=x(function(a,b){var c=a.attribCache;if(e in c)return c[e];var d={isStream:!1};Object.keys(y).forEach(function(a){d[a]=y[a]});y.buffer&&(d.buffer=a.link(y.buffer),d.type=d.type||d.buffer+
".dtype");return c[e]=d})});Object.keys(e).forEach(function(a){var b=e[a];g[a]=L(b,function(a,c){function d(a){c(g[a],"=",e,".",a,"|0;")}var e=a.invoke(c,b),f=a.shared,y=a.constants,O=f.isBufferArgs,f=f.buffer,g={isStream:c.def(!1)},k=new ea;k.state=1;Object.keys(k).forEach(function(a){g[a]=c.def(""+k[a])});var h=g.buffer,l=g.type;c("if(",O,"(",e,")){",g.isStream,"=true;",h,"=",f,".createStream(",34962,",",e,");",l,"=",h,".dtype;","}else{",h,"=",f,".getBuffer(",e,");","if(",h,"){",l,"=",h,".dtype;",
'}else if("constant" in ',e,"){",g.state,"=",2,";","if(typeof "+e+'.constant === "number"){',g[Ca[0]],"=",e,".constant;",Ca.slice(1).map(function(a){return g[a]}).join("="),"=0;","}else{",Ca.map(function(a,b){return g[a]+"="+e+".constant.length>"+b+"?"+e+".constant["+b+"]:0;"}).join(""),"}}else{","if(",O,"(",e,".buffer)){",h,"=",f,".createStream(",34962,",",e,".buffer);","}else{",h,"=",f,".getBuffer(",e,".buffer);","}",l,'="type" in ',e,"?",y.glTypes,"[",e,".type]:",h,".dtype;",g.normalized,"=!!",
e,".normalized;");d("size");d("offset");d("stride");d("divisor");c("}}");c.exit("if(",g.isStream,"){",f,".destroyStream(",h,");","}");return g})});return g}function F(a){var b=a["static"],c=a.dynamic,d={};Object.keys(b).forEach(function(a){var c=b[a];d[a]=x(function(a,b){return"number"===typeof c||"boolean"===typeof c?""+c:a.link(c)})});Object.keys(c).forEach(function(a){var b=c[a];d[a]=L(b,function(a,c){return a.invoke(c,b)})});return d}function A(a,b,d,e,f){function g(a){var b=m[a];b&&(ba[a]=b)}
var l=Q(a,b),z=G(a,f),m=C(a,z,f),n=M(a,f),ba=r(a,f),p=H(a,f,l);g("viewport");g(k("scissor.box"));var q=0<Object.keys(ba).length,z={framebuffer:z,draw:n,shader:p,state:ba,dirty:q,scopeVAO:null,drawVAO:null,useVAO:!1,attributes:{}};z.profile=u(a,f);z.uniforms=U(d,f);z.drawVAO=z.scopeVAO=n.vao;if(!z.drawVAO&&p.program&&!l&&c.angle_instanced_arrays&&n["static"].elements){var t=!0;a=p.program.attributes.map(function(a){a=b["static"][a];t=t&&!!a;return a});if(t&&0<a.length){var v=h.getVAO(h.createVAO({attributes:a,
elements:n["static"].elements}));z.drawVAO=new J(null,null,null,function(a,b){return a.link(v)});z.useVAO=!0}}l?z.useVAO=!0:z.attributes=va(b,f);z.context=F(e,f);return z}function ha(a,b,c){var d=a.shared.context,e=a.scope();Object.keys(c).forEach(function(f){b.save(d,"."+f);var g=c[f].append(a,b);Array.isArray(g)?e(d,".",f,"=[",g.join(),"];"):e(d,".",f,"=",g,";")});b(e)}function T(a,b,c,d){var e=a.shared,f=e.gl,g=e.framebuffer,k;Ma&&(k=b.def(e.extensions,".webgl_draw_buffers"));var h=a.constants,
e=h.drawBuffer,h=h.backBuffer;a=c?c.append(a,b):b.def(g,".next");d||b("if(",a,"!==",g,".cur){");b("if(",a,"){",f,".bindFramebuffer(",36160,",",a,".framebuffer);");Ma&&b(k,".drawBuffersWEBGL(",e,"[",a,".colorAttachments.length]);");b("}else{",f,".bindFramebuffer(",36160,",null);");Ma&&b(k,".drawBuffersWEBGL(",h,");");b("}",g,".cur=",a,";");d||b("}")}function za(a,b,c){var d=a.shared,e=d.gl,f=a.current,g=a.next,h=d.current,l=d.next,m=a.cond(h,".dirty");Na.forEach(function(b){b=k(b);if(!(b in c.state)){var d,
O;if(b in g){d=g[b];O=f[b];var n=S(sa[b].length,function(a){return m.def(d,"[",a,"]")});m(a.cond(n.map(function(a,b){return a+"!=="+O+"["+b+"]"}).join("||")).then(e,".",ua[b],"(",n,");",n.map(function(a,b){return O+"["+b+"]="+a}).join(";"),";"))}else d=m.def(l,".",b),n=a.cond(d,"!==",h,".",b),m(n),b in ta?n(a.cond(d).then(e,".enable(",ta[b],");")["else"](e,".disable(",ta[b],");"),h,".",b,"=",d,";"):n(e,".",ua[b],"(",d,");",h,".",b,"=",d,";")}});0===Object.keys(c.state).length&&m(h,".dirty=false;");
b(m)}function I(a,b,c,d){var e=a.shared,f=a.current,g=e.current,k=e.gl;yb(Object.keys(c)).forEach(function(e){var h=c[e];if(!d||d(h)){var l=h.append(a,b);if(ta[e]){var m=ta[e];wa(h)?l?b(k,".enable(",m,");"):b(k,".disable(",m,");"):b(a.cond(l).then(k,".enable(",m,");")["else"](k,".disable(",m,");"));b(g,".",e,"=",l,";")}else if(qa(l)){var n=f[e];b(k,".",ua[e],"(",l,");",l.map(function(a,b){return n+"["+b+"]="+a}).join(";"),";")}else b(k,".",ua[e],"(",l,");",g,".",e,"=",l,";")}})}function N(a,b){X&&
(a.instancing=b.def(a.shared.extensions,".angle_instanced_arrays"))}function E(a,b,c,d,e){function f(){return"undefined"===typeof performance?"Date.now()":"performance.now()"}function g(a){r=b.def();a(r,"=",f(),";");"string"===typeof e?a(m,".count+=",e,";"):a(m,".count++;");n&&(d?(t=b.def(),a(t,"=",q,".getNumPendingQueries();")):a(q,".beginQuery(",m,");"))}function k(a){a(m,".cpuTime+=",f(),"-",r,";");n&&(d?a(q,".pushScopeStats(",t,",",q,".getNumPendingQueries(),",m,");"):a(q,".endQuery();"))}function h(a){var c=
b.def(p,".profile");b(p,".profile=",a,";");b.exit(p,".profile=",c,";")}var l=a.shared,m=a.stats,p=l.current,q=l.timer;c=c.profile;var r,t;if(c){if(wa(c)){c.enable?(g(b),k(b.exit),h("true")):h("false");return}c=c.append(a,b);h(c)}else c=b.def(p,".profile");l=a.block();g(l);b("if(",c,"){",l,"}");a=a.block();k(a);b.exit("if(",c,"){",a,"}")}function ga(a,b,c,d,e){function f(a){switch(a){case 35664:case 35667:case 35671:return 2;case 35665:case 35668:case 35672:return 3;case 35666:case 35669:case 35673:return 4;
default:return 1}}function g(c,d,e){function f(){b("if(!",n,".buffer){",l,".enableVertexAttribArray(",m,");}");var c=e.type,g;g=e.size?b.def(e.size,"||",d):d;b("if(",n,".type!==",c,"||",n,".size!==",g,"||",q.map(function(a){return n+"."+a+"!=="+e[a]}).join("||"),"){",l,".bindBuffer(",34962,",",p,".buffer);",l,".vertexAttribPointer(",[m,g,c,e.normalized,e.stride,e.offset],");",n,".type=",c,";",n,".size=",g,";",q.map(function(a){return n+"."+a+"="+e[a]+";"}).join(""),"}");X&&(c=e.divisor,b("if(",n,
".divisor!==",c,"){",a.instancing,".vertexAttribDivisorANGLE(",[m,c],");",n,".divisor=",c,";}"))}function h(){b("if(",n,".buffer){",l,".disableVertexAttribArray(",m,");",n,".buffer=null;","}if(",Ca.map(function(a,b){return n+"."+a+"!=="+ka[b]}).join("||"),"){",l,".vertexAttrib4f(",m,",",ka,");",Ca.map(function(a,b){return n+"."+a+"="+ka[b]+";"}).join(""),"}")}var l=k.gl,m=b.def(c,".location"),n=b.def(k.attributes,"[",m,"]");c=e.state;var p=e.buffer,ka=[e.x,e.y,e.z,e.w],q=["buffer","normalized","offset",
"stride"];1===c?f():2===c?h():(b("if(",c,"===",1,"){"),f(),b("}else{"),h(),b("}"))}var k=a.shared;d.forEach(function(d){var k=d.name,h=c.attributes[k],l;if(h){if(!e(h))return;l=h.append(a,b)}else{if(!e(Ab))return;var m=a.scopeAttrib(k);l={};Object.keys(new ea).forEach(function(a){l[a]=b.def(m,".",a)})}g(a.link(d),f(d.info.type),l)})}function R(a,c,d,e,f,g){for(var k=a.shared,h=k.gl,l,m=0;m<e.length;++m){var n=e[m],p=n.name,q=n.info.type,r=d.uniforms[p],n=a.link(n)+".location",t;if(r){if(!f(r))continue;
if(wa(r)){p=r.value;if(35678===q||35680===q)q=a.link(p._texture||p.color[0]._texture),c(h,".uniform1i(",n,",",q+".bind());"),c.exit(q,".unbind();");else if(35674===q||35675===q||35676===q)p=a.global.def("new Float32Array(["+Array.prototype.slice.call(p)+"])"),r=2,35675===q?r=3:35676===q&&(r=4),c(h,".uniformMatrix",r,"fv(",n,",false,",p,");");else{switch(q){case 5126:l="1f";break;case 35664:l="2f";break;case 35665:l="3f";break;case 35666:l="4f";break;case 35670:l="1i";break;case 5124:l="1i";break;
case 35671:l="2i";break;case 35667:l="2i";break;case 35672:l="3i";break;case 35668:l="3i";break;case 35673:l="4i";break;case 35669:l="4i"}c(h,".uniform",l,"(",n,",",qa(p)?Array.prototype.slice.call(p):p,");")}continue}else t=r.append(a,c)}else{if(!f(Ab))continue;t=c.def(k.uniforms,"[",b.id(p),"]")}35678===q?c("if(",t,"&&",t,'._reglType==="framebuffer"){',t,"=",t,".color[0];","}"):35680===q&&c("if(",t,"&&",t,'._reglType==="framebufferCube"){',t,"=",t,".color[0];","}");p=1;switch(q){case 35678:case 35680:q=
c.def(t,"._texture");c(h,".uniform1i(",n,",",q,".bind());");c.exit(q,".unbind();");continue;case 5124:case 35670:l="1i";break;case 35667:case 35671:l="2i";p=2;break;case 35668:case 35672:l="3i";p=3;break;case 35669:case 35673:l="4i";p=4;break;case 5126:l="1f";break;case 35664:l="2f";p=2;break;case 35665:l="3f";p=3;break;case 35666:l="4f";p=4;break;case 35674:l="Matrix2fv";break;case 35675:l="Matrix3fv";break;case 35676:l="Matrix4fv"}if("M"===l.charAt(0)){c(h,".uniform",l,"(",n,",");var n=Math.pow(q-
35674+2,2),v=a.global.def("new Float32Array(",n,")");Array.isArray(t)?c("false,(",S(n,function(a){return v+"["+a+"]="+t[a]}),",",v,")"):c("false,(Array.isArray(",t,")||",t," instanceof Float32Array)?",t,":(",S(n,function(a){return v+"["+a+"]="+t+"["+a+"]"}),",",v,")");c(");")}else{if(1<p){for(var q=[],u=[],r=0;r<p;++r)Array.isArray(t)?u.push(t[r]):u.push(c.def(t+"["+r+"]")),g&&q.push(c.def());g&&c("if(!",a.batchId,"||",q.map(function(a,b){return a+"!=="+u[b]}).join("||"),"){",q.map(function(a,b){return a+
"="+u[b]+";"}).join(""));c(h,".uniform",l,"(",n,",",u.join(","),");")}else g&&(q=c.def(),c("if(!",a.batchId,"||",q,"!==",t,"){",q,"=",t,";")),c(h,".uniform",l,"(",n,",",t,");");g&&c("}")}}}function V(a,b,c,d){function e(f){var g=n[f];return g?g.contextDep&&d.contextDynamic||g.propDep?g.append(a,c):g.append(a,b):b.def(h,".",f)}function f(){function a(){c(v,".drawElementsInstancedANGLE(",[p,r,u,q+"<<(("+u+"-5121)>>1)",t],");")}function b(){c(v,".drawArraysInstancedANGLE(",[p,q,r,t],");")}m&&"null"!==
m?w?a():(c("if(",m,"){"),a(),c("}else{"),b(),c("}")):b()}function g(){function a(){c(l+".drawElements("+[p,r,u,q+"<<(("+u+"-5121)>>1)"]+");")}function b(){c(l+".drawArrays("+[p,q,r]+");")}m&&"null"!==m?w?a():(c("if(",m,"){"),a(),c("}else{"),b(),c("}")):b()}var k=a.shared,l=k.gl,h=k.draw,n=d.draw,m=function(){var e=n.elements,f=b;if(e){if(e.contextDep&&d.contextDynamic||e.propDep)f=c;n.vaoActive?e=e.append(a,f):(e=e.append(a,f),f("if("+e+")"+l+".bindBuffer(34963,"+e+".buffer.buffer);"))}else e=f.def(),
f("if(",k.vao,".currentVAO){",e,"=",a.shared.elements+".getElements("+k.vao,".currentVAO.elements);",ma?"":"if("+e+")"+l+".bindBuffer(34963,"+e+".buffer.buffer);","}else{",e,"=",h,".","elements",";","if(",e,"){",l,".bindBuffer(",34963,",",e,".buffer.buffer);}}");return e}(),p=e("primitive"),q=e("offset"),r=function(){var e=n.count,f=b;if(e){if(e.contextDep&&d.contextDynamic||e.propDep)f=c;e=e.append(a,f)}else e=f.def(h,".","count");return e}();if("number"===typeof r){if(0===r)return}else c("if(",
r,"){"),c.exit("}");var t,v;X&&(t=e("instances"),v=a.instancing);var u=m+".type",w=n.elements&&wa(n.elements)&&!n.vaoActive;X&&("number"!==typeof t||0<=t)?"string"===typeof t?(c("if(",t,">0){"),f(),c("}else if(",t,"<0){"),g(),c("}")):f():g()}function ca(a,b,c,d,e){b=B();e=b.proc("body",e);X&&(b.instancing=e.def(b.shared.extensions,".angle_instanced_arrays"));a(b,e,c,d);return b.compile().body}function Z(a,b,c,d){N(a,b);c.useVAO?c.drawVAO?b(a.shared.vao,".setVAO(",c.drawVAO.append(a,b),");"):b(a.shared.vao,
".setVAO(",a.shared.vao,".targetVAO);"):(b(a.shared.vao,".setVAO(null);"),ga(a,b,c,d.attributes,function(){return!0}));R(a,b,c,d.uniforms,function(){return!0},!1);V(a,b,b,c)}function Ea(a,b){var c=a.proc("draw",1);N(a,c);ha(a,c,b.context);T(a,c,b.framebuffer);za(a,c,b);I(a,c,b.state);E(a,c,b,!1,!0);var d=b.shader.progVar.append(a,c);c(a.shared.gl,".useProgram(",d,".program);");if(b.shader.program)Z(a,c,b,b.shader.program);else{c(a.shared.vao,".setVAO(null);");var e=a.global.def("{}"),f=c.def(d,".id"),
g=c.def(e,"[",f,"]");c(a.cond(g).then(g,".call(this,a0);")["else"](g,"=",e,"[",f,"]=",a.link(function(c){return ca(Z,a,b,c,1)}),"(",d,");",g,".call(this,a0);"))}0<Object.keys(b.state).length&&c(a.shared.current,".dirty=true;")}function oa(a,b,c,d){function e(){return!0}a.batchId="a1";N(a,b);ga(a,b,c,d.attributes,e);R(a,b,c,d.uniforms,e,!1);V(a,b,b,c)}function pa(a,b,c,d){function e(a){return a.contextDep&&g||a.propDep}function f(a){return!e(a)}N(a,b);var g=c.contextDep,k=b.def(),l=b.def();a.shared.props=
l;a.batchId=k;var h=a.scope(),n=a.scope();b(h.entry,"for(",k,"=0;",k,"<","a1",";++",k,"){",l,"=","a0","[",k,"];",n,"}",h.exit);c.needsContext&&ha(a,n,c.context);c.needsFramebuffer&&T(a,n,c.framebuffer);I(a,n,c.state,e);c.profile&&e(c.profile)&&E(a,n,c,!1,!0);d?(c.useVAO?c.drawVAO?e(c.drawVAO)?n(a.shared.vao,".setVAO(",c.drawVAO.append(a,n),");"):h(a.shared.vao,".setVAO(",c.drawVAO.append(a,h),");"):h(a.shared.vao,".setVAO(",a.shared.vao,".targetVAO);"):(h(a.shared.vao,".setVAO(null);"),ga(a,h,c,d.attributes,
f),ga(a,n,c,d.attributes,e)),R(a,h,c,d.uniforms,f,!1),R(a,n,c,d.uniforms,e,!0),V(a,h,n,c)):(b=a.global.def("{}"),d=c.shader.progVar.append(a,n),l=n.def(d,".id"),h=n.def(b,"[",l,"]"),n(a.shared.gl,".useProgram(",d,".program);","if(!",h,"){",h,"=",b,"[",l,"]=",a.link(function(b){return ca(oa,a,c,b,2)}),"(",d,");}",h,".call(this,a0[",k,"],",k,");"))}function W(a,b){function c(a){return a.contextDep&&e||a.propDep}var d=a.proc("batch",2);a.batchId="0";N(a,d);var e=!1,f=!0;Object.keys(b.context).forEach(function(a){e=
e||b.context[a].propDep});e||(ha(a,d,b.context),f=!1);var g=b.framebuffer,k=!1;g?(g.propDep?e=k=!0:g.contextDep&&e&&(k=!0),k||T(a,d,g)):T(a,d,null);b.state.viewport&&b.state.viewport.propDep&&(e=!0);za(a,d,b);I(a,d,b.state,function(a){return!c(a)});b.profile&&c(b.profile)||E(a,d,b,!1,"a1");b.contextDep=e;b.needsContext=f;b.needsFramebuffer=k;f=b.shader.progVar;if(f.contextDep&&e||f.propDep)pa(a,d,b,null);else if(f=f.append(a,d),d(a.shared.gl,".useProgram(",f,".program);"),b.shader.program)pa(a,d,
b,b.shader.program);else{d(a.shared.vao,".setVAO(null);");var g=a.global.def("{}"),k=d.def(f,".id"),l=d.def(g,"[",k,"]");d(a.cond(l).then(l,".call(this,a0,a1);")["else"](l,"=",g,"[",k,"]=",a.link(function(c){return ca(pa,a,b,c,2)}),"(",f,");",l,".call(this,a0,a1);"))}0<Object.keys(b.state).length&&d(a.shared.current,".dirty=true;")}function ia(a,c){function d(b){var g=c.shader[b];g&&e.set(f.shader,"."+b,g.append(a,e))}var e=a.proc("scope",3);a.batchId="a2";var f=a.shared,g=f.current;ha(a,e,c.context);
c.framebuffer&&c.framebuffer.append(a,e);yb(Object.keys(c.state)).forEach(function(b){var d=c.state[b].append(a,e);qa(d)?d.forEach(function(c,d){e.set(a.next[b],"["+d+"]",c)}):e.set(f.next,"."+b,d)});E(a,e,c,!0,!0);["elements","offset","count","instances","primitive"].forEach(function(b){var d=c.draw[b];d&&e.set(f.draw,"."+b,""+d.append(a,e))});Object.keys(c.uniforms).forEach(function(d){var g=c.uniforms[d].append(a,e);Array.isArray(g)&&(g="["+g.join()+"]");e.set(f.uniforms,"["+b.id(d)+"]",g)});Object.keys(c.attributes).forEach(function(b){var d=
c.attributes[b].append(a,e),f=a.scopeAttrib(b);Object.keys(new ea).forEach(function(a){e.set(f,"."+a,d[a])})});c.scopeVAO&&e.set(f.vao,".targetVAO",c.scopeVAO.append(a,e));d("vert");d("frag");0<Object.keys(c.state).length&&(e(g,".dirty=true;"),e.exit(g,".dirty=true;"));e("a1(",a.shared.context,",a0,",a.batchId,");")}function ja(a){if("object"===typeof a&&!qa(a)){for(var b=Object.keys(a),c=0;c<b.length;++c)if(Y.isDynamic(a[b[c]]))return!0;return!1}}function aa(a,b,c){function d(a,b){g.forEach(function(c){var d=
e[c];Y.isDynamic(d)&&(d=a.invoke(b,d),b(n,".",c,"=",d,";"))})}var e=b["static"][c];if(e&&ja(e)){var f=a.global,g=Object.keys(e),k=!1,l=!1,h=!1,n=a.global.def("{}");g.forEach(function(b){var c=e[b];if(Y.isDynamic(c))"function"===typeof c&&(c=e[b]=Y.unbox(c)),b=L(c,null),k=k||b.thisDep,h=h||b.propDep,l=l||b.contextDep;else{f(n,".",b,"=");switch(typeof c){case "number":f(c);break;case "string":f('"',c,'"');break;case "object":Array.isArray(c)&&f("[",c.join(),"]");break;default:f(a.link(c))}f(";")}});
b.dynamic[c]=new Y.DynamicVariable(4,{thisDep:k,contextDep:l,propDep:h,ref:n,append:d});delete b["static"][c]}}var ea=h.Record,fa={add:32774,subtract:32778,"reverse subtract":32779};c.ext_blend_minmax&&(fa.min=32775,fa.max=32776);var X=c.angle_instanced_arrays,Ma=c.webgl_draw_buffers,ma=c.oes_vertex_array_object,sa={dirty:!0,profile:g.profile},Da={},Na=[],ta={},ua={};v("dither",3024);v("blend.enable",3042);p("blend.color","blendColor",[0,0,0,0]);p("blend.equation","blendEquationSeparate",[32774,32774]);
p("blend.func","blendFuncSeparate",[1,0,1,0]);v("depth.enable",2929,!0);p("depth.func","depthFunc",513);p("depth.range","depthRange",[0,1]);p("depth.mask","depthMask",!0);p("colorMask","colorMask",[!0,!0,!0,!0]);v("cull.enable",2884);p("cull.face","cullFace",1029);p("frontFace","frontFace",2305);p("lineWidth","lineWidth",1);v("polygonOffset.enable",32823);p("polygonOffset.offset","polygonOffset",[0,0]);v("sample.alpha",32926);v("sample.enable",32928);p("sample.coverage","sampleCoverage",[1,!1]);v("stencil.enable",
2960);p("stencil.mask","stencilMask",-1);p("stencil.func","stencilFunc",[519,0,-1]);p("stencil.opFront","stencilOpSeparate",[1028,7680,7680,7680]);p("stencil.opBack","stencilOpSeparate",[1029,7680,7680,7680]);v("scissor.enable",3089);p("scissor.box","scissor",[0,0,a.drawingBufferWidth,a.drawingBufferHeight]);p("viewport","viewport",[0,0,a.drawingBufferWidth,a.drawingBufferHeight]);var tb={gl:a,context:D,strings:b,next:Da,current:sa,draw:l,elements:d,buffer:f,shader:t,attributes:h.state,vao:h,uniforms:w,
framebuffer:m,extensions:c,timer:n,isBufferArgs:Sa},Pa={primTypes:Ka,compareFuncs:ab,blendFuncs:Fa,blendEquations:fa,stencilOps:Ta,glTypes:Ja,orientationType:zb};Ma&&(Pa.backBuffer=[1029],Pa.drawBuffer=S(e.maxDrawbuffers,function(a){return 0===a?[0]:S(a,function(a){return 36064+a})}));var ra=0;return{next:Da,current:sa,procs:function(){var a=B(),b=a.proc("poll"),d=a.proc("refresh"),f=a.block();b(f);d(f);var g=a.shared,k=g.gl,l=g.next,h=g.current;f(h,".dirty=false;");T(a,b);T(a,d,null,!0);var n;X&&
(n=a.link(X));c.oes_vertex_array_object&&d(a.link(c.oes_vertex_array_object),".bindVertexArrayOES(null);");for(var m=0;m<e.maxAttributes;++m){var p=d.def(g.attributes,"[",m,"]"),q=a.cond(p,".buffer");q.then(k,".enableVertexAttribArray(",m,");",k,".bindBuffer(",34962,",",p,".buffer.buffer);",k,".vertexAttribPointer(",m,",",p,".size,",p,".type,",p,".normalized,",p,".stride,",p,".offset);")["else"](k,".disableVertexAttribArray(",m,");",k,".vertexAttrib4f(",m,",",p,".x,",p,".y,",p,".z,",p,".w);",p,".buffer=null;");
d(q);X&&d(n,".vertexAttribDivisorANGLE(",m,",",p,".divisor);")}d(a.shared.vao,".currentVAO=null;",a.shared.vao,".setVAO(",a.shared.vao,".targetVAO);");Object.keys(ta).forEach(function(c){var e=ta[c],g=f.def(l,".",c),n=a.block();n("if(",g,"){",k,".enable(",e,")}else{",k,".disable(",e,")}",h,".",c,"=",g,";");d(n);b("if(",g,"!==",h,".",c,"){",n,"}")});Object.keys(ua).forEach(function(c){var e=ua[c],g=sa[c],n,m,p=a.block();p(k,".",e,"(");qa(g)?(e=g.length,n=a.global.def(l,".",c),m=a.global.def(h,".",
c),p(S(e,function(a){return n+"["+a+"]"}),");",S(e,function(a){return m+"["+a+"]="+n+"["+a+"];"}).join("")),b("if(",S(e,function(a){return n+"["+a+"]!=="+m+"["+a+"]"}).join("||"),"){",p,"}")):(n=f.def(l,".",c),m=f.def(h,".",c),p(n,");",h,".",c,"=",n,";"),b("if(",n,"!==",m,"){",p,"}"));d(p)});return a.compile()}(),compile:function(a,b,c,d,e){var f=B();f.stats=f.link(e);Object.keys(b["static"]).forEach(function(a){aa(f,b,a)});Xb.forEach(function(b){aa(f,a,b)});var g=A(a,b,c,d,f);Ea(f,g);ia(f,g);W(f,
g);return K(f.compile(),{destroy:function(){g.shader.program.destroy()}})}}}function Bb(a,b){for(var c=0;c<a.length;++c)if(a[c]===b)return c;return-1}var K=function(a,b){for(var c=Object.keys(b),e=0;e<c.length;++e)a[c[e]]=b[c[e]];return a},Db=0,Y={DynamicVariable:Z,define:function(a,b){return new Z(a,cb(b+""))},isDynamic:function(a){return"function"===typeof a&&!a._reglType||a instanceof Z},unbox:db,accessor:cb},bb={next:"function"===typeof requestAnimationFrame?function(a){return requestAnimationFrame(a)}:
function(a){return setTimeout(a,16)},cancel:"function"===typeof cancelAnimationFrame?function(a){return cancelAnimationFrame(a)}:clearTimeout},Cb="undefined"!==typeof performance&&performance.now?function(){return performance.now()}:function(){return+new Date},G=hb();G.zero=hb();var Yb=function(a,b){var c=1;b.ext_texture_filter_anisotropic&&(c=a.getParameter(34047));var e=1,f=1;b.webgl_draw_buffers&&(e=a.getParameter(34852),f=a.getParameter(36063));var d=!!b.oes_texture_float;if(d){d=a.createTexture();
a.bindTexture(3553,d);a.texImage2D(3553,0,6408,1,1,0,6408,5126,null);var q=a.createFramebuffer();a.bindFramebuffer(36160,q);a.framebufferTexture2D(36160,36064,3553,d,0);a.bindTexture(3553,null);if(36053!==a.checkFramebufferStatus(36160))d=!1;else{a.viewport(0,0,1,1);a.clearColor(1,0,0,1);a.clear(16384);var m=G.allocType(5126,4);a.readPixels(0,0,1,1,6408,5126,m);a.getError()?d=!1:(a.deleteFramebuffer(q),a.deleteTexture(d),d=1===m[0]);G.freeType(m)}}m=!0;"undefined"!==typeof navigator&&(/MSIE/.test(navigator.userAgent)||
/Trident\//.test(navigator.appVersion)||/Edge/.test(navigator.userAgent))||(m=a.createTexture(),q=G.allocType(5121,36),a.activeTexture(33984),a.bindTexture(34067,m),a.texImage2D(34069,0,6408,3,3,0,6408,5121,q),G.freeType(q),a.bindTexture(34067,null),a.deleteTexture(m),m=!a.getError());return{colorBits:[a.getParameter(3410),a.getParameter(3411),a.getParameter(3412),a.getParameter(3413)],depthBits:a.getParameter(3414),stencilBits:a.getParameter(3415),subpixelBits:a.getParameter(3408),extensions:Object.keys(b).filter(function(a){return!!b[a]}),
maxAnisotropic:c,maxDrawbuffers:e,maxColorAttachments:f,pointSizeDims:a.getParameter(33901),lineWidthDims:a.getParameter(33902),maxViewportDims:a.getParameter(3386),maxCombinedTextureUnits:a.getParameter(35661),maxCubeMapSize:a.getParameter(34076),maxRenderbufferSize:a.getParameter(34024),maxTextureUnits:a.getParameter(34930),maxTextureSize:a.getParameter(3379),maxAttributes:a.getParameter(34921),maxVertexUniforms:a.getParameter(36347),maxVertexTextureUnits:a.getParameter(35660),maxVaryingVectors:a.getParameter(36348),
maxFragmentUniforms:a.getParameter(36349),glsl:a.getParameter(35724),renderer:a.getParameter(7937),vendor:a.getParameter(7936),version:a.getParameter(7938),readFloat:d,npotTextureCube:m}},Q=function(a){return a instanceof Uint8Array||a instanceof Uint16Array||a instanceof Uint32Array||a instanceof Int8Array||a instanceof Int16Array||a instanceof Int32Array||a instanceof Float32Array||a instanceof Float64Array||a instanceof Uint8ClampedArray},I=function(a){return Object.keys(a).map(function(b){return a[b]})},
Qa={shape:function(a){for(var b=[];a.length;a=a[0])b.push(a.length);return b},flatten:function(a,b,c,e){var f=1;if(b.length)for(var d=0;d<b.length;++d)f*=b[d];else f=0;c=e||G.allocType(c,f);switch(b.length){case 0:break;case 1:e=b[0];for(b=0;b<e;++b)c[b]=a[b];break;case 2:e=b[0];b=b[1];for(d=f=0;d<e;++d)for(var q=a[d],m=0;m<b;++m)c[f++]=q[m];break;case 3:ib(a,b[0],b[1],b[2],c,0);break;default:jb(a,b,0,c,0)}return c}},Ha={"[object Int8Array]":5120,"[object Int16Array]":5122,"[object Int32Array]":5124,
"[object Uint8Array]":5121,"[object Uint8ClampedArray]":5121,"[object Uint16Array]":5123,"[object Uint32Array]":5125,"[object Float32Array]":5126,"[object Float64Array]":5121,"[object ArrayBuffer]":5121},Ja={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,"float":5126,float32:5126},nb={dynamic:35048,stream:35040,"static":35044},Ua=Qa.flatten,mb=Qa.shape,ma=[];ma[5120]=1;ma[5122]=2;ma[5124]=4;ma[5121]=1;ma[5123]=2;ma[5125]=4;ma[5126]=4;var Ka={points:0,point:0,lines:1,line:1,triangles:4,
triangle:4,"line loop":2,"line strip":3,"triangle strip":5,"triangle fan":6},pb=new Float32Array(1),Lb=new Uint32Array(pb.buffer),Pb=[9984,9986,9985,9987],Oa=[0,6409,6410,6407,6408],V={};V[6409]=V[6406]=V[6402]=1;V[34041]=V[6410]=2;V[6407]=V[35904]=3;V[6408]=V[35906]=4;var Xa=ra("HTMLCanvasElement"),Ya=ra("OffscreenCanvas"),ub=ra("CanvasRenderingContext2D"),vb=ra("ImageBitmap"),wb=ra("HTMLImageElement"),xb=ra("HTMLVideoElement"),Mb=Object.keys(Ha).concat([Xa,Ya,ub,vb,wb,xb]),ya=[];ya[5121]=1;ya[5126]=
4;ya[36193]=2;ya[5123]=2;ya[5125]=4;var C=[];C[32854]=2;C[32855]=2;C[36194]=2;C[34041]=4;C[33776]=.5;C[33777]=.5;C[33778]=1;C[33779]=1;C[35986]=.5;C[35987]=1;C[34798]=1;C[35840]=.5;C[35841]=.25;C[35842]=.5;C[35843]=.25;C[36196]=.5;var R=[];R[32854]=2;R[32855]=2;R[36194]=2;R[33189]=2;R[36168]=1;R[34041]=4;R[35907]=4;R[34836]=16;R[34842]=8;R[34843]=6;var Zb=function(a,b,c,e,f){function d(a){this.id=h++;this.refCount=1;this.renderbuffer=a;this.format=32854;this.height=this.width=0;f.profile&&(this.stats=
{size:0})}function q(b){var c=b.renderbuffer;a.bindRenderbuffer(36161,null);a.deleteRenderbuffer(c);b.renderbuffer=null;b.refCount=0;delete t[b.id];e.renderbufferCount--}var m={rgba4:32854,rgb565:36194,"rgb5 a1":32855,depth:33189,stencil:36168,"depth stencil":34041};b.ext_srgb&&(m.srgba=35907);b.ext_color_buffer_half_float&&(m.rgba16f=34842,m.rgb16f=34843);b.webgl_color_buffer_float&&(m.rgba32f=34836);var w=[];Object.keys(m).forEach(function(a){w[m[a]]=a});var h=0,t={};d.prototype.decRef=function(){0>=
--this.refCount&&q(this)};f.profile&&(e.getTotalRenderbufferSize=function(){var a=0;Object.keys(t).forEach(function(b){a+=t[b].stats.size});return a});return{create:function(b,c){function h(b,c){var d=0,e=0,l=32854;"object"===typeof b&&b?("shape"in b?(e=b.shape,d=e[0]|0,e=e[1]|0):("radius"in b&&(d=e=b.radius|0),"width"in b&&(d=b.width|0),"height"in b&&(e=b.height|0)),"format"in b&&(l=m[b.format])):"number"===typeof b?(d=b|0,e="number"===typeof c?c|0:d):b||(d=e=1);if(d!==g.width||e!==g.height||l!==
g.format)return h.width=g.width=d,h.height=g.height=e,g.format=l,a.bindRenderbuffer(36161,g.renderbuffer),a.renderbufferStorage(36161,l,d,e),f.profile&&(g.stats.size=R[g.format]*g.width*g.height),h.format=w[g.format],h}var g=new d(a.createRenderbuffer());t[g.id]=g;e.renderbufferCount++;h(b,c);h.resize=function(b,c){var d=b|0,e=c|0||d;if(d===g.width&&e===g.height)return h;h.width=g.width=d;h.height=g.height=e;a.bindRenderbuffer(36161,g.renderbuffer);a.renderbufferStorage(36161,g.format,d,e);f.profile&&
(g.stats.size=R[g.format]*g.width*g.height);return h};h._reglType="renderbuffer";h._renderbuffer=g;f.profile&&(h.stats=g.stats);h.destroy=function(){g.decRef()};return h},clear:function(){I(t).forEach(q)},restore:function(){I(t).forEach(function(b){b.renderbuffer=a.createRenderbuffer();a.bindRenderbuffer(36161,b.renderbuffer);a.renderbufferStorage(36161,b.format,b.width,b.height)});a.bindRenderbuffer(36161,null)}}},Za=[];Za[6408]=4;Za[6407]=3;var Ra=[];Ra[5121]=1;Ra[5126]=4;Ra[36193]=2;var Ca=["x",
"y","z","w"],Xb="blend.func blend.equation stencil.func stencil.opFront stencil.opBack sample.coverage viewport scissor.box polygonOffset.offset".split(" "),Fa={0:0,1:1,zero:0,one:1,"src color":768,"one minus src color":769,"src alpha":770,"one minus src alpha":771,"dst color":774,"one minus dst color":775,"dst alpha":772,"one minus dst alpha":773,"constant color":32769,"one minus constant color":32770,"constant alpha":32771,"one minus constant alpha":32772,"src alpha saturate":776},ab={never:512,
less:513,"<":513,equal:514,"=":514,"==":514,"===":514,lequal:515,"<=":515,greater:516,">":516,notequal:517,"!=":517,"!==":517,gequal:518,">=":518,always:519},Ta={0:0,zero:0,keep:7680,replace:7681,increment:7682,decrement:7683,"increment wrap":34055,"decrement wrap":34056,invert:5386},zb={cw:2304,ccw:2305},Ab=new J(!1,!1,!1,function(){}),$b=function(a,b){function c(){this.endQueryIndex=this.startQueryIndex=-1;this.sum=0;this.stats=null}function e(a,b,d){var e=q.pop()||new c;e.startQueryIndex=a;e.endQueryIndex=
b;e.sum=0;e.stats=d;m.push(e)}if(!b.ext_disjoint_timer_query)return null;var f=[],d=[],q=[],m=[],w=[],h=[];return{beginQuery:function(a){var c=f.pop()||b.ext_disjoint_timer_query.createQueryEXT();b.ext_disjoint_timer_query.beginQueryEXT(35007,c);d.push(c);e(d.length-1,d.length,a)},endQuery:function(){b.ext_disjoint_timer_query.endQueryEXT(35007)},pushScopeStats:e,update:function(){var a,c;a=d.length;if(0!==a){h.length=Math.max(h.length,a+1);w.length=Math.max(w.length,a+1);w[0]=0;var e=h[0]=0;for(c=
a=0;c<d.length;++c){var n=d[c];b.ext_disjoint_timer_query.getQueryObjectEXT(n,34919)?(e+=b.ext_disjoint_timer_query.getQueryObjectEXT(n,34918),f.push(n)):d[a++]=n;w[c+1]=e;h[c+1]=a}d.length=a;for(c=a=0;c<m.length;++c){var e=m[c],g=e.startQueryIndex,n=e.endQueryIndex;e.sum+=w[n]-w[g];g=h[g];n=h[n];n===g?(e.stats.gpuTime+=e.sum/1E6,q.push(e)):(e.startQueryIndex=g,e.endQueryIndex=n,m[a++]=e)}m.length=a}},getNumPendingQueries:function(){return d.length},clear:function(){f.push.apply(f,d);for(var a=0;a<
f.length;a++)b.ext_disjoint_timer_query.deleteQueryEXT(f[a]);d.length=0;f.length=0},restore:function(){d.length=0;f.length=0}}};return function(a){function b(){if(0===E.length)u&&u.update(),ca=null;else{ca=bb.next(b);t();for(var a=E.length-1;0<=a;--a){var c=E[a];c&&c(H,null,0)}n.flush();u&&u.update()}}function c(){!ca&&0<E.length&&(ca=bb.next(b))}function e(){ca&&(bb.cancel(b),ca=null)}function f(a){a.preventDefault();e();S.forEach(function(a){a()})}function d(a){n.getError();k.restore();F.restore();
r.restore();A.restore();Q.restore();T.restore();L.restore();u&&u.restore();I.procs.refresh();c();V.forEach(function(a){a()})}function q(a){function b(a,c){var d={},e={};Object.keys(a).forEach(function(b){var f=a[b];if(Y.isDynamic(f))e[b]=Y.unbox(f,b);else{if(c&&Array.isArray(f))for(var g=0;g<f.length;++g)if(Y.isDynamic(f[g])){e[b]=Y.unbox(f,b);return}d[b]=f}});return{dynamic:e,"static":d}}function c(a){for(;n.length<a;)n.push(null);return n}var d=b(a.context||{},!0),e=b(a.uniforms||{},!0),f=b(a.attributes||
{},!1);a=b(function(a){function b(a){if(a in c){var d=c[a];delete c[a];Object.keys(d).forEach(function(b){c[a+"."+b]=d[b]})}}var c=K({},a);delete c.uniforms;delete c.attributes;delete c.context;delete c.vao;"stencil"in c&&c.stencil.op&&(c.stencil.opBack=c.stencil.opFront=c.stencil.op,delete c.stencil.op);b("blend");b("depth");b("cull");b("stencil");b("polygonOffset");b("scissor");b("sample");"vao"in a&&(c.vao=a.vao);return c}(a),!1);var g={gpuTime:0,cpuTime:0,count:0},h=I.compile(a,f,e,d,g),k=h.draw,
l=h.batch,m=h.scope,n=[];return K(function(a,b){var d;if("function"===typeof a)return m.call(this,null,a,0);if("function"===typeof b)if("number"===typeof a)for(d=0;d<a;++d)m.call(this,null,b,d);else if(Array.isArray(a))for(d=0;d<a.length;++d)m.call(this,a[d],b,d);else return m.call(this,a,b,0);else if("number"===typeof a){if(0<a)return l.call(this,c(a|0),a|0)}else if(Array.isArray(a)){if(a.length)return l.call(this,a,a.length)}else return k.call(this,a)},{stats:g,destroy:function(){h.destroy()}})}
function m(a,b){var c=0;I.procs.poll();var d=b.color;d&&(n.clearColor(+d[0]||0,+d[1]||0,+d[2]||0,+d[3]||0),c|=16384);"depth"in b&&(n.clearDepth(+b.depth),c|=256);"stencil"in b&&(n.clearStencil(b.stencil|0),c|=1024);n.clear(c)}function w(a){E.push(a);c();return{cancel:function(){function b(){var a=Bb(E,b);E[a]=E[E.length-1];--E.length;0>=E.length&&e()}var c=Bb(E,a);E[c]=b}}}function h(){var a=R.viewport,b=R.scissor_box;a[0]=a[1]=b[0]=b[1]=0;H.viewportWidth=H.framebufferWidth=H.drawingBufferWidth=a[2]=
b[2]=n.drawingBufferWidth;H.viewportHeight=H.framebufferHeight=H.drawingBufferHeight=a[3]=b[3]=n.drawingBufferHeight}function t(){H.tick+=1;H.time=x();h();I.procs.poll()}function l(){A.refresh();h();I.procs.refresh();u&&u.update()}function x(){return(Cb()-G)/1E3}a=Hb(a);if(!a)return null;var n=a.gl,g=n.getContextAttributes();n.isContextLost();var k=Ib(n,a);if(!k)return null;var v=Eb(),p={vaoCount:0,bufferCount:0,elementsCount:0,framebufferCount:0,shaderCount:0,textureCount:0,cubeCount:0,renderbufferCount:0,
maxTextureUnits:0},B=k.extensions,u=$b(n,B),G=Cb(),C=n.drawingBufferWidth,J=n.drawingBufferHeight,H={tick:0,time:0,viewportWidth:C,viewportHeight:J,framebufferWidth:C,framebufferHeight:J,drawingBufferWidth:C,drawingBufferHeight:J,pixelRatio:a.pixelRatio},C={elements:null,primitive:4,count:-1,offset:0,instances:-1},M=Yb(n,B),r=Jb(n,p,a,function(a){return L.destroyBuffer(a)}),U=Kb(n,B,r,p),L=Sb(n,B,M,p,r,U,C),F=Tb(n,v,p,a),A=Nb(n,B,M,function(){I.procs.poll()},H,p,a),Q=Zb(n,B,M,p,a),T=Rb(n,B,M,A,Q,
p),I=Wb(n,v,B,M,r,U,A,T,{},L,F,C,H,u,a),v=Ub(n,T,I.procs.poll,H,g,B,M),R=I.next,N=n.canvas,E=[],S=[],V=[],Z=[a.onDestroy],ca=null;N&&(N.addEventListener("webglcontextlost",f,!1),N.addEventListener("webglcontextrestored",d,!1));var aa=T.setFBO=q({framebuffer:Y.define.call(null,1,"framebuffer")});l();g=K(q,{clear:function(a){if("framebuffer"in a)if(a.framebuffer&&"framebufferCube"===a.framebuffer_reglType)for(var b=0;6>b;++b)aa(K({framebuffer:a.framebuffer.faces[b]},a),m);else aa(a,m);else m(null,a)},
prop:Y.define.bind(null,1),context:Y.define.bind(null,2),"this":Y.define.bind(null,3),draw:q({}),buffer:function(a){return r.create(a,34962,!1,!1)},elements:function(a){return U.create(a,!1)},texture:A.create2D,cube:A.createCube,renderbuffer:Q.create,framebuffer:T.create,framebufferCube:T.createCube,vao:L.createVAO,attributes:g,frame:w,on:function(a,b){var c;switch(a){case "frame":return w(b);case "lost":c=S;break;case "restore":c=V;break;case "destroy":c=Z}c.push(b);return{cancel:function(){for(var a=
0;a<c.length;++a)if(c[a]===b){c[a]=c[c.length-1];c.pop();break}}}},limits:M,hasExtension:function(a){return 0<=M.extensions.indexOf(a.toLowerCase())},read:v,destroy:function(){E.length=0;e();N&&(N.removeEventListener("webglcontextlost",f),N.removeEventListener("webglcontextrestored",d));F.clear();T.clear();Q.clear();L.clear();A.clear();U.clear();r.clear();u&&u.clear();Z.forEach(function(a){a()})},_gl:n,_refresh:l,poll:function(){t();u&&u.update()},now:x,stats:p});a.onDone(null,g);return g}});

},{}],163:[function(require,module,exports){
'use strict'

/**
 * Remove a range of items from an array
 *
 * @function removeItems
 * @param {Array<*>} arr The target array
 * @param {number} startIdx The index to begin removing from (inclusive)
 * @param {number} removeCount How many items to remove
 */
module.exports = function removeItems (arr, startIdx, removeCount) {
  var i, length = arr.length

  if (startIdx >= length || removeCount === 0) {
    return
  }

  removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount)

  var len = length - removeCount

  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount]
  }

  arr.length = len
}

},{}],164:[function(require,module,exports){
/* global XMLHttpRequest */
var configParameters = [
  'manifest',
  'onDone',
  'onProgress',
  'onError'
]

var manifestParameters = [
  'type',
  'src',
  'stream',
  'credentials',
  'parser'
]

var parserParameters = [
  'onData',
  'onDone'
]

var STATE_ERROR = -1
var STATE_DATA = 0
var STATE_COMPLETE = 1

function raise (message) {
  throw new Error('resl: ' + message)
}

function checkType (object, parameters, name) {
  Object.keys(object).forEach(function (param) {
    if (parameters.indexOf(param) < 0) {
      raise('invalid parameter "' + param + '" in ' + name)
    }
  })
}

function Loader (name, cancel) {
  this.state = STATE_DATA
  this.ready = false
  this.progress = 0
  this.name = name
  this.cancel = cancel
}

module.exports = function resl (config) {
  if (typeof config !== 'object' || !config) {
    raise('invalid or missing configuration')
  }

  checkType(config, configParameters, 'config')

  var manifest = config.manifest
  if (typeof manifest !== 'object' || !manifest) {
    raise('missing manifest')
  }

  function getFunction (name, dflt) {
    if (name in config) {
      var func = config[name]
      if (typeof func !== 'function') {
        raise('invalid callback "' + name + '"')
      }
      return func
    }
    return null
  }

  var onDone = getFunction('onDone')
  if (!onDone) {
    raise('missing onDone() callback')
  }

  var onProgress = getFunction('onProgress')
  var onError = getFunction('onError')

  var assets = {}

  var state = STATE_DATA

  function loadXHR (request) {
    var name = request.name
    var stream = request.stream
    var binary = request.type === 'binary'
    var parser = request.parser

    var xhr = new XMLHttpRequest()
    var asset = null

    var loader = new Loader(name, cancel)

    if (stream) {
      xhr.onreadystatechange = onReadyStateChange
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          onReadyStateChange()
        }
      }
    }

    if (binary) {
      xhr.responseType = 'arraybuffer'
    }

    function onReadyStateChange () {
      if (xhr.readyState < 2 ||
          loader.state === STATE_COMPLETE ||
          loader.state === STATE_ERROR) {
        return
      }
      if (xhr.status !== 200) {
        return abort('error loading resource "' + request.name + '"')
      }
      if (xhr.readyState > 2 && loader.state === STATE_DATA) {
        var response
        if (request.type === 'binary') {
          response = xhr.response
        } else {
          response = xhr.responseText
        }
        if (parser.data) {
          try {
            asset = parser.data(response)
          } catch (e) {
            return abort(e)
          }
        } else {
          asset = response
        }
      }
      if (xhr.readyState > 3 && loader.state === STATE_DATA) {
        if (parser.done) {
          try {
            asset = parser.done()
          } catch (e) {
            return abort(e)
          }
        }
        loader.state = STATE_COMPLETE
      }
      assets[name] = asset
      loader.progress = 0.75 * loader.progress + 0.25
      loader.ready =
        (request.stream && !!asset) ||
        loader.state === STATE_COMPLETE
      notifyProgress()
    }

    function cancel () {
      if (loader.state === STATE_COMPLETE || loader.state === STATE_ERROR) {
        return
      }
      xhr.onreadystatechange = null
      xhr.abort()
      loader.state = STATE_ERROR
    }

    // set up request
    if (request.credentials) {
      xhr.withCredentials = true
    }
    xhr.open('GET', request.src, true)
    xhr.send()

    return loader
  }

  function loadElement (request, element) {
    var name = request.name
    var parser = request.parser

    var loader = new Loader(name, cancel)
    var asset = element

    function handleProgress () {
      if (loader.state === STATE_DATA) {
        if (parser.data) {
          try {
            asset = parser.data(element)
          } catch (e) {
            return abort(e)
          }
        } else {
          asset = element
        }
      }
    }

    function onProgress (e) {
      handleProgress()
      assets[name] = asset
      if (e.lengthComputable) {
        loader.progress = Math.max(loader.progress, e.loaded / e.total)
      } else {
        loader.progress = 0.75 * loader.progress + 0.25
      }
      notifyProgress(name)
    }

    function onComplete () {
      handleProgress()
      if (loader.state === STATE_DATA) {
        if (parser.done) {
          try {
            asset = parser.done()
          } catch (e) {
            return abort(e)
          }
        }
        loader.state = STATE_COMPLETE
      }
      loader.progress = 1
      loader.ready = true
      assets[name] = asset
      removeListeners()
      notifyProgress('finish ' + name)
    }

    function onError () {
      abort('error loading asset "' + name + '"')
    }

    if (request.stream) {
      element.addEventListener('progress', onProgress)
    }
    if (request.type === 'image') {
      element.addEventListener('load', onComplete)
    } else {
      var canPlay = false
      var loadedMetaData = false
      element.addEventListener('loadedmetadata', function () {
        loadedMetaData = true
        if (canPlay) {
          onComplete()
        }
      })
      element.addEventListener('canplay', function () {
        canPlay = true
        if (loadedMetaData) {
          onComplete()
        }
      })
    }
    element.addEventListener('error', onError)

    function removeListeners () {
      if (request.stream) {
        element.removeEventListener('progress', onProgress)
      }
      if (request.type === 'image') {
        element.addEventListener('load', onComplete)
      } else {
        element.addEventListener('canplay', onComplete)
      }
      element.removeEventListener('error', onError)
    }

    function cancel () {
      if (loader.state === STATE_COMPLETE || loader.state === STATE_ERROR) {
        return
      }
      loader.state = STATE_ERROR
      removeListeners()
      element.src = ''
    }

    // set up request
    if (request.credentials) {
      element.crossOrigin = 'use-credentials'
    } else {
      element.crossOrigin = 'anonymous'
    }
    element.src = request.src

    return loader
  }

  var loaders = {
    text: loadXHR,
    binary: function (request) {
      // TODO use fetch API for streaming if supported
      return loadXHR(request)
    },
    image: function (request) {
      return loadElement(request, document.createElement('img'))
    },
    video: function (request) {
      return loadElement(request, document.createElement('video'))
    },
    audio: function (request) {
      return loadElement(request, document.createElement('audio'))
    }
  }

  // First we parse all objects in order to verify that all type information
  // is correct
  var pending = Object.keys(manifest).map(function (name) {
    var request = manifest[name]
    if (typeof request === 'string') {
      request = {
        src: request
      }
    } else if (typeof request !== 'object' || !request) {
      raise('invalid asset definition "' + name + '"')
    }

    checkType(request, manifestParameters, 'asset "' + name + '"')

    function getParameter (prop, accepted, init) {
      var value = init
      if (prop in request) {
        value = request[prop]
      }
      if (accepted.indexOf(value) < 0) {
        raise('invalid ' + prop + ' "' + value + '" for asset "' + name + '", possible values: ' + accepted)
      }
      return value
    }

    function getString (prop, required, init) {
      var value = init
      if (prop in request) {
        value = request[prop]
      } else if (required) {
        raise('missing ' + prop + ' for asset "' + name + '"')
      }
      if (typeof value !== 'string') {
        raise('invalid ' + prop + ' for asset "' + name + '", must be a string')
      }
      return value
    }

    function getParseFunc (name, dflt) {
      if (name in request.parser) {
        var result = request.parser[name]
        if (typeof result !== 'function') {
          raise('invalid parser callback ' + name + ' for asset "' + name + '"')
        }
        return result
      } else {
        return dflt
      }
    }

    var parser = {}
    if ('parser' in request) {
      if (typeof request.parser === 'function') {
        parser = {
          data: request.parser
        }
      } else if (typeof request.parser === 'object' && request.parser) {
        checkType(parser, parserParameters, 'parser for asset "' + name + '"')
        if (!('onData' in parser)) {
          raise('missing onData callback for parser in asset "' + name + '"')
        }
        parser = {
          data: getParseFunc('onData'),
          done: getParseFunc('onDone')
        }
      } else {
        raise('invalid parser for asset "' + name + '"')
      }
    }

    return {
      name: name,
      type: getParameter('type', Object.keys(loaders), 'text'),
      stream: !!request.stream,
      credentials: !!request.credentials,
      src: getString('src', true, ''),
      parser: parser
    }
  }).map(function (request) {
    return (loaders[request.type])(request)
  })

  function abort (message) {
    if (state === STATE_ERROR || state === STATE_COMPLETE) {
      return
    }
    state = STATE_ERROR
    pending.forEach(function (loader) {
      loader.cancel()
    })
    if (onError) {
      if (typeof message === 'string') {
        onError(new Error('resl: ' + message))
      } else {
        onError(message)
      }
    } else {
      console.error('resl error:', message)
    }
  }

  function notifyProgress (message) {
    if (state === STATE_ERROR || state === STATE_COMPLETE) {
      return
    }

    var progress = 0
    var numReady = 0
    pending.forEach(function (loader) {
      if (loader.ready) {
        numReady += 1
      }
      progress += loader.progress
    })

    if (numReady === pending.length) {
      state = STATE_COMPLETE
      onDone(assets)
    } else {
      if (onProgress) {
        onProgress(progress / pending.length, message)
      }
    }
  }

  if (pending.length === 0) {
    setTimeout(function () {
      notifyProgress('done')
    }, 1)
  }
}

},{}],165:[function(require,module,exports){
module.exports = scrollToAnchor

function scrollToAnchor (anchor, options) {
  if (anchor) {
    try {
      var el = document.querySelector(anchor)
      if (el) el.scrollIntoView(options)
    } catch (e) {}
  }
}

},{}],166:[function(require,module,exports){
'use strict'

var parseUnit = require('parse-unit')

module.exports = toPX

var PIXELS_PER_INCH = getSizeBrutal('in', document.body) // 96


function getPropertyInPX(element, prop) {
  var parts = parseUnit(getComputedStyle(element).getPropertyValue(prop))
  return parts[0] * toPX(parts[1], element)
}

//This brutal hack is needed
function getSizeBrutal(unit, element) {
  var testDIV = document.createElement('div')
  testDIV.style['height'] = '128' + unit
  element.appendChild(testDIV)
  var size = getPropertyInPX(testDIV, 'height') / 128
  element.removeChild(testDIV)
  return size
}

function toPX(str, element) {
  if (!str) return null

  element = element || document.body
  str = (str + '' || 'px').trim().toLowerCase()
  if(element === window || element === document) {
    element = document.body
  }

  switch(str) {
    case '%':  //Ambiguous, not sure if we should use width or height
      return element.clientHeight / 100.0
    case 'ch':
    case 'ex':
      return getSizeBrutal(str, element)
    case 'em':
      return getPropertyInPX(element, 'font-size')
    case 'rem':
      return getPropertyInPX(document.body, 'font-size')
    case 'vw':
      return window.innerWidth/100
    case 'vh':
      return window.innerHeight/100
    case 'vmin':
      return Math.min(window.innerWidth, window.innerHeight) / 100
    case 'vmax':
      return Math.max(window.innerWidth, window.innerHeight) / 100
    case 'in':
      return PIXELS_PER_INCH
    case 'cm':
      return PIXELS_PER_INCH / 2.54
    case 'mm':
      return PIXELS_PER_INCH / 25.4
    case 'pt':
      return PIXELS_PER_INCH / 72
    case 'pc':
      return PIXELS_PER_INCH / 6
    case 'px':
      return 1
  }

  // detect number of units
  var parts = parseUnit(str)
  if (!isNaN(parts[0]) && parts[1]) {
    var px = toPX(parts[1], element)
    return typeof px === 'number' ? parts[0] * px : null
  }

  return null
}

},{"parse-unit":160}],167:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var assert = require('assert')
var trie = require('./trie')

module.exports = Wayfarer

// create a router
// str -> obj
function Wayfarer (dft) {
  if (!(this instanceof Wayfarer)) return new Wayfarer(dft)

  var _default = (dft || '').replace(/^\//, '')
  var _trie = trie()

  emit._trie = _trie
  emit.on = on
  emit.emit = emit
  emit.match = match
  emit._wayfarer = true

  return emit

  // define a route
  // (str, fn) -> obj
  function on (route, cb) {
    assert.equal(typeof route, 'string')
    assert.equal(typeof cb, 'function')

    route = route || '/'

    if (cb._wayfarer && cb._trie) {
      _trie.mount(route, cb._trie.trie)
    } else {
      var node = _trie.create(route)
      node.cb = cb
      node.route = route
    }

    return emit
  }

  // match and call a route
  // (str, obj?) -> null
  function emit (route) {
    var matched = match(route)

    var args = new Array(arguments.length)
    args[0] = matched.params
    for (var i = 1; i < args.length; i++) {
      args[i] = arguments[i]
    }

    return matched.cb.apply(matched.cb, args)
  }

  function match (route) {
    assert.notEqual(route, undefined, "'route' must be defined")

    var matched = _trie.match(route)
    if (matched && matched.cb) return new Route(matched)

    var dft = _trie.match(_default)
    if (dft && dft.cb) return new Route(dft)

    throw new Error("route '" + route + "' did not match")
  }

  function Route (matched) {
    this.cb = matched.cb
    this.route = matched.route
    this.params = matched.params
  }
}

},{"./trie":168,"assert":142}],168:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var assert = require('assert')

module.exports = Trie

// create a new trie
// null -> obj
function Trie () {
  if (!(this instanceof Trie)) return new Trie()
  this.trie = { nodes: {} }
}

// create a node on the trie at route
// and return a node
// str -> obj
Trie.prototype.create = function (route) {
  assert.equal(typeof route, 'string', 'route should be a string')
  // strip leading '/' and split routes
  var routes = route.replace(/^\//, '').split('/')

  function createNode (index, trie) {
    var thisRoute = (has(routes, index) && routes[index])
    if (thisRoute === false) return trie

    var node = null
    if (/^:|^\*/.test(thisRoute)) {
      // if node is a name match, set name and append to ':' node
      if (!has(trie.nodes, '$$')) {
        node = { nodes: {} }
        trie.nodes.$$ = node
      } else {
        node = trie.nodes.$$
      }

      if (thisRoute[0] === '*') {
        trie.wildcard = true
      }

      trie.name = thisRoute.replace(/^:|^\*/, '')
    } else if (!has(trie.nodes, thisRoute)) {
      node = { nodes: {} }
      trie.nodes[thisRoute] = node
    } else {
      node = trie.nodes[thisRoute]
    }

    // we must recurse deeper
    return createNode(index + 1, node)
  }

  return createNode(0, this.trie)
}

// match a route on the trie
// and return the node
// str -> obj
Trie.prototype.match = function (route) {
  assert.equal(typeof route, 'string', 'route should be a string')

  var routes = route.replace(/^\//, '').split('/')
  var params = {}

  function search (index, trie) {
    // either there's no match, or we're done searching
    if (trie === undefined) return undefined
    var thisRoute = routes[index]
    if (thisRoute === undefined) return trie

    if (has(trie.nodes, thisRoute)) {
      // match regular routes first
      return search(index + 1, trie.nodes[thisRoute])
    } else if (trie.name) {
      // match named routes
      try {
        params[trie.name] = decodeURIComponent(thisRoute)
      } catch (e) {
        return search(index, undefined)
      }
      return search(index + 1, trie.nodes.$$)
    } else if (trie.wildcard) {
      // match wildcards
      try {
        params.wildcard = decodeURIComponent(routes.slice(index).join('/'))
      } catch (e) {
        return search(index, undefined)
      }
      // return early, or else search may keep recursing through the wildcard
      return trie.nodes.$$
    } else {
      // no matches found
      return search(index + 1)
    }
  }

  var node = search(0, this.trie)

  if (!node) return undefined
  node = Object.assign({}, node)
  node.params = params
  return node
}

// mount a trie onto a node at route
// (str, obj) -> null
Trie.prototype.mount = function (route, trie) {
  assert.equal(typeof route, 'string', 'route should be a string')
  assert.equal(typeof trie, 'object', 'trie should be a object')

  var split = route.replace(/^\//, '').split('/')
  var node = null
  var key = null

  if (split.length === 1) {
    key = split[0]
    node = this.create(key)
  } else {
    var head = split.join('/')
    key = split[0]
    node = this.create(head)
  }

  Object.assign(node.nodes, trie.nodes)
  if (trie.name) node.name = trie.name

  // delegate properties from '/' to the new node
  // '/' cannot be reached once mounted
  if (node.nodes['']) {
    Object.keys(node.nodes['']).forEach(function (key) {
      if (key === 'nodes') return
      node[key] = node.nodes[''][key]
    })
    Object.assign(node.nodes, node.nodes[''].nodes)
    delete node.nodes[''].nodes
  }
}

function has (object, property) {
  return Object.prototype.hasOwnProperty.call(object, property)
}

},{"assert":142}],169:[function(require,module,exports){
(function (global){(function (){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.NtscVideo = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],"/index.js":[function(require,module,exports){
var glsl = require('glslify')

module.exports = TV

function TV(opts) {
  if (!(this instanceof TV)) return new TV(opts)
  this._regl = opts.regl
  var widths = Array.isArray(opts.width)
    ? opts.width : [ opts.width || 1024, opts.width || 1024]
  this.shadowMask = opts.shadowMask !== undefined ? opts.shadowMask : 0.1
  this._mtick = 0
  this._dtick = 0

  this._fbOpts = [262,263,262,263,525].map((height,i) => ({
    color: this._regl.texture({
      width: widths[i%2],
      height,
    })
  }))
  this._fbo = this._fbOpts.map(this._regl.framebuffer)
  this._nlines = 0
  this._src = 0
  this._dst = 0
  this._src0 = 0
  this._src1 = 0

  this._setfb = this._regl({
    framebuffer: () => this._fbo[this._dst]
  })
  this._setf = this._regl({
    framebuffer: () => this._fbo[this._dst],
    uniforms: {
      signal: () => this._fbo[this._src],
      n_lines: () => this._nlines,
    }
  })
  this._setd = this._regl({
    uniforms: {
      tick: () => this._dtick
    }
  })

  this._size = [0,0]
  this._mdraw = this._regl({
    frag: glsl(["\n      precision highp float;\n#define GLSLIFY 1\n\n      vec3 rgb_to_yiq_1540259130(vec3 rgb) {\n  float y = 0.30*rgb.x + 0.59*rgb.y + 0.11*rgb.z;\n  return vec3(\n    y,\n    -0.27*(rgb.z-y) + 0.74*(rgb.x-y),\n    0.41*(rgb.z-y) + 0.48*(rgb.x-y)\n  );\n}\n\n//const float FSC = 5e6*63.0/88.0;\nconst float FSC = 3579545.5; // 5e6*63.0/88.0\nconst float PI = 3.1415927410125732;\nconst float L_TIME_1604150559 = 6.35555e-5;\nconst float P_TIME_1604150559 = 5.26e-5;\nconst float FP_TIME_1604150559 = 1.5e-6;\nconst float SP_TIME_1604150559 = 4.7e-6;\nconst float BW_TIME_1604150559 = 0.6e-6;\nconst float CB_TIME_1604150559 = 2.5e-6;\nconst float BP_TIME_1604150559 = 1.6e-6;\nconst float Q_TIME_1604150559 = 2.71e-5;\nconst float EQ_TIME_1604150559 = 2.3e-6;\n\nfloat modulate_t_1604150559(float t, vec3 rgb) {\n  vec3 yiq = rgb_to_yiq_1540259130(rgb);\n  float s = sin(2.0*PI*t*FSC);\n  float c = cos(2.0*PI*t*FSC);\n  return yiq.x*(100.0-7.5) + (c*yiq.y + s*yiq.z)*20.0 + 7.5;\n}\n\nfloat modulate_uv_1604150559(vec2 uv, float n_lines, vec3 rgb) {\n  float v_lines = n_lines - 20.0;\n  float t = uv.x*P_TIME_1604150559 + floor(uv.y*(v_lines-1.0)+0.5)*P_TIME_1604150559;\n  return modulate_t_1604150559(t, rgb);\n}\n\nfloat modulate(vec2 v, float n_lines, sampler2D picture) {\n  float v_lines = n_lines - 20.0;\n  float line = floor((1.0-v.y)*n_lines+0.5);\n  vec2 uv = v\n    * vec2(L_TIME_1604150559/P_TIME_1604150559, n_lines/v_lines)\n    - vec2((L_TIME_1604150559-P_TIME_1604150559)/P_TIME_1604150559, 0);\n  float hblank = step(v.x, (L_TIME_1604150559-P_TIME_1604150559)/L_TIME_1604150559);\n  float vblank = step(1.0-(n_lines-v_lines)/n_lines, v.y);\n\n  float odd = mod(n_lines,2.0);\n  float vsync_pre = step(0.0,line)*step(line, 3.0);\n  float vsync_pulse = step(3.0,line)*step(line,6.0);\n  float vsync_post = step(6.0,line)*step(line,9.0);\n\n  float vt = 0.0;\n  float fporch = step(v.x,FP_TIME_1604150559/L_TIME_1604150559);\n  vt += FP_TIME_1604150559/L_TIME_1604150559;\n  float syncpulse = step(vt,v.x) * step(v.x,vt+SP_TIME_1604150559/L_TIME_1604150559);\n  vt += SP_TIME_1604150559/L_TIME_1604150559;\n  float breezeway = step(vt,v.x) * step(v.x,vt+BW_TIME_1604150559/L_TIME_1604150559);\n  vt += BW_TIME_1604150559/L_TIME_1604150559;\n  float colorburst = step(vt,v.x) * step(v.x,vt+CB_TIME_1604150559/L_TIME_1604150559);\n  vt += CB_TIME_1604150559/L_TIME_1604150559;\n  float bporch = step(vt,v.x) * step(v.x,vt+BP_TIME_1604150559/L_TIME_1604150559);\n  vec3 rgb = texture2D(picture,uv).xyz;\n  float signal = modulate_uv_1604150559(v, n_lines, rgb);\n  signal *= 1.0 - hblank;\n  signal -= 40.0 * syncpulse;\n  signal += sin(2.0*PI*FSC)*20.0*colorburst;\n  signal *= 1.0 - vblank;\n  signal -= 40.0 * vsync_pre * step(mod(v.x,0.5)*L_TIME_1604150559,EQ_TIME_1604150559);\n  signal -= 40.0 * vsync_pulse * step(mod(v.x,0.5)*L_TIME_1604150559,Q_TIME_1604150559);\n  signal -= 40.0 * vsync_post * step(mod(v.x,0.5)*L_TIME_1604150559,EQ_TIME_1604150559);\n  return (signal + 40.0) / (120.0+40.0);\n}\n\n      varying vec2 vpos;\n      uniform float n_lines;\n      uniform sampler2D src;\n      void main () {\n        gl_FragColor = vec4(modulate(vpos*0.5+0.5, n_lines, src),0,0,1);\n      }\n    ",""]),
    vert: `
      precision highp float;
      attribute vec2 position;
      varying vec2 vpos;
      void main () {
        vpos = position;
        gl_Position = vec4(position,0,1);
      }
    `,
    attributes: { position: [-4,-4,-4,+4,+4,+0] },
    elements: [0,1,2],
    framebuffer: this._regl.prop('framebuffer'),
    uniforms: {
      n_lines: this._regl.prop('n_lines'),
      src: () => this._fbo[4]
    }
  })
  this._ddraw = this._regl({
    frag: glsl(["\n      precision highp float;\n#define GLSLIFY 1\n\n      const float FSC = 3579545.5; //5e6*63.0/88.0;\nconst float PI_0 = 3.1415927410125732;\nconst float M = 2.7936508217862865e-7; // 1.0/FSC;\nconst float T_LINE_1604150559 = 5.26e-5;\nconst float L_TIME_1604150559 = 6.35555e-5;\nconst float P_TIME_1604150559 = 5.26e-5;\nconst float RSQ3 = 0.5773502588272095; // 1.0/sqrt(3.0);\n\nvec3 yiq_to_rgb_1540259130(vec3 yiq) {\n  return vec3(\n    yiq.x + 0.9469*yiq.y + 0.6236*yiq.z,\n    yiq.x - 0.2748*yiq.y - 0.6357*yiq.z,\n    yiq.x - 1.1*yiq.y + 1.7*yiq.z\n  );\n}\n\nvec4 read(float t, float n_lines, sampler2D signal) {\n  return texture2D(signal, vec2(\n    mod(t,T_LINE_1604150559)/T_LINE_1604150559,\n    floor(t/T_LINE_1604150559)/(n_lines-1.0)\n  ));\n}\n\nvec3 demodulate_t_1604150559(float t, float n_lines, sampler2D signal) {\n  float f = 1.0, m = 2.0*f;\n  float ti = t - mod(t,M/m);\n  float tq = t - mod(t,M/m) + M*0.25/f;\n  float ta = t - mod(t,M/m) + M*0.50/f;\n\n  float signal_i = read(ti, n_lines, signal).x*(120.0+40.0)-40.0;\n  float signal_q = read(tq, n_lines, signal).x*(120.0+40.0)-40.0;\n  float signal_a = read(ta, n_lines, signal).x*(120.0+40.0)-40.0;\n  float signal_b = read(t, n_lines, signal).x*(120.0+40.0)-40.0;\n\n  float min_y = min(signal_i,signal_q);\n  min_y = min(min_y,signal_a);\n  float max_y = max(signal_i, signal_q);\n  max_y = max(max_y,signal_a);\n  float y = min_y*0.5 + max_y*0.5;\n\n  float s = sin(2.0*PI_0*FSC*t*f);\n  float c = cos(2.0*PI_0*FSC*t*f);\n  vec3 yiq = vec3(\n    (y-7.5)/(100.0-7.5),\n    (signal_i-y)/20.0 * sign(s),\n    (signal_q-y)/20.0 * sign(s)\n  );\n  vec3 rgb = clamp(vec3(0), vec3(1), yiq_to_rgb_1540259130(yiq));\n  float d = max(rgb.x,max(rgb.y,rgb.z))-min(rgb.x,min(rgb.y,rgb.z));\n  float v = (signal_b-7.5+(c*yiq.y+s*yiq.z)*20.0)/(100.0-7.5)*2.0-1.0;\n  float p = pow(abs(v),2.2)*sign(v)*pow(max(d,length(rgb)*RSQ3),2.2);\n  return clamp(vec3(0), vec3(1), mix(rgb,vec3(p*0.5+0.5),abs(p)));\n}\n\nvec3 demodulate_uv_1604150559(vec2 uv, float n_lines, sampler2D signal) {\n  float v_lines = n_lines - 20.0;\n  float t = uv.x*T_LINE_1604150559 + floor(uv.y*(v_lines-1.0)+0.5)*T_LINE_1604150559;\n  return demodulate_t_1604150559(t, v_lines, signal);\n}\n\nvec3 demodulate(vec2 v, vec3 n, sampler2D signal) {\n  float v_lines = n.x - 20.0;\n  vec2 uv = v * vec2(P_TIME_1604150559/L_TIME_1604150559, v_lines/n.x) - vec2(P_TIME_1604150559/L_TIME_1604150559, 0);\n  float odd = floor(mod(uv.x*n.y,2.0));\n  float sy = odd/n.z*0.5;\n  vec2 ruv = vec2(\n    floor(uv.x*n.y+0.5)/n.y,\n    floor(uv.y*n.z+odd*0.5)/n.z\n  );\n  return demodulate_uv_1604150559(ruv, n.x, signal);\n}\n\n      uniform sampler2D signal0, signal1;\n      varying vec2 vpos;\n      uniform float tick, shadowMask;\n      const float PI = ",";\n      const float L_TIME = 6.35555e-5;\n      const float P_TIME = 5.26e-5;\n      void main () {\n        vec2 v = vpos*0.5+0.5;\n        vec2 r = vec2(720, 485);\n        vec3 rgb0 = demodulate(v, vec3(262,r), signal0);\n        vec3 rgb1 = demodulate(v, vec3(263,r), signal1);\n        vec3 rgb = mix(rgb0,rgb1,sin(v.y*PI*2.0*242.5)*0.5+0.5);\n        float sy = floor(mod(v.x*r.x,2.0))/r.x*0.5;\n        vec3 mask = vec3(\n          step(mod(v.x*r.x*3.0+2.0,3.0),1.0),\n          step(mod(v.x*r.x*3.0+1.0,3.0),1.0),\n          step(mod(v.x*r.x*3.0+0.0,3.0),1.0)\n        ) * (1.0-step(mod(((v.y+sy)*r.y)*3.0,3.0),0.5));\n        vec3 c = mix(rgb,rgb*mask,shadowMask);\n        //vec3 c = vec3(texture2D(signal0,v).x);\n        gl_FragColor = vec4(c,1);\n      }\n    ",""],Math.PI),
    vert: `
      precision highp float;
      attribute vec2 position;
      varying vec2 vpos;
      void main () {
        vpos = position;
        gl_Position = vec4(position,0,1);
      }
    `,
    attributes: { position: [-4,-4,-4,+4,+4,+0] },
    elements: [0,1,2],
    uniforms: {
      signal0: this._regl.prop('signal0'),
      signal1: this._regl.prop('signal1'),
      tick: this._regl.context('tick'),
      size: (context) => {
        this._size[0] = context.viewportWidth
        this._size[1] = context.viewportWidth
        return this._size
      },
      shadowMask: () => this.shadowMask
    }
  })
}

TV.prototype._updateFb = function (n) {
  this._fbo[n](this._fbOpts[n])
}

TV.prototype.modulate = function (fn) {
  this._src0 = 0
  this._src1 = 1
  this._updateFb(4)
  this._dst = 4
  this._setfb(fn)
  this._dst = this._mtick%2
  this._updateFb(this._dst)
  this._nlines = this._mtick%2 ? 263 : 262
  this._mdraw({
    n_lines: this._nlines,
    framebuffer: this._fbo[this._dst]
  })
  this._mtick++
}

TV.prototype.filter = function (fn) {
  this._src = this._dst
  this._dst += 2
  this._updateFb(this._dst)
  this._setf(fn)
  this._src0 += 2
  this._src1 += 2
}

/* // todo:
TV.prototype.load = function (opts) {
  // opts.width
  // opts.height
  // opts.data
}

TV.prototype.sync = function (data) {
  this.vsync()
  this.hsync()
}

TV.prototype.vsync = function (data) {
}

TV.prototype.hsync = function (data) {
}
*/

TV.prototype.demodulate = function () {
  this._regl.poll()
  this._regl.clear({ color: [0,0,0,1], depth: true })
  this._setd(() => {
    this._ddraw({
      signal0: this._fbo[this._src0],
      signal1: this._fbo[this._src1],
    })
  })
}

},{"glslify":1}]},{},[])("/index.js")
});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"glslify":170}],170:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"dup":136}]},{},[14]);
</script>
</html>
